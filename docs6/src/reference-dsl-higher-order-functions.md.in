# DSL higher-order functions

A _higher-order function_ is one which takes [another function](reference-dsl-user-defined-functions.md)
as an argument.
As of [Miller 6](new-in-miller-6.md) you can use
[`select`](reference-dsl-builtin-functions.md#select),
[`apply`](reference-dsl-builtin-functions.md#apply),
[`reduce`](reference-dsl-builtin-functions.md#reduce),
[`fold`](reference-dsl-builtin-functions.md#fold), and
[`sort`](reference-dsl-builtin-functions.md#sort) to express flexible,
intuitive operations on arrays and maps, as an alternative to things which
would otherwise require for-loops.

See also the [`get_keys`](reference-dsl-builtin-functions.md#get_keys) and
[`get_values`](reference-dsl-builtin-functions.md#get_values) functions which,
when given a map, return an array of its keys or an array of its values,
respectively.

## select

The [`select`](reference-dsl-builtin-functions.md#select) function takes a map
or array as its first argument and a function as second argument.  It includes
each input element in the ouptut if the function returns true.

For arrays, that function should take one argument, for array element; for
maps, it should take two, for map-element key and value. In either case it
should return a boolean.

A perhaps helpful analogy: the `select` function is to arrays and maps as the
[`filter`](reference-verbs.md#filter) is to records.

Array examples:

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_array = [2, 9, 10, 3, 1, 4, 5, 8, 7, 6];

    print "Original:";
    print my_array;

    print;
    print "Evens:";
    print select(my_array, func (e) { return e % 2 == 0});

    print;
    print "Odds:";
    print select(my_array, func (e) { return e % 2 == 1});
    print;
  }
'
GENMD_EOF

Map examples:

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_map = {"cubit": 823, "dale": 13, "apple": 199, "ember": 191, "bottle": 107};
    print "Original:";
    print my_map;

    print;
    print "Keys with an 'o' in them:";
    print select(my_map, func (k,v) { return k =~ "o"});

    print;
    print "Values with last digit >= 5:";
    print select(my_map, func (k,v) { return v % 10 >= 5});
  }
'
GENMD_EOF

## apply

The [`apply`](reference-dsl-builtin-functions.md#apply) function takes a map
or array as its first argument and a function as second argument.  It applies
the function to each element of the array or map.

For arrays, the function should take one argument, for array element; it should
return a new element. For maps, it should take two, for map-element key and
value. It should return a new key-value pair (i.e. a single-entry map).

A perhaps helpful analogy: the `apply` function is to arrays and maps as the
[`put`](reference-verbs.md#put) is to records.

Array examples:

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_array = [2, 9, 10, 3, 1, 4, 5, 8, 7, 6];
    print "Original:";
    print my_array;

    print;
    print "Squares:";
    print apply(my_array, func(e) { return e**2 });

    print;
    print "Cubes:";
    print apply(my_array, func(e) { return e**3 });

    print;
    print "Sorted cubes:";
    print sort(apply(my_array, func(e) { return e**3 }));
  }
'
GENMD_EOF

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_map = {"cubit": 823, "dale": 13, "apple": 199, "ember": 191, "bottle": 107};
    print "Original:";
    print my_map;

    print;
    print "Squared values:";
    print apply(my_map, func(k,v) { return {k: v**2} });

    print;
    print "Cubed values, sorted by key:";
    print sort(apply(my_map, func(k,v) { return {k: v**3} }));

    print;
    print "Same, with upcased keys:";
    print sort(apply(my_map, func(k,v) { return {toupper(k): v**3} }));
  }
'
GENMD_EOF

## reduce

The [`reduce`](reference-dsl-builtin-functions.md#reduce) function takes a map
or array as its first argument and a function as second argument. It accumulates entries into a final
output -- for example, sum or product.

For arrays, the function should take two
arguments, for accumulated value and array element; for maps, it should take
three, for accumulated value, map-element key, and map-element value. In either
case it should return the updated accumulator.

The start value for the accumulator is the first element for arrays, or the
first element's value (not key) for maps.

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_array = [2, 9, 10, 3, 1, 4, 5, 8, 7, 6];

    print "Original:";
    print my_array;

    print;
    print "First:";
    print reduce(my_array, func (acc,e) { return acc });

    print;
    print "Last:";
    print reduce(my_array, func (acc,e) { return e });

    print;
    print "Sum:";
    print reduce(my_array, func (acc,e) { return acc + e });

    print;
    print "Product:";
    print reduce(my_array, func (acc,e) { return acc * e });

    print;
    print "Concatenation:";
    print reduce(my_array, func (acc,e) { return acc. "," . e });
  }
'
GENMD_EOF

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_map = {"cubit": 823, "dale": 13, "apple": 199, "ember": 191, "bottle": 107};
    print "Original:";
    print my_map;

    print;
    print "First:";
    print reduce(my_map, func (acck,accv,ek,ev) { return {acck: accv}});

    print;
    print "Last:";
    print reduce(my_map, func (acck,accv,ek,ev) { return {ek: ev}});

    print;
    print "Concatenate keys and values:";
    print reduce(my_map, func (acck,accv,ek,ev) { return {acck . "," . ek: accv . "," . ev}});

    print;
    print "Sum of values:";
    print reduce(my_map, func (acck,accv,ek,ev) { return {"sum": accv + ev }});

    print;
    print "Product of values:";
    print reduce(my_map, func (acck,accv,ek,ev) { return {"product": accv * ev }});

    print;
    print "String-join of values:";
    print reduce(my_map, func (acck,accv,ek,ev) { return {"joined": accv . "," . ev }});
  }
'
GENMD_EOF

## fold

The [`fold`](reference-dsl-builtin-functions.md#fold) function is the same as
`reduce`, except that instead of the starting value for the accumulation being
taken from the first entry of the array/map, you specify it as the third
argument.

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_array = [2, 9, 10, 3, 1, 4, 5, 8, 7, 6];

    print "Original:";
    print my_array;

    print;
    print "Sum with reduce:";
    print reduce(my_array, func (acc,e) { return acc + e });

    print;
    print "Sum with fold and 0 initial value:";
    print fold(my_array, func (acc,e) { return acc + e }, 0);

    print;
    print "Sum with fold and 1000000 initial value:";
    print fold(my_array, func (acc,e) { return acc + e }, 1000000);
  }
'
GENMD_EOF

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_map = {"cubit": 823, "dale": 13, "apple": 199, "ember": 191, "bottle": 107};
    print "Original:";
    print my_map;

    print;
    print "Sum of values with reduce:";
    print reduce(my_map, func (acck,accv,ek,ev) { return {"sum": accv + ev} });

    print;
    print "Sum of values with fold and 0 initial value:";
    print fold(my_map, func (acck,accv,ek,ev) { return {"sum": accv + ev} }, {"sum": 0});

    print;
    print "Sum of values with fold and 1000000 initial value:";
    print fold(my_map, func (acck,accv,ek,ev) { return {"sum": accv + ev} }, {"sum": 1000000});
  }
'
GENMD_EOF

## sort

The [`sort`](reference-dsl-builtin-functions.md#sort) function takes a map or
array as its first argument, and it can take a function as second argument.
Unlike the other higher-order functions, the second argument can be omitted
when a natual ordering is desired -- ordered by array element for arrays, or by
key for maps.

As a second option, character flags such as `r` for reverse or `c` for
case-folded lexical sort can be supplied as the second argument.

As a third option, a function can be supplied as the second argument.

For arrays, that function should take two arguments `a` and `b`, returning a
negative, zero, or positive number as `a<b`, `a==b`, or `a>b` respectively.
For maps, the function should take four arguments `ak`, `av`, `bk`, and `bv`,
again returning negative, zero, or positive, using `a` and `b`'s keys and
values.

Array examples:

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_array = [2, 9, 10, 3, 1, 4, 5, 8, 7, 6];

    print "Original:";
    print my_array;

    print;
    print "Ascending:";
    print sort(my_array);
    print sort(my_array, func (a,b) { return a <=> b });

    print;
    print "Descending:";
    print sort(my_array, "r");
    print sort(my_array, func (a,b) { return b <=> a });
  }
'
GENMD_EOF

Map examples:

GENMD_RUN_COMMAND
mlr -n put '
  end {
    my_map = {"cubit": 823, "dale": 13, "apple": 199, "ember": 191, "bottle": 107};

    print "Original:";
    print my_map;

    print;
    print "Ascending by key:";
    print sort(my_map);
    print sort(my_map, func(ak,av,bk,bv) { return ak <=> bk });

    print;
    print "Descending by key:";
    print sort(my_map, "r");
    print sort(my_map, func(ak,av,bk,bv) { return bk <=> ak });

    print;
    print "Ascending by value:";
    print sort(my_map, func(ak,av,bk,bv) { return av <=> bv });

    print;
    print "Descending by value:";
    print sort(my_map, func(ak,av,bk,bv) { return bv <=> av });
  }
'
GENMD_EOF

Please see the [sorting page](sorting.md) for more examples.

## Caveats

### Remember return

From other languages it's easy to accidentially write

GENMD_RUN_COMMAND_TOLERATING_ERROR
mlr -n put 'end { print select([1,2,3,4,5], func (e) { e >= 3 })}'
GENMD_EOF

instead of

GENMD_RUN_COMMAND
mlr -n put 'end { print select([1,2,3,4,5], func (e) { return e >= 3 })}'
GENMD_EOF

### No IIFEs

As of September 2021, immediately invoked function expressions (IIFEs) are not part of the Miller DSL's grammar. For example, this doesn't work yet:

GENMD_RUN_COMMAND_TOLERATING_ERROR
mlr -n put '
  end {
    x = 3;
    y = (func (e) { return e**7 })(x);
    print y;
  }
'
GENMD_EOF

but this does:

GENMD_RUN_COMMAND
mlr -n put '
  end {
    x = 3;
    f = func (e) { return e**7 };
    y = f(x);
    print y;
  }
'
GENMD_EOF

### Built-in functions currently unsupported as arguments

[Built-in functions](reference-dsl-user-defined-functions.md) are, as of
September 2021, a bit separate from [user-defined
functions](reference-dsl-builtin-functions.md) internally to Miller, and can't
be used directly as arguments to higher-order functions.

For example, this doesn't work yet:

GENMD_RUN_COMMAND_TOLERATING_ERROR
mlr -n put '
  end {
    notches = [0,1,2,3];
    radians = apply(notches, func (e) { return e * M_PI / 8 });
    cosines = apply(radians, cos);
    print cosines;
  }
'
GENMD_EOF

but this does:

GENMD_RUN_COMMAND
mlr -n put '
  end {
    notches = [0,1,2,3];
    radians = apply(notches, func (e) { return e * M_PI / 8 });
    # cosines = apply(radians, cos);
    cosines = apply(radians, func (e) { return cos(e) });
    print cosines;
  }
'
GENMD_EOF
