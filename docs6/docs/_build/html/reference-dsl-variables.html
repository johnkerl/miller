
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DSL reference: variables &#8212; Miller 6.0.0-alpha documentation</title>
    
    <link rel="stylesheet" href="_static/scrolls.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/language_data.js"></script>
    <script src="_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="DSL reference: operators" href="reference-dsl-operators.html" />
    <link rel="prev" title="DSL reference: syntax" href="reference-dsl-syntax.html" /> 
  </head><body>
    <div id="content">
      <div class="header">
        <h1 class="heading"><a href="index.html"
          title="back to the documentation overview"><span>DSL reference: variables</span></a></h1>
      </div>
      <div class="relnav" role="navigation" aria-label="related navigation">
        <a href="reference-dsl-syntax.html">&laquo; DSL reference: syntax</a> |
        <a href="#">DSL reference: variables</a>
        | <a href="reference-dsl-operators.html">DSL reference: operators &raquo;</a>
      </div>
      <div id="contentwrapper">
        <div id="toc" role="navigation" aria-label="table of contents navigation">
          <h3>Table of Contents</h3>
          <ul>
<li><a class="reference internal" href="#">DSL reference: variables</a><ul>
<li><a class="reference internal" href="#built-in-variables">Built-in variables</a></li>
<li><a class="reference internal" href="#field-names">Field names</a></li>
<li><a class="reference internal" href="#positional-field-names">Positional field names</a></li>
<li><a class="reference internal" href="#out-of-stream-variables">Out-of-stream variables</a></li>
<li><a class="reference internal" href="#indexed-out-of-stream-variables">Indexed out-of-stream variables</a></li>
<li><a class="reference internal" href="#local-variables">Local variables</a></li>
<li><a class="reference internal" href="#map-literals">Map literals</a></li>
<li><a class="reference internal" href="#type-checking">Type-checking</a><ul>
<li><a class="reference internal" href="#type-test-and-type-assertion-expressions">Type-test and type-assertion expressions</a></li>
<li><a class="reference internal" href="#type-declarations-for-local-variables-function-parameter-and-function-return-values">Type-declarations for local variables, function parameter, and function return values</a></li>
</ul>
</li>
<li><a class="reference internal" href="#null-data-empty-and-absent">Null data: empty and absent</a></li>
<li><a class="reference internal" href="#aggregate-variable-assignments">Aggregate variable assignments</a></li>
<li><a class="reference internal" href="#keywords-for-filter-and-put">Keywords for filter and put</a></li>
</ul>
</li>
</ul>

        </div>
        <div role="main">
        
  <div class="section" id="dsl-reference-variables">
<h1>DSL reference: variables<a class="headerlink" href="#dsl-reference-variables" title="Permalink to this headline">¶</a></h1>
<p>Miller has the following kinds of variables:</p>
<p><strong>Built-in variables</strong> such as <code class="docutils literal notranslate"><span class="pre">NF</span></code>, <code class="docutils literal notranslate"><span class="pre">NF</span></code>, <code class="docutils literal notranslate"><span class="pre">FILENAME</span></code>, <code class="docutils literal notranslate"><span class="pre">M_PI</span></code>, and <code class="docutils literal notranslate"><span class="pre">M_E</span></code>.  These are all capital letters and are read-only (although some of them change value from one record to another).</p>
<p><strong>Fields of stream records</strong>, accessed using the <code class="docutils literal notranslate"><span class="pre">$</span></code> prefix. These refer to fields of the current data-stream record. For example, in <code class="docutils literal notranslate"><span class="pre">echo</span> <span class="pre">x=1,y=2</span> <span class="pre">|</span> <span class="pre">mlr</span> <span class="pre">put</span> <span class="pre">'$z</span> <span class="pre">=</span> <span class="pre">$x</span> <span class="pre">+</span> <span class="pre">$y'</span></code>, <code class="docutils literal notranslate"><span class="pre">$x</span></code> and <code class="docutils literal notranslate"><span class="pre">$y</span></code> refer to input fields, and <code class="docutils literal notranslate"><span class="pre">$z</span></code> refers to a new, computed output field. In a few contexts, presented below, you can refer to the entire record as <code class="docutils literal notranslate"><span class="pre">$*</span></code>.</p>
<p><strong>Out-of-stream variables</strong> accessed using the <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> prefix. These refer to data which persist from one record to the next, including in <code class="docutils literal notranslate"><span class="pre">begin</span></code> and <code class="docutils literal notranslate"><span class="pre">end</span></code> blocks (which execute before/after the record stream is consumed, respectively). You use them to remember values across records, such as sums, differences, counters, and so on.  In a few contexts, presented below, you can refer to the entire out-of-stream-variables collection as <code class="docutils literal notranslate"><span class="pre">&#64;*</span></code>.</p>
<p><strong>Local variables</strong> are limited in scope and extent to the current statements being executed: these include function arguments, bound variables in for loops, and explicitly declared local variables.</p>
<p><strong>Keywords</strong> are not variables, but since their names are reserved, you cannot use these names for local variables.</p>
<div class="section" id="built-in-variables">
<h2>Built-in variables<a class="headerlink" href="#built-in-variables" title="Permalink to this headline">¶</a></h2>
<p>These are written all in capital letters, such as <code class="docutils literal notranslate"><span class="pre">NR</span></code>, <code class="docutils literal notranslate"><span class="pre">NF</span></code>, <code class="docutils literal notranslate"><span class="pre">FILENAME</span></code>, and only a small, specific set of them is defined by Miller.</p>
<p>Namely, Miller supports the following five built-in variables for <a class="reference internal" href="reference-dsl.html"><span class="doc">filter and put</span></a>, all <code class="docutils literal notranslate"><span class="pre">awk</span></code>-inspired: <code class="docutils literal notranslate"><span class="pre">NF</span></code>, <code class="docutils literal notranslate"><span class="pre">NR</span></code>, <code class="docutils literal notranslate"><span class="pre">FNR</span></code>, <code class="docutils literal notranslate"><span class="pre">FILENUM</span></code>, and <code class="docutils literal notranslate"><span class="pre">FILENAME</span></code>, as well as the mathematical constants <code class="docutils literal notranslate"><span class="pre">M_PI</span></code> and <code class="docutils literal notranslate"><span class="pre">M_E</span></code>.  Lastly, the <code class="docutils literal notranslate"><span class="pre">ENV</span></code> hashmap allows read access to environment variables, e.g.  <code class="docutils literal notranslate"><span class="pre">ENV[&quot;HOME&quot;]</span></code> or <code class="docutils literal notranslate"><span class="pre">ENV[&quot;foo_&quot;.$hostname]</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr filter &#39;FNR == 2&#39; data/small*
</span> a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
 1=pan,2=pan,3=1,4=0.3467901443380824,5=0.7268028627434533
 a=wye,b=eks,i=10000,x=0.734806020620654365,y=0.884788571337605134
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$fnr = FNR&#39; data/small*
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533,fnr=1
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797,fnr=2
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776,fnr=3
 a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463,fnr=4
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729,fnr=5
 1=a,2=b,3=i,4=x,5=y,fnr=1
 1=pan,2=pan,3=1,4=0.3467901443380824,5=0.7268028627434533,fnr=2
 1=eks,2=pan,3=2,4=0.7586799647899636,5=0.5221511083334797,fnr=3
 1=wye,2=wye,3=3,4=0.20460330576630303,5=0.33831852551664776,fnr=4
 1=eks,2=wye,3=4,4=0.38139939387114097,5=0.13418874328430463,fnr=5
 1=wye,2=pan,3=5,4=0.5732889198020006,5=0.8636244699032729,fnr=6
 a=pan,b=eks,i=9999,x=0.267481232652199086,y=0.557077185510228001,fnr=1
 a=wye,b=eks,i=10000,x=0.734806020620654365,y=0.884788571337605134,fnr=2
 a=pan,b=wye,i=10001,x=0.870530722602517626,y=0.009854780514656930,fnr=3
 a=hat,b=wye,i=10002,x=0.321507044286237609,y=0.568893318795083758,fnr=4
 a=pan,b=zee,i=10003,x=0.272054845593895200,y=0.425789896597056627,fnr=5
</pre></div>
</div>
<p>Their values of <code class="docutils literal notranslate"><span class="pre">NF</span></code>, <code class="docutils literal notranslate"><span class="pre">NR</span></code>, <code class="docutils literal notranslate"><span class="pre">FNR</span></code>, <code class="docutils literal notranslate"><span class="pre">FILENUM</span></code>, and <code class="docutils literal notranslate"><span class="pre">FILENAME</span></code> change from one record to the next as Miller scans through your input data stream. The mathematical constants, of course, do not change; <code class="docutils literal notranslate"><span class="pre">ENV</span></code> is populated from the system environment variables at the time Miller starts and is read-only for the remainder of program execution.</p>
<p>Their <strong>scope is global</strong>: you can refer to them in any <code class="docutils literal notranslate"><span class="pre">filter</span></code> or <code class="docutils literal notranslate"><span class="pre">put</span></code> statement. Their values are assigned by the input-record reader:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --csv put &#39;$nr = NR&#39; data/a.csv
</span> a,b,c,nr
 1,2,3,1
 4,5,6,2
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --csv repeat -n 3 then put &#39;$nr = NR&#39; data/a.csv
</span> a,b,c,nr
 1,2,3,1
 1,2,3,1
 1,2,3,1
 4,5,6,2
 4,5,6,2
 4,5,6,2
</pre></div>
</div>
<p>The <strong>extent</strong> is for the duration of the put/filter: in a <code class="docutils literal notranslate"><span class="pre">begin</span></code> statement (which executes before the first input record is consumed) you will find <code class="docutils literal notranslate"><span class="pre">NR=1</span></code> and in an <code class="docutils literal notranslate"><span class="pre">end</span></code> statement (which is executed after the last input record is consumed) you will find <code class="docutils literal notranslate"><span class="pre">NR</span></code> to be the total number of records ingested.</p>
<p>These are all <strong>read-only</strong> for the <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">put</span></code> and <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">filter</span></code> DSLs: they may be assigned from, e.g. <code class="docutils literal notranslate"><span class="pre">$nr=NR</span></code>, but they may not be assigned to: <code class="docutils literal notranslate"><span class="pre">NR=100</span></code> is a syntax error.</p>
</div>
<div class="section" id="field-names">
<h2>Field names<a class="headerlink" href="#field-names" title="Permalink to this headline">¶</a></h2>
<p>Names of fields within stream records must be specified using a <code class="docutils literal notranslate"><span class="pre">$</span></code> in <a class="reference internal" href="reference-dsl.html"><span class="doc">filter and put expressions</span></a>, even though the dollar signs don’t appear in the data stream itself. For integer-indexed data, this looks like <code class="docutils literal notranslate"><span class="pre">awk</span></code>’s <code class="docutils literal notranslate"><span class="pre">$1,$2,$3</span></code>, except that Miller allows non-numeric names such as <code class="docutils literal notranslate"><span class="pre">$quantity</span></code> or <code class="docutils literal notranslate"><span class="pre">$hostname</span></code>.  Likewise, enclose string literals in double quotes in <code class="docutils literal notranslate"><span class="pre">filter</span></code> expressions even though they don’t appear in file data.  In particular, <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">filter</span> <span class="pre">'$x==&quot;abc&quot;'</span></code> passes through the record <code class="docutils literal notranslate"><span class="pre">x=abc</span></code>.</p>
<p>If field names have <strong>special characters</strong> such as <code class="docutils literal notranslate"><span class="pre">.</span></code> then you can use braces, e.g. <code class="docutils literal notranslate"><span class="pre">'${field.name}'</span></code>.</p>
<p>You may also use a <strong>computed field name</strong> in square brackets, e.g.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> echo a=3,b=4 | mlr filter &#39;$[&quot;x&quot;] &lt; 0.5&#39;
</span></pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> echo s=green,t=blue,a=3,b=4 | mlr put &#39;$[$s.&quot;_&quot;.$t] = $a * $b&#39;
</span> s=green,t=blue,a=3,b=4,green_blue=12
</pre></div>
</div>
<p>Notes:</p>
<p>The names of record fields depend on the contents of your input data stream, and their values change from one record to the next as Miller scans through your input data stream.</p>
<p>Their <strong>extent</strong> is limited to the current record; their <strong>scope</strong> is the <code class="docutils literal notranslate"><span class="pre">filter</span></code> or <code class="docutils literal notranslate"><span class="pre">put</span></code> command in which they appear.</p>
<p>These are <strong>read-write</strong>: you can do <code class="docutils literal notranslate"><span class="pre">$y=2*$x</span></code>, <code class="docutils literal notranslate"><span class="pre">$x=$x+1</span></code>, etc.</p>
<p>Records are Miller’s output: field names present in the input stream are passed through to output (written to standard output) unless fields are removed with <code class="docutils literal notranslate"><span class="pre">cut</span></code>, or records are excluded with <code class="docutils literal notranslate"><span class="pre">filter</span></code> or <code class="docutils literal notranslate"><span class="pre">put</span> <span class="pre">-q</span></code>, etc. Simply assign a value to a field and it will be output.</p>
</div>
<div class="section" id="positional-field-names">
<h2>Positional field names<a class="headerlink" href="#positional-field-names" title="Permalink to this headline">¶</a></h2>
<p>Even though Miller’s main selling point is name-indexing, sometimes you really want to refer to a field name by its positional index (starting from 1).</p>
<p>Use <code class="docutils literal notranslate"><span class="pre">$[[3]]</span></code> to access the name of field 3.  More generally, any expression evaluating to an integer can go between <code class="docutils literal notranslate"><span class="pre">$[[</span></code> and <code class="docutils literal notranslate"><span class="pre">]]</span></code>.</p>
<p>Then using a computed field name, <code class="docutils literal notranslate"><span class="pre">$[</span> <span class="pre">$[[3]]</span> <span class="pre">]</span></code> is the value in the third field. This has the shorter equivalent notation <code class="docutils literal notranslate"><span class="pre">$[[[3]]]</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr cat data/small
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$[[3]] = &quot;NEW&quot;&#39; data/small
</span> a=pan,b=pan,NEW=1,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=pan,NEW=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,NEW=3,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=wye,NEW=4,x=0.38139939387114097,y=0.13418874328430463
 a=wye,b=pan,NEW=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$[[[3]]] = &quot;NEW&quot;&#39; data/small
</span> a=pan,b=pan,i=NEW,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=pan,i=NEW,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,i=NEW,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=wye,i=NEW,x=0.38139939387114097,y=0.13418874328430463
 a=wye,b=pan,i=NEW,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$NEW = $[[NR]]&#39; data/small
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533,NEW=a
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797,NEW=b
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776,NEW=i
 a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463,NEW=x
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729,NEW=y
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$NEW = $[[[NR]]]&#39; data/small
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533,NEW=pan
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797,NEW=pan
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776,NEW=3
 a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463,NEW=0.38139939387114097
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729,NEW=0.8636244699032729
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$[[[NR]]] = &quot;NEW&quot;&#39; data/small
</span> a=NEW,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=NEW,i=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,i=NEW,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=wye,i=4,x=NEW,y=0.13418874328430463
 a=wye,b=pan,i=5,x=0.5732889198020006,y=NEW
</pre></div>
</div>
<p>Right-hand side accesses to non-existent fields – i.e. with index less than 1 or greater than <code class="docutils literal notranslate"><span class="pre">NF</span></code> – return an absent value. Likewise, left-hand side accesses only refer to fields which already exist. For example, if a field has 5 records then assigning the name or value of the 6th (or 600th) field results in a no-op.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$[[6]] = &quot;NEW&quot;&#39; data/small
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;$[[[6]]] = &quot;NEW&quot;&#39; data/small
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
</div>
<div class="section" id="out-of-stream-variables">
<h2>Out-of-stream variables<a class="headerlink" href="#out-of-stream-variables" title="Permalink to this headline">¶</a></h2>
<p>These are prefixed with an at-sign, e.g. <code class="docutils literal notranslate"><span class="pre">&#64;sum</span></code>.  Furthermore, unlike built-in variables and stream-record fields, they are maintained in an arbitrarily nested hashmap: you can do <code class="docutils literal notranslate"><span class="pre">&#64;sum</span> <span class="pre">+=</span> <span class="pre">$quanity</span></code>, or <code class="docutils literal notranslate"><span class="pre">&#64;sum[$color]</span> <span class="pre">+=</span> <span class="pre">$quanity</span></code>, or <code class="docutils literal notranslate"><span class="pre">&#64;sum[$color][$shape]</span> <span class="pre">+=</span> <span class="pre">$quanity</span></code>. The keys for the multi-level hashmap can be any expression which evaluates to string or integer: e.g.  <code class="docutils literal notranslate"><span class="pre">&#64;sum[NR]</span> <span class="pre">=</span> <span class="pre">$a</span> <span class="pre">+</span> <span class="pre">$b</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;sum[$a.&quot;-&quot;.$b]</span> <span class="pre">=</span> <span class="pre">$x</span></code>, etc.</p>
<p>Their names and their values are entirely under your control; they change only when you assign to them.</p>
<p>Just as for field names in stream records, if you want to define out-of-stream variables with <strong>special characters</strong> such as <code class="docutils literal notranslate"><span class="pre">.</span></code> then you can use braces, e.g. <code class="docutils literal notranslate"><span class="pre">'&#64;{variable.name}[&quot;index&quot;]'</span></code>.</p>
<p>You may use a <strong>computed key</strong> in square brackets, e.g.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> echo s=green,t=blue,a=3,b=4 | mlr put -q &#39;@[$s.&quot;_&quot;.$t] = $a * $b; emit all&#39;
</span> green_blue=12
</pre></div>
</div>
<p>Out-of-stream variables are <strong>scoped</strong> to the <code class="docutils literal notranslate"><span class="pre">put</span></code> command in which they appear.  In particular, if you have two or more <code class="docutils literal notranslate"><span class="pre">put</span></code> commands separated by <code class="docutils literal notranslate"><span class="pre">then</span></code>, each put will have its own set of out-of-stream variables:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> cat data/a.dkvp
</span> a=1,b=2,c=3
 a=4,b=5,c=6
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;@sum += $a; end {emit @sum}&#39; \
</span><span class="hll">   then put &#39;is_present($a) {$a=10*$a; @sum += $a}; end {emit @sum}&#39; \
</span><span class="hll">   data/a.dkvp
</span> a=10,b=2,c=3
 a=40,b=5,c=6
 sum=5
 sum=50
</pre></div>
</div>
<p>Out-of-stream variables’ <strong>extent</strong> is from the start to the end of the record stream, i.e. every time the <code class="docutils literal notranslate"><span class="pre">put</span></code> or <code class="docutils literal notranslate"><span class="pre">filter</span></code> statement referring to them is executed.</p>
<p>Out-of-stream variables are <strong>read-write</strong>: you can do <code class="docutils literal notranslate"><span class="pre">$sum=&#64;sum</span></code>, <code class="docutils literal notranslate"><span class="pre">&#64;sum=$sum</span></code>, etc.</p>
</div>
<div class="section" id="indexed-out-of-stream-variables">
<h2>Indexed out-of-stream variables<a class="headerlink" href="#indexed-out-of-stream-variables" title="Permalink to this headline">¶</a></h2>
<p>Using an index on the <code class="docutils literal notranslate"><span class="pre">&#64;count</span></code> and <code class="docutils literal notranslate"><span class="pre">&#64;sum</span></code> variables, we get the benefit of the <code class="docutils literal notranslate"><span class="pre">-g</span></code> (group-by) option which <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">stats1</span></code> and various other Miller commands have:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put -q &#39;
</span><span class="hll">   @x_count[$a] += 1;
</span><span class="hll">   @x_sum[$a] += $x;
</span><span class="hll">   end {
</span><span class="hll">     emit @x_count, &quot;a&quot;;
</span><span class="hll">     emit @x_sum, &quot;a&quot;;
</span><span class="hll">   }
</span><span class="hll"> &#39; ../data/small
</span> a=pan,x_count=2
 a=eks,x_count=3
 a=wye,x_count=2
 a=zee,x_count=2
 a=hat,x_count=1
 a=pan,x_sum=0.8494161498792961
 a=eks,x_sum=1.75186341922895
 a=wye,x_sum=0.7778922255683036
 a=zee,x_sum=1.1256801691982772
 a=hat,x_sum=0.03144187646093577
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr stats1 -a count,sum -f x -g a ../data/small
</span> a=pan,x_count=2,x_sum=0.8494161498792961
 a=eks,x_count=3,x_sum=1.75186341922895
 a=wye,x_count=2,x_sum=0.7778922255683036
 a=zee,x_count=2,x_sum=1.1256801691982772
 a=hat,x_count=1,x_sum=0.03144187646093577
</pre></div>
</div>
<p>Indices can be arbitrarily deep – here there are two or more of them:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --from data/medium put -q &#39;
</span><span class="hll">   @x_count[$a][$b] += 1;
</span><span class="hll">   @x_sum[$a][$b] += $x;
</span><span class="hll">   end {
</span><span class="hll">     emit (@x_count, @x_sum), &quot;a&quot;, &quot;b&quot;;
</span><span class="hll">   }
</span><span class="hll"> &#39;
</span> a=pan,b=pan,x_count=427,x_sum=219.1851288316854
 a=pan,b=wye,x_count=395,x_sum=198.43293070748447
 a=pan,b=eks,x_count=429,x_sum=216.07522773165525
 a=pan,b=hat,x_count=417,x_sum=205.22277621488686
 a=pan,b=zee,x_count=413,x_sum=205.09751802331917
 a=eks,b=pan,x_count=371,x_sum=179.96303047250723
 a=eks,b=wye,x_count=407,x_sum=196.9452860713734
 a=eks,b=zee,x_count=357,x_sum=176.8803651584733
 a=eks,b=eks,x_count=413,x_sum=215.91609712937984
 a=eks,b=hat,x_count=417,x_sum=208.783170520597
 a=wye,b=wye,x_count=377,x_sum=185.29584980261419
 a=wye,b=pan,x_count=392,x_sum=195.84790012056564
 a=wye,b=hat,x_count=426,x_sum=212.0331829346132
 a=wye,b=zee,x_count=385,x_sum=194.77404756708714
 a=wye,b=eks,x_count=386,x_sum=204.8129608356315
 a=zee,b=pan,x_count=389,x_sum=202.21380378504267
 a=zee,b=wye,x_count=455,x_sum=233.9913939194868
 a=zee,b=eks,x_count=391,x_sum=190.9617780631925
 a=zee,b=zee,x_count=403,x_sum=206.64063510417319
 a=zee,b=hat,x_count=409,x_sum=191.30000620900935
 a=hat,b=wye,x_count=423,x_sum=208.8830097609959
 a=hat,b=zee,x_count=385,x_sum=196.3494502965293
 a=hat,b=eks,x_count=389,x_sum=189.0067933716193
 a=hat,b=hat,x_count=381,x_sum=182.8535323148762
 a=hat,b=pan,x_count=363,x_sum=168.5538067327806
</pre></div>
</div>
<p>The idea is that <code class="docutils literal notranslate"><span class="pre">stats1</span></code>, and other Miller verbs, encapsulate frequently-used patterns with a minimum of keystroking (and run a little faster), whereas using out-of-stream variables you have more flexibility and control in what you do.</p>
<p>Begin/end blocks can be mixed with pattern/action blocks. For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;
</span><span class="hll">   begin {
</span><span class="hll">     @num_total = 0;
</span><span class="hll">     @num_positive = 0;
</span><span class="hll">   };
</span><span class="hll">   @num_total += 1;
</span><span class="hll">   $x &gt; 0.0 {
</span><span class="hll">     @num_positive += 1;
</span><span class="hll">     $y = log10($x); $z = sqrt($y)
</span><span class="hll">   };
</span><span class="hll">   end {
</span><span class="hll">     emitf @num_total, @num_positive
</span><span class="hll">   }
</span><span class="hll"> &#39; data/put-gating-example-1.dkvp
</span> x=-1
 x=0
 x=1,y=0,z=0
 x=2,y=0.3010299956639812,z=0.5486620049392715
 x=3,y=0.4771212547196624,z=0.6907396432228734
 num_total=5,num_positive=3
</pre></div>
</div>
</div>
<div class="section" id="local-variables">
<span id="reference-dsl-local-variables"></span><h2>Local variables<a class="headerlink" href="#local-variables" title="Permalink to this headline">¶</a></h2>
<p>Local variables are similar to out-of-stream variables, except that their extent is limited to the expressions in which they appear (and their basenames can’t be computed using square brackets). There are three kinds of local variables: <strong>arguments</strong> to functions/subroutines, <strong>variables bound within for-loops</strong>, and <strong>locals</strong> defined within control blocks. They may be untyped using <code class="docutils literal notranslate"><span class="pre">var</span></code>, or typed using <code class="docutils literal notranslate"><span class="pre">num</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, <code class="docutils literal notranslate"><span class="pre">bool</span></code>, and <code class="docutils literal notranslate"><span class="pre">map</span></code>.</p>
<p>For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> # Here I&#39;m using a specified random-number seed so this example always
</span><span class="hll"> # produces the same output for this web document: in everyday practice we
</span><span class="hll"> # would leave off the --seed 12345 part.
</span><span class="hll"> mlr --seed 12345 seqgen --start 1 --stop 10 then put &#39;
</span><span class="hll">   func f(a, b) {                          # function arguments a and b
</span><span class="hll">       r = 0.0;                            # local r scoped to the function
</span><span class="hll">       for (int i = 0; i &lt; 6; i += 1) {    # local i scoped to the for-loop
</span><span class="hll">           num u = urand();                # local u scoped to the for-loop
</span><span class="hll">           r += u;                         # updates r from the enclosing scope
</span><span class="hll">       }
</span><span class="hll">       r /= 6;
</span><span class="hll">       return a + (b - a) * r;
</span><span class="hll">   }
</span><span class="hll">   num o = f(10, 20);                      # local to the top-level scope
</span><span class="hll">   $o = o;
</span><span class="hll"> &#39;
</span> i=1,o=15.952526011537227
 i=2,o=12.782237754999116
 i=3,o=15.126606630220966
 i=4,o=14.794357488895775
 i=5,o=15.168665974047421
 i=6,o=16.20662783079942
 i=7,o=13.966128063060479
 i=8,o=13.99248245928659
 i=9,o=15.784270485515197
 i=10,o=15.37686787628025
</pre></div>
</div>
<p>Things which are completely unsurprising, resembling many other languages:</p>
<ul class="simple">
<li><p>Parameter names are bound to their arguments but can be reassigned, e.g. if there is a parameter named <code class="docutils literal notranslate"><span class="pre">a</span></code> then you can reassign the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> to be something else within the function if you like.</p></li>
<li><p>However, you cannot redeclare the <em>type</em> of an argument or a local: <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">a=1;</span> <span class="pre">var</span> <span class="pre">a=2</span></code> is an error but <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">a=1;</span>&#160; <span class="pre">a=2</span></code> is OK.</p></li>
<li><p>All argument-passing is positional rather than by name; arguments are passed by value, not by reference. (This is also true for map-valued variables: they are not, and cannot be, passed by reference)</p></li>
<li><p>You can define locals (using <code class="docutils literal notranslate"><span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">num</span></code>, etc.) at any scope (if-statements, else-statements, while-loops, for-loops, or the top-level scope), and nested scopes will have access (more details on scope in the next section).  If you define a local variable with the same name inside an inner scope, then a new variable is created with the narrower scope.</p></li>
<li><p>If you assign to a local variable for the first time in a scope without declaring it as <code class="docutils literal notranslate"><span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">num</span></code>, etc. then: if it exists in an outer scope, that outer-scope variable will be updated; if not, it will be defined in the current scope as if <code class="docutils literal notranslate"><span class="pre">var</span></code> had been used. (See also <a class="reference internal" href="#reference-dsl-type-checking"><span class="std std-ref">Type-checking</span></a> for an example.) I recommend always declaring variables explicitly to make the intended scoping clear.</p></li>
<li><p>Functions and subroutines never have access to locals from their callee (unless passed by value as arguments).</p></li>
</ul>
<p>Things which are perhaps surprising compared to other languages:</p>
<ul class="simple">
<li><p>Type declarations using <code class="docutils literal notranslate"><span class="pre">var</span></code>, or typed using <code class="docutils literal notranslate"><span class="pre">num</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, and <code class="docutils literal notranslate"><span class="pre">bool</span></code> are necessary to declare local variables.  Function arguments and variables bound in for-loops over stream records and out-of-stream variables are <em>implicitly</em> declared using <code class="docutils literal notranslate"><span class="pre">var</span></code>. (Some examples are shown below.)</p></li>
<li><p>Type-checking is done at assignment time. For example, <code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">0</span></code> is an error (since <code class="docutils literal notranslate"><span class="pre">0</span></code> is an integer), as is <code class="docutils literal notranslate"><span class="pre">float</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">0.0;</span> <span class="pre">f</span> <span class="pre">=</span> <span class="pre">1</span></code>. For this reason I prefer to use <code class="docutils literal notranslate"><span class="pre">num</span></code> over <code class="docutils literal notranslate"><span class="pre">float</span></code> in most contexts since <code class="docutils literal notranslate"><span class="pre">num</span></code> encompasses integer and floating-point values. More information about type-checking is at <a class="reference internal" href="#reference-dsl-type-checking"><span class="std std-ref">Type-checking</span></a>.</p></li>
<li><p>Bound variables in for-loops over stream records and out-of-stream variables are implicitly local to that block. E.g. in <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(k,</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">$*)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">((k1,</span> <span class="pre">k2),</span> <span class="pre">v</span> <span class="pre">in</span> <span class="pre">&#64;*)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> if there are <code class="docutils literal notranslate"><span class="pre">k</span></code>, <code class="docutils literal notranslate"><span class="pre">v</span></code>, etc. in the enclosing scope then those will be masked by the loop-local bound variables in the loop, and moreover the values of the loop-local bound variables are not available after the end of the loop.</p></li>
<li><p>For C-style triple-for loops, if a for-loop variable is defined using <code class="docutils literal notranslate"><span class="pre">var</span></code>, <code class="docutils literal notranslate"><span class="pre">int</span></code>, etc. then it is scoped to that for-loop. E.g. <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10;</span> <span class="pre">i</span> <span class="pre">+=</span> <span class="pre">1)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code> and <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(int</span> <span class="pre">i</span> <span class="pre">=</span> <span class="pre">0;</span> <span class="pre">i</span> <span class="pre">&lt;</span> <span class="pre">10;</span> <span class="pre">i</span> <span class="pre">+=</span> <span class="pre">1)</span> <span class="pre">{</span> <span class="pre">...</span> <span class="pre">}</span></code>. (This is unsurprising.). If there is no typedecl and an outer-scope variable of that name exists, then it is used. (This is also unsurprising.) But of there is no outer-scope variable of that name then the variable is scoped to the for-loop only.</p></li>
</ul>
<p>The following example demonstrates the scope rules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> cat data/scope-example.mlr
</span> func f(a) {      # argument is local to the function
   var b = 100;   # local to the function
   c = 100;       # local to the function; does not overwrite outer c
   return a + 1;
 }
 var a = 10;      # local at top level
 var b = 20;      # local at top level
 c = 30;          # local at top level; there is no more-outer-scope c
 if (NR == 3) {
   var a = 40;    # scoped to the if-statement; doesn&#39;t overwrite outer a
   b = 50;        # not scoped to the if-statement; overwrites outer b
   c = 60;        # not scoped to the if-statement; overwrites outer c
   d = 70;        # there is no outer d so a local d is created here

   $inner_a = a;
   $inner_b = b;
   $inner_c = c;
   $inner_d = d;
 }
 $outer_a = a;
 $outer_b = b;
 $outer_c = c;
 $outer_d = d;    # there is no outer d defined so no assignment happens
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> cat data/scope-example.dat
</span> n=1,x=123
 n=2,x=456
 n=3,x=789
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --oxtab --from data/scope-example.dat put -f data/scope-example.mlr
</span> n       1
 x       123
 outer_a 10
 outer_b 20
 outer_c 30

 n       2
 x       456
 outer_a 10
 outer_b 20
 outer_c 30

 n       3
 x       789
 inner_a 40
 inner_b 50
 inner_c 60
 inner_d 70
 outer_a 10
 outer_b 50
 outer_c 60
</pre></div>
</div>
<p>And this example demonstrates the type-declaration rules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> cat data/type-decl-example.mlr
</span> subr s(a, str b, int c) {                         # a is implicitly var (untyped).
                                                   # b is explicitly str.
                                                   # c is explicitly int.
                                                   # The type-checking is done at the callsite
                                                   # when arguments are bound to parameters.
                                                   #
     var b = 100;     # error                      # Re-declaration in the same scope is disallowed.
     int n = 10;                                   # Declaration of variable local to the subroutine.
     n = 20;                                       # Assignment is OK.
     int n = 30;      # error                      # Re-declaration in the same scope is disallowed.
     str n = &quot;abc&quot;;   # error                      # Re-declaration in the same scope is disallowed.
                                                   #
     float f1 = 1;    # error                      # 1 is an int, not a float.
     float f2 = 2.0;                               # 2.0 is a float.
     num f3 = 3;                                   # 3 is a num.
     num f4 = 4.0;                                 # 4.0 is a num.
 }                                                 #
                                                   #
 call s(1, 2, 3);                                  # Type-assertion &#39;3 is int&#39; is done here at the callsite.
                                                   #
 k = &quot;def&quot;;                                        # Top-level variable k.
                                                   #
 for (str k, v in $*) {                            # k and v are bound here, masking outer k.
   print k . &quot;:&quot; . v;                              # k is explicitly str; v is implicitly var.
 }                                                 #
                                                   #
 print &quot;k is&quot;.k;                                   # k at this scope level is still &quot;def&quot;.
 print &quot;v is&quot;.v;                                   # v is undefined in this scope.
                                                   #
 i = -1;                                           #
 for (i = 1, int j = 2; i &lt;= 10; i += 1, j *= 2) { # C-style triple-for variables use enclosing scope, unless
                                                   # declared local: i is outer, j is local to the loop.
   print &quot;inner i =&quot; . i;                          #
   print &quot;inner j =&quot; . j;                          #
 }                                                 #
 print &quot;outer i =&quot; . i;                            # i has been modified by the loop.
 print &quot;outer j =&quot; . j;                            # j is undefined in this scope.
</pre></div>
</div>
</div>
<div class="section" id="map-literals">
<h2>Map literals<a class="headerlink" href="#map-literals" title="Permalink to this headline">¶</a></h2>
<p>Miller’s <code class="docutils literal notranslate"><span class="pre">put</span></code>/<code class="docutils literal notranslate"><span class="pre">filter</span></code> DSL has four kinds of hashmaps. <strong>Stream records</strong> are (single-level) maps from name to value. <strong>Out-of-stream variables</strong> and <strong>local variables</strong> can also be maps, although they can be multi-level hashmaps (e.g. <code class="docutils literal notranslate"><span class="pre">&#64;sum[$x][$y]</span></code>).  The fourth kind is <strong>map literals</strong>. These cannot be on the left-hand side of assignment expressions. Syntactically they look like JSON, although Miller allows string and integer keys in its map literals while JSON allows only string keys (e.g. <code class="docutils literal notranslate"><span class="pre">&quot;3&quot;</span></code> rather than <code class="docutils literal notranslate"><span class="pre">3</span></code>).</p>
<p>For example, the following swaps the input stream’s <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">i</span></code> fields, modifies <code class="docutils literal notranslate"><span class="pre">y</span></code>, and drops the rest:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --opprint put &#39;
</span><span class="hll">   $* = {
</span><span class="hll">     &quot;a&quot;: $i,
</span><span class="hll">     &quot;i&quot;: $a,
</span><span class="hll">     &quot;y&quot;: $y * 10,
</span><span class="hll">   }
</span><span class="hll"> &#39; data/small
</span> a i   y
 1 pan 7.268028627434533
 2 eks 5.221511083334796
 3 wye 3.3831852551664774
 4 eks 1.3418874328430463
 5 wye 8.63624469903273
</pre></div>
</div>
<p>Likewise, you can assign map literals to out-of-stream variables or local variables; pass them as arguments to user-defined functions, return them from functions, and so on:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --from data/small put &#39;
</span><span class="hll">   func f(map m): map {
</span><span class="hll">     m[&quot;x&quot;] *= 200;
</span><span class="hll">     return m;
</span><span class="hll">   }
</span><span class="hll">   $* = f({&quot;a&quot;: $a, &quot;x&quot;: $x});
</span><span class="hll"> &#39;
</span> a=pan,x=69.35802886761648
 a=eks,x=151.73599295799272
 a=wye,x=40.92066115326061
 a=eks,x=76.2798787742282
 a=wye,x=114.65778396040011
</pre></div>
</div>
<p>Like out-of-stream and local variables, map literals can be multi-level:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --from data/small put -q &#39;
</span><span class="hll">   begin {
</span><span class="hll">     @o = {
</span><span class="hll">       &quot;nrec&quot;: 0,
</span><span class="hll">       &quot;nkey&quot;: {&quot;numeric&quot;:0, &quot;non-numeric&quot;:0},
</span><span class="hll">     };
</span><span class="hll">   }
</span><span class="hll">   @o[&quot;nrec&quot;] += 1;
</span><span class="hll">   for (k, v in $*) {
</span><span class="hll">     if (is_numeric(v)) {
</span><span class="hll">       @o[&quot;nkey&quot;][&quot;numeric&quot;] += 1;
</span><span class="hll">     } else {
</span><span class="hll">       @o[&quot;nkey&quot;][&quot;non-numeric&quot;] += 1;
</span><span class="hll">     }
</span><span class="hll">   }
</span><span class="hll">   end {
</span><span class="hll">     dump @o;
</span><span class="hll">   }
</span><span class="hll"> &#39;
</span> {
   &quot;nrec&quot;: 5,
   &quot;nkey&quot;: {
     &quot;numeric&quot;: 15,
     &quot;non-numeric&quot;: 10
   }
 }
</pre></div>
</div>
<p>By default, map-valued expressions are dumped using JSON formatting. If you use <code class="docutils literal notranslate"><span class="pre">dump</span></code> to print a hashmap with integer keys and you don’t want them double-quoted (JSON-style) then you can use <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">put</span> <span class="pre">--jknquoteint</span></code>. See also <code class="docutils literal notranslate"><span class="pre">mlr</span> <span class="pre">put</span> <span class="pre">--help</span></code>.</p>
</div>
<div class="section" id="type-checking">
<span id="reference-dsl-type-checking"></span><h2>Type-checking<a class="headerlink" href="#type-checking" title="Permalink to this headline">¶</a></h2>
<p>Miller’s <code class="docutils literal notranslate"><span class="pre">put</span></code>/<code class="docutils literal notranslate"><span class="pre">filter</span></code> DSLs support two optional kinds of type-checking.  One is inline <strong>type-tests</strong> and <strong>type-assertions</strong> within expressions.  The other is <strong>type declarations</strong> for assignments to local variables, binding of arguments to user-defined functions, and return values from user-defined functions, These are discussed in the following subsections.</p>
<p>Use of type-checking is entirely up to you: omit it if you want flexibility with heterogeneous data; use it if you want to help catch misspellings in your DSL code or unexpected irregularities in your input data.</p>
<div class="section" id="type-test-and-type-assertion-expressions">
<span id="reference-dsl-type-tests-and-assertions"></span><h3>Type-test and type-assertion expressions<a class="headerlink" href="#type-test-and-type-assertion-expressions" title="Permalink to this headline">¶</a></h3>
<p>The following <code class="docutils literal notranslate"><span class="pre">is...</span></code> functions take a value and return a boolean indicating whether the argument is of the indicated type. The <code class="docutils literal notranslate"><span class="pre">assert_...</span></code> functions return their argument if it is of the specified type, and cause a fatal error otherwise:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr -f | grep ^is
</span> is_absent
 is_array
 is_bool
 is_boolean
 is_empty
 is_empty_map
 is_error
 is_float
 is_int
 is_map
 is_nonempty_map
 is_not_array
 is_not_empty
 is_not_map
 is_not_null
 is_null
 is_numeric
 is_present
 is_string
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr -f | grep ^assert
</span> asserting_absent
 asserting_array
 asserting_bool
 asserting_boolean
 asserting_empty
 asserting_empty_map
 asserting_error
 asserting_float
 asserting_int
 asserting_map
 asserting_nonempty_map
 asserting_not_array
 asserting_not_empty
 asserting_not_map
 asserting_not_null
 asserting_null
 asserting_numeric
 asserting_present
 asserting_string
</pre></div>
</div>
<p>See <a class="reference internal" href="data-cleaning-examples.html"><span class="doc">Data-cleaning examples</span></a> for examples of how to use these.</p>
</div>
<div class="section" id="type-declarations-for-local-variables-function-parameter-and-function-return-values">
<h3>Type-declarations for local variables, function parameter, and function return values<a class="headerlink" href="#type-declarations-for-local-variables-function-parameter-and-function-return-values" title="Permalink to this headline">¶</a></h3>
<p>Local variables can be defined either untyped as in <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code>, or typed as in <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code>. Types include <strong>var</strong> (explicitly untyped), <strong>int</strong>, <strong>float</strong>, <strong>num</strong> (int or float), <strong>str</strong>, <strong>bool</strong>, and <strong>map</strong>. These optional type declarations are enforced at the time values are assigned to variables: whether at the initial value assignment as in <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code> or in any subsequent assignments to the same variable farther down in the scope.</p>
<p>The reason for <code class="docutils literal notranslate"><span class="pre">num</span></code> is that <code class="docutils literal notranslate"><span class="pre">int</span></code> and <code class="docutils literal notranslate"><span class="pre">float</span></code> typedecls are very precise:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>float a = 0;   # Runtime error since 0 is int not float
int   b = 1.0; # Runtime error since 1.0 is float not int
num   c = 0;   # OK
num   d = 1.0; # OK
</pre></div>
</div>
<p>A suggestion is to use <code class="docutils literal notranslate"><span class="pre">num</span></code> for general use when you want numeric content, and use <code class="docutils literal notranslate"><span class="pre">int</span></code> when you genuinely want integer-only values, e.g. in loop indices or map keys (since Miller map keys can only be strings or ints).</p>
<p>The <code class="docutils literal notranslate"><span class="pre">var</span></code> type declaration indicates no type restrictions, e.g. <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code> has the same type restrictions on <code class="docutils literal notranslate"><span class="pre">x</span></code> as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code>. The difference is in intentional shadowing: if you have <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">1</span></code> in outer scope and <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">2</span></code> in inner scope (e.g. within a for-loop or an if-statement) then outer-scope <code class="docutils literal notranslate"><span class="pre">x</span></code> has value 2 after the second assignment.  But if you have <code class="docutils literal notranslate"><span class="pre">var</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">2</span></code> in the inner scope, then you are declaring a variable scoped to the inner block.) For example:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x = 1;
if (NR == 4) {
  x = 2; # Refers to outer-scope x: value changes from 1 to 2.
}
print x; # Value of x is now two
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>x = 1;
if (NR == 4) {
  var x = 2; # Defines a new inner-scope x with value 2
}
print x;     # Value of this x is still 1
</pre></div>
</div>
<p>Likewise function arguments can optionally be typed, with type enforced when the function is called:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>func f(map m, int i) {
  ...
}
$a = f({1:2, 3:4}, 5);     # OK
$b = f({1:2, 3:4}, &quot;abc&quot;); # Runtime error
$c = f({1:2, 3:4}, $x);    # Runtime error for records with non-integer field named x
if (NR == 4) {
  var x = 2; # Defines a new inner-scope x with value 2
}
print x;     # Value of this x is still 1
</pre></div>
</div>
<p>Thirdly, function return values can be type-checked at the point of <code class="docutils literal notranslate"><span class="pre">return</span></code> using <code class="docutils literal notranslate"><span class="pre">:</span></code> and a typedecl after the parameter list:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>func f(map m, int i): bool {
  ...
  ...
  if (...) {
    return &quot;false&quot;; # Runtime error if this branch is taken
  }
  ...
  ...
  if (...) {
    return retval; # Runtime error if this function doesn&#39;t have an in-scope
    # boolean-valued variable named retval
  }
  ...
  ...
  # In Miller if your functions don&#39;t explicitly return a value, they return absent-null.
  # So it would also be a runtime error on reaching the end of this function without
  # an explicit return statement.
}
</pre></div>
</div>
</div>
</div>
<div class="section" id="null-data-empty-and-absent">
<h2>Null data: empty and absent<a class="headerlink" href="#null-data-empty-and-absent" title="Permalink to this headline">¶</a></h2>
<p>Please see <a class="reference internal" href="reference-main-null-data.html"><span class="doc">Reference: null data</span></a>.</p>
</div>
<div class="section" id="aggregate-variable-assignments">
<h2>Aggregate variable assignments<a class="headerlink" href="#aggregate-variable-assignments" title="Permalink to this headline">¶</a></h2>
<p>There are three remaining kinds of variable assignment using out-of-stream variables, the last two of which use the <code class="docutils literal notranslate"><span class="pre">$*</span></code> syntax:</p>
<ul class="simple">
<li><p>Recursive copy of out-of-stream variables</p></li>
<li><p>Out-of-stream variable assigned to full stream record</p></li>
<li><p>Full stream record assigned to an out-of-stream variable</p></li>
</ul>
<p>Example recursive copy of out-of-stream variables:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --opprint put -q &#39;@v[&quot;sum&quot;] += $x; @v[&quot;count&quot;] += 1; end{dump; @w = @v; dump}&#39; data/small
</span> {
   &quot;v&quot;: {
     &quot;sum&quot;: 2.264761728567491,
     &quot;count&quot;: 5
   }
 }
 {
   &quot;v&quot;: {
     &quot;sum&quot;: 2.264761728567491,
     &quot;count&quot;: 5
   },
   &quot;w&quot;: {
     &quot;sum&quot;: 2.264761728567491,
     &quot;count&quot;: 5
   }
 }
</pre></div>
</div>
<p>Example of out-of-stream variable assigned to full stream record, where the 2nd record is stashed, and the 4th record is overwritten with that:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr put &#39;NR == 2 {@keep = $*}; NR == 4 {$* = @keep}&#39; data/small
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<p>Example of full stream record assigned to an out-of-stream variable, finding the record for which the <code class="docutils literal notranslate"><span class="pre">x</span></code> field has the largest value in the input stream:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> cat data/small
</span> a=pan,b=pan,i=1,x=0.3467901443380824,y=0.7268028627434533
 a=eks,b=pan,i=2,x=0.7586799647899636,y=0.5221511083334797
 a=wye,b=wye,i=3,x=0.20460330576630303,y=0.33831852551664776
 a=eks,b=wye,i=4,x=0.38139939387114097,y=0.13418874328430463
 a=wye,b=pan,i=5,x=0.5732889198020006,y=0.8636244699032729
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr --opprint put -q &#39;
</span><span class="hll">   is_null(@xmax) || $x &gt; @xmax {@xmax=$x; @recmax=$*};
</span><span class="hll">   end {emit @recmax}
</span><span class="hll"> &#39; data/small
</span> a   b   i x                  y
 eks pan 2 0.7586799647899636 0.5221511083334797
</pre></div>
</div>
</div>
<div class="section" id="keywords-for-filter-and-put">
<h2>Keywords for filter and put<a class="headerlink" href="#keywords-for-filter-and-put" title="Permalink to this headline">¶</a></h2>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span><span class="hll"> mlr help usage-keywords
</span> all: used in &quot;emit&quot;, &quot;emitp&quot;, and &quot;unset&quot; as a synonym for @*

 begin: defines a block of statements to be executed before input records
 are ingested. The body statements must be wrapped in curly braces.

   Example: &#39;begin { @count = 0 }&#39;

 bool: declares a boolean local variable in the current curly-braced scope.
 Type-checking happens at assignment: &#39;bool b = 1&#39; is an error.

 break: causes execution to continue after the body of the current for/while/do-while loop.

 call: used for invoking a user-defined subroutine.

   Example: &#39;subr s(k,v) { print k . &quot; is &quot; . v} call s(&quot;a&quot;, $a)&#39;

 continue: causes execution to skip the remaining statements in the body of
 the current for/while/do-while loop. For-loop increments are still applied.

 do: with &quot;while&quot;, introduces a do-while loop. The body statements must be wrapped
 in curly braces.

 dump: prints all currently defined out-of-stream variables immediately
 to stdout as JSON.

 With &gt;, &gt;&gt;, or |, the data do not become part of the output record stream but
 are instead redirected.

 The &gt; and &gt;&gt; are for write and append, as in the shell, but (as with awk) the
 file-overwrite for &gt; is on first write, not per record. The | is for piping to
 a process which will process the data. There will be one open file for each
 distinct file name (for &gt; and &gt;&gt;) or one subordinate process for each distinct
 value of the piped-to command (for |). Output-formatting flags are taken from
 the main command line.

   Example: mlr --from f.dat put -q &#39;@v[NR]=$*; end { dump }&#39;
   Example: mlr --from f.dat put -q &#39;@v[NR]=$*; end { dump &gt;  &quot;mytap.dat&quot;}&#39;
   Example: mlr --from f.dat put -q &#39;@v[NR]=$*; end { dump &gt;&gt; &quot;mytap.dat&quot;}&#39;
   Example: mlr --from f.dat put -q &#39;@v[NR]=$*; end { dump | &quot;jq .[]&quot;}&#39;

 edump: prints all currently defined out-of-stream variables immediately
 to stderr as JSON.

   Example: mlr --from f.dat put -q &#39;@v[NR]=$*; end { edump }&#39;

 elif: the way Miller spells &quot;else if&quot;. The body statements must be wrapped
 in curly braces.

 else: terminates an if/elif/elif chain. The body statements must be wrapped
 in curly braces.

 emit: inserts an out-of-stream variable into the output record stream. Hashmap
 indices present in the data but not slotted by emit arguments are not output.

 With &gt;, &gt;&gt;, or |, the data do not become part of the output record stream but
 are instead redirected.

 The &gt; and &gt;&gt; are for write and append, as in the shell, but (as with awk) the
 file-overwrite for &gt; is on first write, not per record. The | is for piping to
 a process which will process the data. There will be one open file for each
 distinct file name (for &gt; and &gt;&gt;) or one subordinate process for each distinct
 value of the piped-to command (for |). Output-formatting flags are taken from
 the main command line.

 You can use any of the output-format command-line flags, e.g. --ocsv, --ofs,
 etc., to control the format of the output if the output is redirected. See also mlr -h.

   Example: mlr --from f.dat put &#39;emit &gt;  &quot;/tmp/data-&quot;.$a, $*&#39;
   Example: mlr --from f.dat put &#39;emit &gt;  &quot;/tmp/data-&quot;.$a, mapexcept($*, &quot;a&quot;)&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit @sums&#39;
   Example: mlr --from f.dat put --ojson &#39;@sums[$a][$b]+=$x; emit &gt; &quot;tap-&quot;.$a.$b.&quot;.dat&quot;, @sums&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit @sums, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit &gt;  &quot;mytap.dat&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit &gt;&gt; &quot;mytap.dat&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit | &quot;gzip &gt; mytap.dat.gz&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit &gt; stderr, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emit | &quot;grep somepattern&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;

 Please see https://johnkerl.org/miller6://johnkerl.org/miller/doc for more information.

 emitf: inserts non-indexed out-of-stream variable(s) side-by-side into the
 output record stream.

 With &gt;, &gt;&gt;, or |, the data do not become part of the output record stream but
 are instead redirected.

 The &gt; and &gt;&gt; are for write and append, as in the shell, but (as with awk) the
 file-overwrite for &gt; is on first write, not per record. The | is for piping to
 a process which will process the data. There will be one open file for each
 distinct file name (for &gt; and &gt;&gt;) or one subordinate process for each distinct
 value of the piped-to command (for |). Output-formatting flags are taken from
 the main command line.

 You can use any of the output-format command-line flags, e.g. --ocsv, --ofs,
 etc., to control the format of the output if the output is redirected. See also mlr -h.

   Example: mlr --from f.dat put &#39;@a=$i;@b+=$x;@c+=$y; emitf @a&#39;
   Example: mlr --from f.dat put --oxtab &#39;@a=$i;@b+=$x;@c+=$y; emitf &gt; &quot;tap-&quot;.$i.&quot;.dat&quot;, @a&#39;
   Example: mlr --from f.dat put &#39;@a=$i;@b+=$x;@c+=$y; emitf @a, @b, @c&#39;
   Example: mlr --from f.dat put &#39;@a=$i;@b+=$x;@c+=$y; emitf &gt; &quot;mytap.dat&quot;, @a, @b, @c&#39;
   Example: mlr --from f.dat put &#39;@a=$i;@b+=$x;@c+=$y; emitf &gt;&gt; &quot;mytap.dat&quot;, @a, @b, @c&#39;
   Example: mlr --from f.dat put &#39;@a=$i;@b+=$x;@c+=$y; emitf &gt; stderr, @a, @b, @c&#39;
   Example: mlr --from f.dat put &#39;@a=$i;@b+=$x;@c+=$y; emitf | &quot;grep somepattern&quot;, @a, @b, @c&#39;
   Example: mlr --from f.dat put &#39;@a=$i;@b+=$x;@c+=$y; emitf | &quot;grep somepattern &gt; mytap.dat&quot;, @a, @b, @c&#39;

 Please see https://johnkerl.org/miller6://johnkerl.org/miller/doc for more information.

 emitp: inserts an out-of-stream variable into the output record stream.
 Hashmap indices present in the data but not slotted by emitp arguments are
 output concatenated with &quot;:&quot;.

 With &gt;, &gt;&gt;, or |, the data do not become part of the output record stream but
 are instead redirected.

 The &gt; and &gt;&gt; are for write and append, as in the shell, but (as with awk) the
 file-overwrite for &gt; is on first write, not per record. The | is for piping to
 a process which will process the data. There will be one open file for each
 distinct file name (for &gt; and &gt;&gt;) or one subordinate process for each distinct
 value of the piped-to command (for |). Output-formatting flags are taken from
 the main command line.

 You can use any of the output-format command-line flags, e.g. --ocsv, --ofs,
 etc., to control the format of the output if the output is redirected. See also mlr -h.

   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp @sums&#39;
   Example: mlr --from f.dat put --opprint &#39;@sums[$a][$b]+=$x; emitp &gt; &quot;tap-&quot;.$a.$b.&quot;.dat&quot;, @sums&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp @sums, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp &gt;  &quot;mytap.dat&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp &gt;&gt; &quot;mytap.dat&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp | &quot;gzip &gt; mytap.dat.gz&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp &gt; stderr, @*, &quot;index1&quot;, &quot;index2&quot;&#39;
   Example: mlr --from f.dat put &#39;@sums[$a][$b]+=$x; emitp | &quot;grep somepattern&quot;, @*, &quot;index1&quot;, &quot;index2&quot;&#39;

 Please see https://johnkerl.org/miller6://johnkerl.org/miller/doc for more information.

 end: defines a block of statements to be executed after input records
 are ingested. The body statements must be wrapped in curly braces.

   Example: &#39;end { emit @count }&#39;
   Example: &#39;end { eprint &quot;Final count is &quot; . @count }&#39;

 eprint: prints expression immediately to stderr.

   Example: mlr --from f.dat put -q &#39;eprint &quot;The sum of x and y is &quot;.($x+$y)&#39;
   Example: mlr --from f.dat put -q &#39;for (k, v in $*) { eprint k . &quot; =&gt; &quot; . v }&#39;
   Example: mlr --from f.dat put  &#39;(NR %% 1000 == 0) { eprint &quot;Checkpoint &quot;.NR}&#39;

 eprintn: prints expression immediately to stderr, without trailing newline.

   Example: mlr --from f.dat put -q &#39;eprintn &quot;The sum of x and y is &quot;.($x+$y); eprint &quot;&quot;&#39;

 false: the boolean literal value.

 filter: includes/excludes the record in the output record stream.

   Example: mlr --from f.dat put &#39;filter (NR == 2 || $x &gt; 5.4)&#39;

 Instead of put with &#39;filter false&#39; you can simply use put -q.  The following
 uses the input record to accumulate data but only prints the running sum
 without printing the input record:

   Example: mlr --from f.dat put -q &#39;@running_sum += $x * $y; emit @running_sum&#39;

 float: declares a floating-point local variable in the current curly-braced scope.
 Type-checking happens at assignment: &#39;float x = 0&#39; is an error.

 for: defines a for-loop using one of three styles. The body statements must
 be wrapped in curly braces.
 For-loop over stream record:

   Example:  &#39;for (k, v in $*) { ... }&#39;

 For-loop over out-of-stream variables:

   Example: &#39;for (k, v in @counts) { ... }&#39;
   Example: &#39;for ((k1, k2), v in @counts) { ... }&#39;
   Example: &#39;for ((k1, k2, k3), v in @*) { ... }&#39;

 C-style for-loop:

   Example:  &#39;for (var i = 0, var b = 1; i &lt; 10; i += 1, b *= 2) { ... }&#39;

 func: used for defining a user-defined function.

   Example: &#39;func f(a,b) { return sqrt(a**2+b**2)} $d = f($x, $y)&#39;

 if: starts an if/elif/elif chain. The body statements must be wrapped
 in curly braces.

 in: used in for-loops over stream records or out-of-stream variables.

 int: declares an integer local variable in the current curly-braced scope.
 Type-checking happens at assignment: &#39;int x = 0.0&#39; is an error.

 map: declares an map-valued local variable in the current curly-braced scope.
 Type-checking happens at assignment: &#39;map b = 0&#39; is an error. map b = {} is
 always OK. map b = a is OK or not depending on whether a is a map.

 num: declares an int/float local variable in the current curly-braced scope.
 Type-checking happens at assignment: &#39;num b = true&#39; is an error.

 print: prints expression immediately to stdout.

   Example: mlr --from f.dat put -q &#39;print &quot;The sum of x and y is &quot;.($x+$y)&#39;
   Example: mlr --from f.dat put -q &#39;for (k, v in $*) { print k . &quot; =&gt; &quot; . v }&#39;
   Example: mlr --from f.dat put  &#39;(NR %% 1000 == 0) { print &gt; stderr, &quot;Checkpoint &quot;.NR}&#39;

 printn: prints expression immediately to stdout, without trailing newline.

   Example: mlr --from f.dat put -q &#39;printn &quot;.&quot;; end { print &quot;&quot; }&#39;

 return: specifies the return value from a user-defined function.
 Omitted return statements (including via if-branches) result in an absent-null
 return value, which in turns results in a skipped assignment to an LHS.

 stderr: Used for tee, emit, emitf, emitp, print, and dump in place of filename
 to print to standard error.

 stdout: Used for tee, emit, emitf, emitp, print, and dump in place of filename
 to print to standard output.

 str: declares a string local variable in the current curly-braced scope.
 Type-checking happens at assignment.

 subr: used for defining a subroutine.

   Example: &#39;subr s(k,v) { print k . &quot; is &quot; . v} call s(&quot;a&quot;, $a)&#39;

 tee: prints the current record to specified file.
 This is an immediate print to the specified file (except for pprint format
 which of course waits until the end of the input stream to format all output).

 The &gt; and &gt;&gt; are for write and append, as in the shell, but (as with awk) the
 file-overwrite for &gt; is on first write, not per record. The | is for piping to
 a process which will process the data. There will be one open file for each
 distinct file name (for &gt; and &gt;&gt;) or one subordinate process for each distinct
 value of the piped-to command (for |). Output-formatting flags are taken from
 the main command line.

 You can use any of the output-format command-line flags, e.g. --ocsv, --ofs,
 etc., to control the format of the output. See also mlr -h.

 emit with redirect and tee with redirect are identical, except tee can only
 output $*.

   Example: mlr --from f.dat put &#39;tee &gt;  &quot;/tmp/data-&quot;.$a, $*&#39;
   Example: mlr --from f.dat put &#39;tee &gt;&gt; &quot;/tmp/data-&quot;.$a.$b, $*&#39;
   Example: mlr --from f.dat put &#39;tee &gt;  stderr, $*&#39;
   Example: mlr --from f.dat put -q &#39;tee | &quot;tr \[a-z\\] \[A-Z\\]&quot;, $*&#39;
   Example: mlr --from f.dat put -q &#39;tee | &quot;tr \[a-z\\] \[A-Z\\] &gt; /tmp/data-&quot;.$a, $*&#39;
   Example: mlr --from f.dat put -q &#39;tee | &quot;gzip &gt; /tmp/data-&quot;.$a.&quot;.gz&quot;, $*&#39;
   Example: mlr --from f.dat put -q --ojson &#39;tee | &quot;gzip &gt; /tmp/data-&quot;.$a.&quot;.gz&quot;, $*&#39;

 true: the boolean literal value.

 unset: clears field(s) from the current record, or an out-of-stream or local variable.

   Example: mlr --from f.dat put &#39;unset $x&#39;
   Example: mlr --from f.dat put &#39;unset $*&#39;
   Example: mlr --from f.dat put &#39;for (k, v in $*) { if (k =~ &quot;a.*&quot;) { unset $[k] } }&#39;
   Example: mlr --from f.dat put &#39;...; unset @sums&#39;
   Example: mlr --from f.dat put &#39;...; unset @sums[&quot;green&quot;]&#39;
   Example: mlr --from f.dat put &#39;...; unset @*&#39;

 var: declares an untyped local variable in the current curly-braced scope.

   Examples: &#39;var a=1&#39;, &#39;var xyz=&quot;&quot;&#39;

 while: introduces a while loop, or with &quot;do&quot;, introduces a do-while loop.
 The body statements must be wrapped in curly braces.

 ENV: access to environment variables by name, e.g. &#39;$home = ENV[&quot;HOME&quot;]&#39;

 FILENAME: evaluates to the name of the current file being processed.

 FILENUM: evaluates to the number of the current file being processed,
 starting with 1.

 FNR: evaluates to the number of the current record within the current file
 being processed, starting with 1. Resets at the start of each file.

 IFS: evaluates to the input field separator from the command line.

 IPS: evaluates to the input pair separator from the command line.

 IRS: evaluates to the input record separator from the command line,
 or to LF or CRLF from the input data if in autodetect mode (which is
 the default).

 M_E: the mathematical constant e.

 M_PI: the mathematical constant pi.

 NF: evaluates to the number of fields in the current record.

 NR: evaluates to the number of the current record over all files
 being processed, starting with 1. Does not reset at the start of each file.

 OFS: evaluates to the output field separator from the command line.

 OPS: evaluates to the output pair separator from the command line.

 ORS: evaluates to the output record separator from the command line,
 or to LF or CRLF from the input data if in autodetect mode (which is
 the default).
</pre></div>
</div>
</div>
</div>


        </div>
      </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, John Kerl.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
    </div>
  </body>
</html>