// ================================================================
// Constructors
// ================================================================

package types

import (
	"errors"

	"mlr/internal/pkg/lib"
)

func MlrvalFromString(input string) *Mlrval {
	if input == "" {
		return MLRVAL_VOID
	}
	return &Mlrval{
		mvtype:        MT_STRING,
		printrep:      input,
		printrepValid: true,
	}
}

func MlrvalFromInt(input int) *Mlrval {
	return &Mlrval{
		mvtype:        MT_INT,
		printrepValid: false,
		intval:        input,
	}
}

func MlrvalFromFloat64(input float64) *Mlrval {
	return &Mlrval{
		mvtype:        MT_FLOAT,
		printrepValid: false,
		floatval:      input,
	}
}

func MlrvalFromBool(input bool) *Mlrval {
	if input == true {
		return MLRVAL_TRUE
	} else {
		return MLRVAL_FALSE
	}
}

func MlrvalFromBoolString(input string) *Mlrval {
	if input == "true" {
		return MLRVAL_TRUE
	} else if input == "false" {
		return MLRVAL_FALSE
	} else {
		lib.InternalCodingErrorIf(true)
		return MLRVAL_ERROR // not reached
	}
}

// The user-defined function is of type 'interface{}' here to avoid what would
// otherwise be a package-dependency cycle between this package and
// mlr/internal/pkg/dsl/cst.
//
// Nominally the name argument is the user-specified name if `func f(a, b) {
// ... }`, or some autogenerated UUID like `fl0052` if `func (a, b) { ... }`.
func MlrvalFromFunction(funcval interface{}, name string) *Mlrval {
	return &Mlrval{
		mvtype:        MT_FUNC,
		printrep:      name,
		printrepValid: true,
		funcval:       funcval,
	}
}

func MlrvalFromEmptyMap() *Mlrval {
	return &Mlrval{
		mvtype:        MT_MAP,
		printrep:      "(bug-if-you-see-this-map-type)",
		printrepValid: false,
		mapval:        NewMlrmap(),
	}
}

func MlrvalFromMap(mlrmap *Mlrmap) *Mlrval {
	mv := MlrvalFromEmptyMap()
	if mlrmap == nil {
		// TODO maybe return 2nd-arg error in the API
		return MLRVAL_ERROR
	}

	for pe := mlrmap.Head; pe != nil; pe = pe.Next {
		mv.mapval.PutCopy(pe.Key, pe.Value)
	}
	return mv
}

// Like previous but doesn't copy. Only safe when the argument's sole purpose
// is to be passed into here.
func MlrvalFromMapReferenced(mlrmap *Mlrmap) *Mlrval {
	mv := MlrvalFromEmptyMap()
	if mlrmap == nil {
		// xxx maybe return 2nd-arg error in the API
		return MLRVAL_ERROR
	}

	for pe := mlrmap.Head; pe != nil; pe = pe.Next {
		mv.mapval.PutReference(pe.Key, pe.Value)
	}
	return mv
}

// Does not copy the data. We can make a MlrvalFromArrayLiteralCopy if needed,
// using values.CopyMlrvalArray().
func MlrvalEmptyArray() Mlrval {
	return Mlrval{
		mvtype:        MT_ARRAY,
		printrep:      "(bug-if-you-see-this-array-type)",
		printrepValid: false,
		intval:        0,
		floatval:      0.0,
		boolval:       false,
		arrayval:      make([]Mlrval, 0, 10),
		mapval:        nil,
	}
}

// Users can do things like '$new[1][2][3] = 4' even if '$new' isn't already
// allocated. This function supports that.
func NewSizedMlrvalArray(length int) *Mlrval {
	arrayval := make([]Mlrval, length, 2*length)

	for i := 0; i < int(length); i++ {
		arrayval[i] = *MLRVAL_VOID
	}

	return &Mlrval{
		mvtype:        MT_ARRAY,
		printrep:      "(bug-if-you-see-this-array-type)",
		printrepValid: false,
		intval:        0,
		floatval:      0.0,
		boolval:       false,
		arrayval:      arrayval,
		mapval:        nil,
	}
}

// Does not copy the data. We can make a SetFromArrayLiteralCopy if needed
// using values.CopyMlrvalArray().
func MlrvalFromArrayReference(input []Mlrval) *Mlrval {
	return &Mlrval{
		mvtype:        MT_ARRAY,
		printrepValid: false,
		arrayval:      input,
	}
}

func LengthenMlrvalArray(array *[]Mlrval, newLength64 int) {
	newLength := int(newLength64)
	lib.InternalCodingErrorIf(newLength <= len(*array))

	if newLength <= cap(*array) {
		newArray := (*array)[:newLength]
		for zindex := len(*array); zindex < newLength; zindex++ {
			// TODO: comment why not MT_ABSENT or MT_VOID
			newArray[zindex] = *MLRVAL_NULL
		}
		*array = newArray
	} else {
		newArray := make([]Mlrval, newLength, 2*newLength)
		zindex := 0
		for zindex = 0; zindex < len(*array); zindex++ {
			newArray[zindex] = (*array)[zindex]
		}
		for zindex = len(*array); zindex < newLength; zindex++ {
			// TODO: comment why not MT_ABSENT or MT_VOID
			newArray[zindex] = *MLRVAL_NULL
		}
		*array = newArray
	}
}

// NewMlrvalForAutoDeepen is for auto-deepen of nested maps in things like
//
//   $foo[1]["a"][2]["b"] = 3
//
// Autocreated levels are maps.  Array levels can be explicitly created e.g.
//
//   $foo[1]["a"] ??= []
//   $foo[1]["a"][2]["b"] = 3
func NewMlrvalForAutoDeepen(mvtype MVType) (*Mlrval, error) {
	if mvtype == MT_STRING || mvtype == MT_INT {
		empty := MlrvalFromEmptyMap()
		return empty, nil
	} else {
		return nil, errors.New(
			"mlr: indices must be string, int, or array thereof; got " + GetTypeName(mvtype),
		)
	}
}
