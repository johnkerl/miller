#!/bin/sh

# ================================================================
# MILLER REGRESSION SCRIPT
#
# Miller has some source-code-level unit-test routines -- but the
# vast majority of tests (thousands) are invoked here at the
# command-line level.
#
# Output from various mlr command-line invocations, with prepared
# inputs, is generated and then compared against stored expected
# output.
# ================================================================

# ----------------------------------------------------------------
# Path to mlr executable, which for interactive development is
# simply "./mlr".
#
# For building with autoconf:
# * in-directory build:
#   pwd                  is /path/to/the/tree/c/reg_test
#   path to mlr          is /path/to/the/tree/c/mlr
#   path to reg_test/run is /path/to/the/tree/c/reg_test/run
#
# * out-of-directory ("VPATH") build:
#   pwd                  is /path/to/build/tree/c/reg_test
#   path to mlr          is /path/to/build/tree/c/mlr
#   path to reg_test/run is /path/to/source/tree/c/reg_test/run

# For building without autoconf:
#   pwd                  is /does/not/matter
#   path to mlr          is /path/to/the/tree/c/mlr
#   path to reg_test/run is /path/to/the/tree/c/reg_test/run

ourdir=`dirname $0`
srcdir=$ourdir/../..
pwd=`pwd`

try1=$pwd/../mlr    # For autoconf builds, in-tree or out-of-tree
try2=$srcdir/c/mlr  # For non-autoconf builds
if [ -x "$try1" ]; then
  path_to_mlr=$try1
elif [ -x "$try2" ]; then
  path_to_mlr=$try2
else
  echo "$0: Could not find path to mlr executable." 1>&2
  echo "Try 1: $try1" 1>&2
  echo "Try 2: $try2" 1>&2
  exit 1
fi

# mlr lecat, mlr termcvt, etc. do not accept initial '--no-mmap'.
path_to_mlr_for_auxents="$path_to_mlr"

if [ "$1" = "--valgrind" ]; then
  # Leak-check the test suite. Needs 'make mlrg' first.
  # ../tools/clean-valg can be used to filter the output.
  path_to_mlr="valgrind --leak-check=full ${path_to_mlr}g"
  path_to_mlr_for_auxents="$path_to_mlr"
fi
echo Using mlr executable $path_to_mlr

# ----------------------------------------------------------------
# Input/output locations
indir=$ourdir/input
expdir=$ourdir/expected
outdir=$pwd/output-regtest
reloutdir=./output-regtest
outfile=$outdir/out
expfile=$expdir/out

# ================================================================
# Functions

num_completed=0
num_passed=0
num_failed=0

announce() {
  echo >> $outfile
  echo "================================================================" >> $outfile
  echo "$@" >> $outfile
  echo >> $outfile
}

mention() {
  echo >> $outfile
  echo ---------------------------------------------------------------- "$@" >> $outfile
}

# A key feature of this regression script is that it can be invoked from any
# directory. Depending on the directory it's invoked from, the path to the mlr
# executable may vary.  Nonetheless for debugging it's crucial that we echo out
# each command being executed. See also diff -I below.
run_mlr() {
  # Use just "mlr" for info messages
  echo mlr "$@"
  echo mlr "$@" >> $outfile
  # Use path to mlr for invoking the command
  $path_to_mlr "$@" >> $outfile
  status=$?
  num_completed=`expr $num_completed + 1`
  if [ $status -eq 0 ]; then
    num_passed=`expr $num_passed + 1`
  else
    num_failed=`expr $num_failed + 1`
  fi
  echo >> $outfile
}

run_cat() {
  echo cat "$@"
  echo cat "$@" >> $outfile
  cat "$@" >> $outfile
  echo >> $outfile
}

run_mlr_for_auxents() {
  # Use just "mlr" for info messages
  echo mlr "$@" >> $outfile
  # Use path to mlr for invoking the command
  $path_to_mlr_for_auxents "$@" >> $outfile
  status=$?
  num_completed=`expr $num_completed + 1`
  if [ $status -eq 0 ]; then
    num_passed=`expr $num_passed + 1`
  else
    num_failed=`expr $num_failed + 1`
  fi
}

run_mlr_for_auxents_no_output() {
  # Use just "mlr" for info messages
  echo mlr "$@" >> $outfile
  # Use path to mlr for invoking the command
  $path_to_mlr_for_auxents "$@"
  status=$?
  num_completed=`expr $num_completed + 1`
  if [ $status -eq 0 ]; then
    num_passed=`expr $num_passed + 1`
  else
    num_failed=`expr $num_failed + 1`
  fi
}

# Just cats a file while also announcing that fact.
run_cat() {
  echo cat "$@"
  echo cat "$@" >> $outfile # for diff at end
  cat "$@" >> $outfile      # for diff at end
  echo >> $outfile
}

mlr_expect_fail() {
  # Use just "mlr" for info messages
  echo mlr "$@"
  echo mlr "$@" >> $outfile
  # Use path to mlr for invoking the command
  stderr_capture=$( $path_to_mlr "$@" 3>&1 1>&2 2>&3 >>$outfile )
  status=$?
  num_completed=`expr $num_completed + 1`
  if [ $status -eq 1 ]; then
    num_passed=`expr $num_passed + 1`
  else
    num_failed=`expr $num_failed + 1`
  fi
  echo "${stderr_capture}" >> $outfile
  if [ $status -ne 1 ]; then
    echo "Exit status was $status; expected 1."
    echo "Exit status was $status; expected 1." >> $outfile
  fi
  echo >> $outfile
}

# ================================================================
# Start of script

mkdir -p $outdir

# Don't let the running user's .mlrrc affect the regression test
export MLRRC="__none__"

rm -rf $outdir
mkdir -p $outdir
touch $outfile
echo

# ================================================================
announce STATELESS MAPPERS

run_mlr cat $indir/abixy
run_mlr cat /dev/null

run_mlr cat -n $indir/abixy-het
run_mlr cat -N counter $indir/abixy-het

run_mlr cat -g a,b $indir/abixy-het
run_mlr cat -g a,b $indir/abixy-het

run_mlr cat -g a,b -n $indir/abixy-het
run_mlr cat -g a,b -N counter $indir/abixy-het

run_mlr cut -f a,x $indir/abixy
run_mlr cut --complement -f a,x $indir/abixy

run_mlr cut -r    -f c,e         $indir/having-fields-regex.dkvp
run_mlr cut -r    -f '"C","E"'   $indir/having-fields-regex.dkvp
run_mlr cut -r    -f '"c"i,"e"'  $indir/having-fields-regex.dkvp
run_mlr cut -r    -f '"C"i,"E"'  $indir/having-fields-regex.dkvp
run_mlr cut -r -x -f c,e         $indir/having-fields-regex.dkvp
run_mlr cut -r -x -f '"C","E"'   $indir/having-fields-regex.dkvp
run_mlr cut -r -x -f '"C","E"i'  $indir/having-fields-regex.dkvp
run_mlr cut -r -x -f '"c","e"i'  $indir/having-fields-regex.dkvp

run_mlr --csvlite cut -r -f '^Name$,^Date_[0-9].*$' $indir/date1.csv $indir/date2.csv

run_mlr having-fields --at-least  a,b         $indir/abixy
run_mlr having-fields --at-least  a,c         $indir/abixy
run_mlr having-fields --at-least  a,b,i,x,y   $indir/abixy
run_mlr having-fields --which-are a,b,i,x     $indir/abixy
run_mlr having-fields --which-are a,b,i,x,y   $indir/abixy
run_mlr having-fields --which-are a,b,i,y,x   $indir/abixy
run_mlr having-fields --which-are a,b,i,x,w   $indir/abixy
run_mlr having-fields --which-are a,b,i,x,y,z $indir/abixy
run_mlr having-fields --at-most   a,c         $indir/abixy
run_mlr having-fields --at-most   a,b,i,x,y   $indir/abixy
run_mlr having-fields --at-most   a,b,i,x,y,z $indir/abixy

run_mlr having-fields --all-matching  '"^[a-z][a-z][a-z]$"'  $indir/having-fields-regex.dkvp
run_mlr having-fields --any-matching  '"^[a-z][a-z][a-z]$"'  $indir/having-fields-regex.dkvp
run_mlr having-fields --none-matching '"^[a-z][a-z][a-z]$"'  $indir/having-fields-regex.dkvp
run_mlr having-fields --all-matching  '"^[a-z][a-z][a-z]$"i' $indir/having-fields-regex.dkvp
run_mlr having-fields --any-matching  '"^[a-z][a-z][a-z]$"i' $indir/having-fields-regex.dkvp
run_mlr having-fields --none-matching '"^[a-z][a-z][a-z]$"i' $indir/having-fields-regex.dkvp

run_mlr rename b,BEE,x,EKS $indir/abixy
run_mlr rename nonesuch,nonesuch,x,EKS $indir/abixy

run_mlr         label NEW             $indir/abixy
run_mlr         label a,NEW,c         $indir/abixy
run_mlr         label 1,2,3,4,5,6,7,8 $indir/abixy
run_mlr         label d,x,f           $indir/abixy
mlr_expect_fail label d,x,d           $indir/abixy

run_mlr --csvlite rename -r    '^Date_[0-9].*$,Date'  $indir/date1.csv $indir/date2.csv
run_mlr --csvlite rename -r    '(.*)e(.*),\1EEE\2'    $indir/date1.csv $indir/date2.csv
run_mlr --csvlite rename -r    '"(.*)e(.*)"i,\1EEE\2' $indir/date1.csv $indir/date2.csv
run_mlr --csvlite rename -r -g '"(.*)e(.*)"i,\1EEE\2' $indir/date1.csv $indir/date2.csv
run_mlr --csvlite rename -r    '^(.a.e)(_.*)?,AA\1BB\2CC' $indir/date1.csv
run_mlr --csvlite rename -r    '"e",EEE'              $indir/date1.csv $indir/date2.csv
run_mlr --csvlite rename -r -g '"e",EEE'              $indir/date1.csv $indir/date2.csv
run_mlr --csvlite rename -r    '"e"i,EEE'             $indir/date1.csv $indir/date2.csv
run_mlr --csvlite rename -r -g '"e"i,EEE'             $indir/date1.csv $indir/date2.csv

run_mlr regularize $indir/regularize.dkvp

run_mlr --opprint bar -f x,y --lo 0 --hi 1 $indir/abixy
run_mlr --opprint bar -f x,y -c c -x x -b b --lo 0.1 --hi 0.9 -w 20 $indir/abixy
run_mlr --opprint bar --auto -f x,y -w 10 $indir/abixy

run_mlr altkv <<EOF
a,b,c,d,e,f
EOF
run_mlr altkv <<EOF
a,b,c,d,e,f,g
EOF

# ----------------------------------------------------------------
announce TRIVIAL RETAINERS

run_mlr group-by a   $indir/abixy
run_mlr group-by a,b $indir/abixy

run_mlr group-like $indir/het.dkvp

run_mlr tac $indir/abixy
run_mlr tac /dev/null

run_mlr --opprint unsparsify $indir/abixy
run_mlr --opprint unsparsify $indir/abixy-het

run_mlr --opprint unsparsify -f nonesuch $indir/abixy-het
run_mlr --opprint unsparsify -f a,b,i,x,y $indir/abixy-het
run_mlr --opprint unsparsify -f aaa,bbb,xxx,iii,yyy $indir/abixy-het
run_mlr --opprint unsparsify -f a,b,i,x,y,aaa,bbb,xxx,iii,yyy $indir/abixy-het
run_mlr --opprint unsparsify -f a,b,i,x,y,aaa,bbb,xxx,iii,yyy then regularize $indir/abixy-het

run_mlr --csv skip-trivial-records $indir/trivial-records.csv
run_mlr --csv remove-empty-columns $indir/remove-empty-columns.csv

run_mlr format-values $indir/abixy
run_mlr format-values -n $indir/abixy
run_mlr format-values -i %08llx -f %.6le -s X%sX $indir/abixy
run_mlr format-values -i %08llx -f %.6le -s X%sX -n $indir/abixy

# ----------------------------------------------------------------
announce REPEAT

run_mlr repeat -n 5 $indir/repeat-input.dat
run_mlr repeat -f a $indir/repeat-input.dat
run_mlr repeat -f b $indir/repeat-input.dat
run_mlr repeat -f c $indir/repeat-input.dat

# ----------------------------------------------------------------
announce MAPPER NOTHING

run_mlr cat then nothing < $indir/abixy
run_mlr cat then nothing   $indir/abixy
run_mlr tac then nothing   $indir/abixy
run_mlr cat then nothing   $indir/abixy $indir/abixy
run_mlr cat then nothing then cat $indir/abixy

# ----------------------------------------------------------------
announce CHAINING

run_mlr cat then cat $indir/short
run_mlr cat then tac $indir/short
run_mlr tac then cat $indir/short
run_mlr tac then tac $indir/short

run_mlr cat then cat then cat $indir/short
run_mlr cat then cat then tac $indir/short
run_mlr cat then tac then cat $indir/short
run_mlr cat then tac then tac $indir/short
run_mlr tac then cat then cat $indir/short
run_mlr tac then cat then tac $indir/short
run_mlr tac then tac then cat $indir/short
run_mlr tac then tac then tac $indir/short

# ----------------------------------------------------------------
announce HEAD/TAIL/ETC.

run_mlr head -n 2        $indir/abixy-het
run_mlr head -n 2 -g a   $indir/abixy-het
run_mlr head -n 2 -g a,b $indir/abixy-het

# Test allowing then-chains to start with an initial 'then'
run_mlr \
    then cat \
    then head -n 2 -g a,b \
    then tac \
    $indir/abixy-het

# Test early-out for unkeyed head
run_mlr head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
run_mlr head -n 2 -g a then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
run_mlr cat then head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
run_mlr tac then head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide
run_mlr head -n 2 then put 'end{ print "Final NR is ".NR}' $indir/abixy-wide $indir/abixy-wide $indir/abixy-wide

run_mlr tail -n 2        $indir/abixy-het
run_mlr tail -n 2 -g a   $indir/abixy-het
run_mlr tail -n 2 -g a,b $indir/abixy-het

run_mlr top -f x,y -n 2        $indir/abixy-het
run_mlr top -f x,y -n 2 -g a   $indir/abixy-het
run_mlr top -f x,y -n 2 -g a,b $indir/abixy-het

run_mlr top -f x,y -n 2        $indir/ints.dkvp
run_mlr top -f x,y -n 2 -F     $indir/ints.dkvp

run_mlr top    -n 4 -f x        $indir/abixy-wide
run_mlr top    -n 1 -f x,y      $indir/abixy-wide
run_mlr top    -n 4 -f x   -g a $indir/abixy-wide
run_mlr top    -n 1 -f x,y -g a $indir/abixy-wide
run_mlr top -a -n 4 -f x        $indir/abixy-wide
run_mlr top -a -n 4 -f x   -g a $indir/abixy-wide

run_mlr top    -n 3 -f x,y       $indir/near-ovf.dkvp
run_mlr top    -n 3 -f x,y --min $indir/near-ovf.dkvp
run_mlr top -F -n 3 -f x,y       $indir/near-ovf.dkvp
run_mlr top -F -n 3 -f x,y --min $indir/near-ovf.dkvp

run_mlr --seed 12345 bootstrap       $indir/abixy-het
run_mlr --seed 12345 bootstrap -n  2 $indir/abixy-het
run_mlr --seed 12345 bootstrap -n 20 $indir/abixy-het

run_mlr --seed 12345 sample -k 2        $indir/abixy-het
run_mlr --seed 12345 sample -k 2 -g a   $indir/abixy-het
run_mlr --seed 12345 sample -k 2 -g a,b $indir/abixy-het

run_mlr --seed 12345 shuffle $indir/abixy-het
run_mlr --seed 23456 shuffle $indir/abixy-het
run_mlr --seed 34567 shuffle $indir/abixy-het

run_mlr uniq    -g a   $indir/abixy-het
run_mlr uniq    -g a,b $indir/abixy-het

run_mlr uniq    -f a   $indir/abixy-het
run_mlr uniq    -f a,b $indir/abixy-het

run_mlr uniq -c -g a   $indir/abixy-het
run_mlr uniq -c -g a,b $indir/abixy-het

run_mlr count-distinct -f a      $indir/small $indir/abixy
run_mlr count-distinct -f a,b    $indir/small $indir/abixy
run_mlr count-distinct -f a,b -u $indir/small $indir/abixy

run_mlr count-distinct -f a   -n $indir/small $indir/abixy
run_mlr count-distinct -f a,b -n $indir/small $indir/abixy

run_mlr uniq    -g a   -o foo $indir/abixy-het
run_mlr uniq    -g a,b -o foo $indir/abixy-het

run_mlr uniq    -f a   -o foo $indir/abixy-het
run_mlr uniq    -f a,b -o foo $indir/abixy-het

run_mlr uniq -c -g a   -o foo $indir/abixy-het
run_mlr uniq -c -g a,b -o foo $indir/abixy-het

run_mlr uniq -a           $indir/repeats.dkvp
run_mlr uniq -a -c        $indir/repeats.dkvp
run_mlr uniq -a -c -o foo $indir/repeats.dkvp
run_mlr uniq -a -n        $indir/repeats.dkvp
run_mlr uniq -a -n -o bar $indir/repeats.dkvp

run_mlr count-distinct -f a   -o foo $indir/small $indir/abixy
run_mlr count-distinct -f a,b -o foo $indir/small $indir/abixy

run_mlr count-distinct -f a   -n -o foo $indir/small $indir/abixy
run_mlr count-distinct -f a,b -n -o foo $indir/small $indir/abixy

run_mlr grep    pan $indir/abixy-het
run_mlr grep -v pan $indir/abixy-het

run_mlr decimate         -n 4 $indir/abixy
run_mlr decimate      -b -n 4 $indir/abixy
run_mlr decimate      -e -n 4 $indir/abixy
run_mlr decimate -g a    -n 2 $indir/abixy
run_mlr decimate -g a -b -n 2 $indir/abixy
run_mlr decimate -g a -e -n 2 $indir/abixy

# ----------------------------------------------------------------
announce WHITESPACE-REDUCTION

run_mlr --icsv --ojson cat                                $indir/clean-whitespace.csv
run_mlr --icsv --ojson put '$a = lstrip($a)'              $indir/clean-whitespace.csv
run_mlr --icsv --ojson put '$a = rstrip($a)'              $indir/clean-whitespace.csv
run_mlr --icsv --ojson put '$a = strip($a)'               $indir/clean-whitespace.csv
run_mlr --icsv --ojson put '$a = collapse_whitespace($a)' $indir/clean-whitespace.csv
run_mlr --icsv --ojson put '$a = clean_whitespace($a)'    $indir/clean-whitespace.csv

run_mlr --icsv --ojson clean-whitespace -k $indir/clean-whitespace.csv
run_mlr --icsv --ojson clean-whitespace -v $indir/clean-whitespace.csv
run_mlr --icsv --ojson clean-whitespace    $indir/clean-whitespace.csv

# ----------------------------------------------------------------
announce SORT

run_mlr sort -f a   $indir/abixy
run_mlr sort -r a   $indir/abixy
run_mlr sort -f x   $indir/abixy
run_mlr sort -r x   $indir/abixy
run_mlr sort -nf x  $indir/abixy
run_mlr sort -nr x  $indir/abixy

run_mlr sort -f a,b   $indir/abixy
run_mlr sort -r a,b   $indir/abixy
run_mlr sort -f x,y   $indir/abixy
run_mlr sort -r x,y   $indir/abixy
run_mlr sort -nf x,y  $indir/abixy
run_mlr sort -nr x,y  $indir/abixy

run_mlr sort -f a -nr x $indir/abixy
run_mlr sort -nr y -f a $indir/abixy
run_mlr sort -f a -r b -nf x -nr y $indir/abixy

run_mlr sort -f x $indir/sort-het.dkvp
run_mlr sort -r x $indir/sort-het.dkvp

# ----------------------------------------------------------------
announce SORT-WITHIN-RECORDS

run_mlr sort-within-records $indir/sort-within-records.dkvp

# ----------------------------------------------------------------
announce JOIN

run_mlr --opprint join -s                -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join                   -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s      --ul      -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join         --ul      -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s           --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join              --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s --ul      --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join         --ul --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s --np --ul      -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join    --np --ul      -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s --np      --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join    --np      --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s --np --ul --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join    --np --ul --ur -f $indir/joina.dkvp -l l -r r -j o $indir/joinb.dkvp

run_mlr join -l l -r r -j j -f $indir/joina.dkvp $indir/joinb.dkvp
run_mlr join -l l      -j r -f $indir/joina.dkvp $indir/joinb.dkvp
run_mlr join      -r r -j l -f $indir/joina.dkvp $indir/joinb.dkvp

run_mlr --opprint join -s                -f /dev/null -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join                   -f /dev/null -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s      --ul      -f /dev/null -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join         --ul      -f /dev/null -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s           --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join              --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s      --ul --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join         --ul --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s --np --ul      -f /dev/null -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join    --np --ul      -f /dev/null -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s --np      --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join    --np      --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp

run_mlr --opprint join -s --np --ul --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp
run_mlr --opprint join    --np --ul --ur -f /dev/null -l l -r r -j o $indir/joinb.dkvp


run_mlr --opprint join -s                -f $indir/joina.dkvp -l l -r r -j o /dev/null
run_mlr --opprint join                   -f $indir/joina.dkvp -l l -r r -j o /dev/null

run_mlr --opprint join -s      --ul      -f $indir/joina.dkvp -l l -r r -j o /dev/null
run_mlr --opprint join         --ul      -f $indir/joina.dkvp -l l -r r -j o /dev/null

run_mlr --opprint join -s           --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null
run_mlr --opprint join              --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null

run_mlr --opprint join -s      --ul --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null
run_mlr --opprint join         --ul --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null

run_mlr --opprint join -s --np --ul      -f $indir/joina.dkvp -l l -r r -j o /dev/null
run_mlr --opprint join    --np --ul      -f $indir/joina.dkvp -l l -r r -j o /dev/null

run_mlr --opprint join -s --np      --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null
run_mlr --opprint join    --np      --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null

run_mlr --opprint join -s --np --ul --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null
run_mlr --opprint join    --np --ul --ur -f $indir/joina.dkvp -l l -r r -j o /dev/null

run_mlr --odkvp join -j a -f $indir/join-het.dkvp $indir/abixy-het
run_mlr --odkvp join -j a -f $indir/abixy-het     $indir/join-het.dkvp
run_mlr --odkvp join --np --ul --ur -j a -f $indir/join-het.dkvp $indir/abixy-het
run_mlr --odkvp join --np --ul --ur -j a -f $indir/abixy-het     $indir/join-het.dkvp

run_mlr --idkvp --oxtab join --lp left_ --rp right_ -j i -f $indir/abixy-het $indir/abixy-het

for sorted_flag in "-s" ""; do
  for pairing_flags in "" "--np --ul" "--np --ur"; do
    for i in 1 2 3 4 5 6; do
      run_mlr join $sorted_flag $pairing_flags -l l -r r -j j -f $indir/het-join-left $indir/het-join-right-r$i
      for j in 1 2 3 4 5 6; do
        if [ "$i" -le "$j" ]; then
          run_mlr join $sorted_flag $pairing_flags -l l -r r -j j -f $indir/het-join-left $indir/het-join-right-r$i$j
        fi
      done
    done
  done
done

# ----------------------------------------------------------------
announce JOIN PREPIPE

run_mlr --prepipe cat --odkvp join -j a -f $indir/join-het.dkvp $indir/abixy-het
run_mlr --odkvp join --prepipe cat -j a -f $indir/join-het.dkvp $indir/abixy-het
run_mlr --prepipe cat --odkvp join --prepipe cat -j a -f $indir/join-het.dkvp $indir/abixy-het

# ----------------------------------------------------------------
announce JOIN MIXED-FORMAT

# in1, in2, out all same formats
run_mlr --json    join -s -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.json
run_mlr --dkvp    join -s -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.dkvp
run_mlr --csvlite join -s -j x -f $indir/multi-format-join-a.csv  $indir/multi-format-join-b.csv

run_mlr --json    join -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.json
run_mlr --dkvp    join -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.dkvp
run_mlr --csvlite join -j x -f $indir/multi-format-join-a.csv  $indir/multi-format-join-b.csv

# in2 different format
run_mlr --json    join -s -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.json
run_mlr --dkvp    join -s -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.dkvp
run_mlr --csvlite join -s -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.csv

run_mlr --json    join    -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.json
run_mlr --dkvp    join    -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.dkvp
run_mlr --csvlite join    -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.csv

run_mlr --json    join -s -i dkvp  -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.json
run_mlr --dkvp    join -s -i dkvp  -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.dkvp
run_mlr --csvlite join -s -i dkvp  -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.csv

run_mlr --json    join    -i dkvp  -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.json
run_mlr --dkvp    join    -i dkvp  -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.dkvp
run_mlr --csvlite join    -i dkvp  -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.csv

run_mlr --json    join -s -i json  -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.json
run_mlr --dkvp    join -s -i json  -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.dkvp
run_mlr --csvlite join -s -i json  -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.csv

run_mlr --json    join    -i json  -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.json
run_mlr --dkvp    join    -i json  -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.dkvp
run_mlr --csvlite join    -i json  -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.csv

# vary all three
run_mlr --ijson    --ojson join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.json
run_mlr --idkvp    --ojson join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --ojson join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.csv

run_mlr --ijson    --ojson join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.json
run_mlr --idkvp    --ojson join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --ojson join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.csv

run_mlr --ijson    --ojson join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.json
run_mlr --idkvp    --ojson join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --ojson join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.csv


run_mlr --ijson    --odkvp join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.json
run_mlr --idkvp    --odkvp join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --odkvp join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.csv

run_mlr --ijson    --odkvp join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.json
run_mlr --idkvp    --odkvp join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --odkvp join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.csv

run_mlr --ijson    --odkvp join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.json
run_mlr --idkvp    --odkvp join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --odkvp join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.csv


run_mlr --ijson    --ocsvlite join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.json
run_mlr --idkvp    --ocsvlite join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --ocsvlite join -i csvlite -j x -f $indir/multi-format-join-a.csv $indir/multi-format-join-b.csv

run_mlr --ijson    --ocsvlite join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.json
run_mlr --idkvp    --ocsvlite join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --ocsvlite join -i dkvp     -j x -f $indir/multi-format-join-a.dkvp $indir/multi-format-join-b.csv

run_mlr --ijson    --ocsvlite join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.json
run_mlr --idkvp    --ocsvlite join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.dkvp
run_mlr --icsvlite --ocsvlite join -i json     -j x -f $indir/multi-format-join-a.json $indir/multi-format-join-b.csv

# ----------------------------------------------------------------
announce RESHAPE

run_mlr --pprint reshape -i X,Y,Z   -o item,price $indir/reshape-wide.tbl
run_mlr --pprint reshape -i X,Z     -o item,price $indir/reshape-wide.tbl
run_mlr --pprint reshape -r '[X-Z]' -o item,price $indir/reshape-wide.tbl
run_mlr --pprint reshape -r '[XZ]'  -o item,price $indir/reshape-wide.tbl

run_mlr --pprint reshape -s item,price $indir/reshape-long.tbl

run_mlr --pprint reshape -i X,Y,Z -o item,price then reshape -s item,price $indir/reshape-wide.tbl
run_mlr --pprint reshape -s item,price then reshape -i X,Y,Z -o item,price $indir/reshape-long.tbl

run_mlr reshape -i X,Y,Z   -o item,price $indir/reshape-wide-ragged.dkvp
run_mlr reshape -i X,Z     -o item,price $indir/reshape-wide-ragged.dkvp
run_mlr reshape -r '[X-Z]' -o item,price $indir/reshape-wide-ragged.dkvp
run_mlr reshape -r '[XZ]'  -o item,price $indir/reshape-wide-ragged.dkvp

run_mlr reshape -s item,price $indir/reshape-long-ragged.dkvp

run_mlr --json reshape -i x,y -o item,value $indir/small-non-nested.json

# ----------------------------------------------------------------
announce NEST

run_mlr cat $indir/nest-explode.dkvp
run_mlr cat $indir/nest-explode-vary-fs-ps.dkvp

run_mlr nest --explode --values --across-fields  -f x $indir/nest-explode.dkvp
run_mlr nest --explode --values --across-fields  -f x --nested-fs pipe --nested-ps = $indir/nest-explode-vary-fs-ps.dkvp

run_mlr nest --explode --values --across-fields  -f x then nest --implode --values --across-fields  -f x $indir/nest-explode.dkvp
run_mlr nest --explode --values --across-fields  -f x --nested-fs pipe --nested-ps = then nest --implode --values --across-fields  -f x --nested-fs pipe --nested-ps = $indir/nest-explode-vary-fs-ps.dkvp

run_mlr nest --explode --values --across-records -f x $indir/nest-explode.dkvp
run_mlr nest --explode --values --across-records -f x --nested-fs pipe --nested-ps = $indir/nest-explode-vary-fs-ps.dkvp

run_mlr nest --explode --values --across-records -f x then nest --implode --values --across-records -f x $indir/nest-explode.dkvp
run_mlr nest --explode --values --across-records -f x --nested-fs pipe --nested-ps = then nest --implode --values --across-records -f x --nested-fs pipe --nested-ps = $indir/nest-explode-vary-fs-ps.dkvp

run_mlr nest --explode --pairs  --across-fields  -f x $indir/nest-explode.dkvp
run_mlr nest --explode --pairs  --across-fields  -f x --nested-fs pipe --nested-ps = $indir/nest-explode-vary-fs-ps.dkvp

run_mlr nest --explode --pairs  --across-records -f x $indir/nest-explode.dkvp
run_mlr nest --explode --pairs  --across-records -f x --nested-fs pipe --nested-ps = $indir/nest-explode-vary-fs-ps.dkvp

# ----------------------------------------------------------------
announce FILL-DOWN

run_mlr --csv fill-down -f a,b,c    $indir/fill-down.csv
run_mlr --csv fill-down -f a,b,c -a $indir/fill-down.csv

# ----------------------------------------------------------------
announce FILL-EMPTY

run_mlr --csv fill-empty        $indir/fill-down.csv
run_mlr --csv fill-empty -v FOO $indir/fill-down.csv

# ----------------------------------------------------------------
announce SEQGEN

run_mlr seqgen --start 1 --stop 5 --step  1
run_mlr seqgen --start 1 --stop 5 --step  2
run_mlr seqgen --start 1 --stop 1 --step  1 -f a
run_mlr seqgen --start 5 --stop 1 --step  1 -f b
run_mlr seqgen --start 5 --stop 1 --step -1 -f c
run_mlr seqgen --start 5 --stop 5 --step -1 -f d
run_mlr --from $indir/abixy cat then seqgen --start 1 --stop 5
run_mlr --from $indir/abixy cat then seqgen --start 1 --stop 100 then stats1 -a count,sum,min,p50,max -f i

# ----------------------------------------------------------------
announce FRACTION

run_mlr fraction -f x,y              $indir/abixy-het
run_mlr fraction -f x,y -g a         $indir/abixy-het
run_mlr fraction -f x,y -g a,b       $indir/abixy-het

run_mlr fraction -f x,y        -p    $indir/abixy-het
run_mlr fraction -f x,y -g a   -p    $indir/abixy-het
run_mlr fraction -f x,y -g a,b -p    $indir/abixy-het

run_mlr fraction -f x,y           -c $indir/abixy-het
run_mlr fraction -f x,y -g a      -c $indir/abixy-het
run_mlr fraction -f x,y -g a,b    -c $indir/abixy-het

run_mlr fraction -f x,y        -p -c $indir/abixy-het
run_mlr fraction -f x,y -g a   -p -c $indir/abixy-het
run_mlr fraction -f x,y -g a,b -p -c $indir/abixy-het

# ----------------------------------------------------------------
announce STATS

run_mlr --opprint stats1    -a mean,sum,count,min,max,antimode,mode     -f i,x,y $indir/abixy
run_mlr --opprint stats1    -a min,p10,p50,median,antimode,mode,p90,max -f i,x,y $indir/abixy
run_mlr --opprint stats1    -a mean,meaneb,stddev                       -f i,x,y $indir/abixy
run_mlr --oxtab   stats1 -s -a mean,sum,count,min,max,antimode,mode     -f i,x,y $indir/abixy

run_mlr --opprint stats1    -a mean,sum,count,min,max,antimode,mode     -f i,x,y -g a $indir/abixy
run_mlr --opprint stats1    -a min,p10,p50,median,antimode,mode,p90,max -f i,x,y -g a $indir/abixy
run_mlr --opprint stats1    -a mean,meaneb,stddev                       -f i,x,y -g a $indir/abixy
run_mlr --oxtab   stats1 -s -a mean,sum,count,min,max,antimode,mode     -f i,x,y -g a $indir/abixy

run_mlr --opprint stats1    -a mean,sum,count,min,max,antimode,mode     -f i,x,y -g a,b $indir/abixy
run_mlr --opprint stats1    -a min,p10,p50,median,antimode,mode,p90,max -f i,x,y -g a,b $indir/abixy
run_mlr --opprint stats1    -a mean,meaneb,stddev                       -f i,x,y -g a,b $indir/abixy
run_mlr --oxtab   stats1 -s -a mean,sum,count,min,max,antimode,mode     -f i,x,y -g a,b $indir/abixy

run_mlr --oxtab stats1 -a min,p0,p50,p100,max -f x,y,z $indir/string-numeric-ordering.dkvp

run_mlr --oxtab   stats1 -a mean -f x      $indir/abixy-het
run_mlr --oxtab   stats1 -a mean -f x -g a $indir/abixy-het

run_mlr --oxtab   stats1 -a p0,p50,p100 -f x,y    $indir/near-ovf.dkvp
run_mlr --oxtab   stats1 -a p0,p50,p100 -f x,y -F $indir/near-ovf.dkvp

run_mlr --opprint stats2       -a linreg-ols,linreg-pca,r2,corr,cov -f x,y,xy,y2        $indir/abixy-wide
run_mlr --opprint stats2       -a linreg-ols,linreg-pca,r2,corr,cov -f x,y,xy,y2 -g a,b $indir/abixy-wide
run_mlr --oxtab   stats2 -s    -a linreg-ols,linreg-pca,r2,corr,cov -f x,y,xy,y2        $indir/abixy-wide-short
run_mlr --oxtab   stats2 -s    -a linreg-ols,linreg-pca,r2,corr,cov -f x,y,xy,y2 -g a,b $indir/abixy-wide-short
run_mlr --opprint stats2 --fit -a linreg-ols,linreg-pca             -f x,y,xy,y2        $indir/abixy-wide-short
run_mlr --opprint stats2 --fit -a linreg-ols,linreg-pca             -f x,y,xy,y2 -g a   $indir/abixy-wide-short

run_mlr --opprint stats2    -a logireg -f x,y      $indir/logi.dkvp
run_mlr --opprint stats2    -a logireg -f x,y -g g $indir/logi.dkvp

run_mlr --oxtab   stats2 -a cov -f x,y      $indir/abixy-het
run_mlr --oxtab   stats2 -a cov -f x,y -g a $indir/abixy-het

run_mlr --opprint step -a rsum,shift,delta,counter -f x,y $indir/abixy
run_mlr --opprint step -a rsum,shift,delta,counter -f x,y -g a $indir/abixy
run_mlr --opprint step -a ewma -d 0.1,0.9 -f x,y -g a $indir/abixy
run_mlr --opprint step -a ewma -d 0.1,0.9 -o smooth,rough -f x,y -g a $indir/abixy

run_mlr --odkvp   step -a rsum,shift,delta,counter -f x,y      $indir/abixy-het
run_mlr --odkvp   step -a rsum,shift,delta,counter -f x,y -g a $indir/abixy-het
run_mlr --opprint step -a ewma -d 0.1,0.9 -f x,y -g a $indir/abixy-het
run_mlr --opprint step -a ewma -d 0.1,0.9 -o smooth,rough -f x,y -g a $indir/abixy-het

run_mlr --icsvlite --opprint step -a from-first -f x      $indir/from-first.csv
run_mlr --icsvlite --opprint step -a from-first -f x -g g $indir/from-first.csv

run_mlr --opprint histogram -f x,y --lo 0 --hi 1 --nbins 20 $indir/small
run_mlr --opprint histogram -f x,y --lo 0 --hi 1 --nbins 20 -o foo_ $indir/small

run_mlr --opprint histogram --nbins 9 --auto -f x,y $indir/ints.dkvp
run_mlr --opprint histogram --nbins 9 --auto -f x,y -o foo_ $indir/ints.dkvp

run_mlr --csvlite --opprint merge-fields    -a p0,min,p29,max,p100,sum -c _in,_out $indir/merge-fields-in-out.csv
run_mlr --csvlite --opprint merge-fields -k -a p0,min,p29,max,p100,sum -c _in,_out $indir/merge-fields-in-out.csv

run_mlr --csvlite --opprint merge-fields -i    -a p0,min,p29,max,p100,sum -c _in,_out $indir/merge-fields-in-out.csv
run_mlr --csvlite --opprint merge-fields -i -k -a p0,min,p29,max,p100,sum -c _in,_out $indir/merge-fields-in-out.csv

run_mlr --csvlite --opprint merge-fields    -a p0,min,p29,max,p100 -c _in,_out $indir/merge-fields-in-out-mixed.csv
run_mlr --csvlite --opprint merge-fields -k -a p0,min,p29,max,p100 -c _in,_out $indir/merge-fields-in-out-mixed.csv

run_mlr --oxtab merge-fields -k -a p0,min,p29,max,p100,sum,count -f a_in_x,a_out_x -o foo $indir/merge-fields-abxy.dkvp
run_mlr --oxtab merge-fields -k -a p0,min,p29,max,p100,sum,count -r in_,out_       -o bar $indir/merge-fields-abxy.dkvp
run_mlr --oxtab merge-fields -k -a p0,min,p29,max,p100,sum,count -c in_,out_              $indir/merge-fields-abxy.dkvp

run_mlr --oxtab merge-fields -i -k -a p0,min,p29,max,p100,sum,count -f a_in_x,a_out_x -o foo $indir/merge-fields-abxy.dkvp
run_mlr --oxtab merge-fields -i -k -a p0,min,p29,max,p100,sum,count -r in_,out_       -o bar $indir/merge-fields-abxy.dkvp
run_mlr --oxtab merge-fields -i -k -a p0,min,p29,max,p100,sum,count -c in_,out_              $indir/merge-fields-abxy.dkvp

# ----------------------------------------------------------------
announce STATS1 WITH REGEXED FIELD NAMES

run_mlr --from $indir/abixy --opprint stats1 -a sum  -g  a,b      -f  i,x,y

run_mlr --from $indir/abixy --opprint stats1 -a sum --gr '^[a-h]$' --fr '^[i-z]$'
run_mlr --from $indir/abixy --opprint stats1 -a sum  -g  a,b       --fr '^[i-z]$'
run_mlr --from $indir/abixy --opprint stats1 -a sum --gr '^[a-h]$'  -f  i,x,y

run_mlr --from $indir/abixy --opprint stats1 -a sum --gx '^[i-z]$' --fx '^[a-h]$'
run_mlr --from $indir/abixy --opprint stats1 -a sum  -g  a,b       --fx '^[a-h]$'
run_mlr --from $indir/abixy --opprint stats1 -a sum --gx '^[i-z]$'  -f  i,x,y

# ----------------------------------------------------------------
announce MOST/LEAST FREQUENT

run_mlr --opprint --from $indir/freq.dkvp most-frequent -f a -n 3
run_mlr --opprint --from $indir/freq.dkvp most-frequent -f a,b -n 3
run_mlr --opprint --from $indir/freq.dkvp most-frequent -f a,b -n 3 -b
run_mlr --opprint --from $indir/freq.dkvp most-frequent -f nonesuch -n 3

run_mlr --opprint --from $indir/freq.dkvp least-frequent -f a -n 3
run_mlr --opprint --from $indir/freq.dkvp least-frequent -f a,b -n 3
run_mlr --opprint --from $indir/freq.dkvp least-frequent -f a,b -n 3 -b
run_mlr --opprint --from $indir/freq.dkvp least-frequent -f nonesuch -n 3

run_mlr --opprint --from $indir/freq.dkvp most-frequent -f a -n 3 -o foo
run_mlr --opprint --from $indir/freq.dkvp most-frequent -f a,b -n 3 -o foo
run_mlr --opprint --from $indir/freq.dkvp most-frequent -f a,b -n 3 -b -o foo
run_mlr --opprint --from $indir/freq.dkvp most-frequent -f nonesuch -n 3 -o foo

run_mlr --opprint --from $indir/freq.dkvp least-frequent -f a -n 3 -o foo
run_mlr --opprint --from $indir/freq.dkvp least-frequent -f a,b -n 3 -o foo
run_mlr --opprint --from $indir/freq.dkvp least-frequent -f a,b -n 3 -b -o foo
run_mlr --opprint --from $indir/freq.dkvp least-frequent -f nonesuch -n 3 -o foo

# ----------------------------------------------------------------
announce COUNT-SIMILAR

run_mlr --opprint --from $indir/abixy count-similar -g a
run_mlr --opprint --from $indir/abixy count-similar -g b,i
run_mlr --opprint --from $indir/abixy count-similar -g a,b,i -o other_name_for_counter

# ----------------------------------------------------------------
announce NON-INTERPOLATED AND INTERPOLATED PERCENTILES

for k in 1 2 3 4 5 6 7 8 9 10 11; do
run_mlr --from $indir/x0to10.dat --oxtab head -n $k then stats1 -f x -a p00,p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32,p33,p34,p35,p36,p37,p38,p39,p40,p41,p42,p43,p44,p45,p46,p47,p48,p49,p50,p51,p52,p53,p54,p55,p56,p57,p58,p59,p60,p61,p62,p63,p64,p65,p66,p67,p68,p69,p70,p71,p72,p73,p74,p75,p76,p77,p78,p79,p80,p81,p82,p83,p84,p85,p86,p87,p88,p89,p90,p91,p92,p93,p94,p95,p96,p97,p98,p99,p100
done

for k in 1 2 3 4 5 6 7 8 9 10 11; do
run_mlr --from $indir/x0to10.dat --oxtab head -n $k then stats1 -i -f x -a p00,p01,p02,p03,p04,p05,p06,p07,p08,p09,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32,p33,p34,p35,p36,p37,p38,p39,p40,p41,p42,p43,p44,p45,p46,p47,p48,p49,p50,p51,p52,p53,p54,p55,p56,p57,p58,p59,p60,p61,p62,p63,p64,p65,p66,p67,p68,p69,p70,p71,p72,p73,p74,p75,p76,p77,p78,p79,p80,p81,p82,p83,p84,p85,p86,p87,p88,p89,p90,p91,p92,p93,p94,p95,p96,p97,p98,p99,p100
done

# ----------------------------------------------------------------
announce IN-PLACE PROCESSING

cp $indir/abixy $outdir/abixy.temp1
cp $indir/abixy $outdir/abixy.temp2
run_cat $outdir/abixy.temp1
run_cat $outdir/abixy.temp2
run_mlr -I --opprint head -n 2 $outdir/abixy.temp1 $outdir/abixy.temp2
run_cat $outdir/abixy.temp1
run_cat $outdir/abixy.temp2

mlr_expect_fail -I --opprint head -n 2 < $outdir/abixy.temp1
mlr_expect_fail -I --opprint -n head -n 2 $outdir/abixy.temp1

cp $indir/abixy $outdir/abixy.temp1
cp $indir/abixy $outdir/abixy.temp2
run_cat $outdir/abixy.temp1
run_cat $outdir/abixy.temp2
run_mlr -I --opprint rename a,AYE,b,BEE $outdir/abixy.temp1 $outdir/abixy.temp2
run_cat $outdir/abixy.temp1
run_cat $outdir/abixy.temp2

# ----------------------------------------------------------------
announce DSL OPERATOR ASSOCIATIVITY
# Note: filter -v and put -v print the AST.

run_mlr put    -v '$x = 1 || 2 || 3'   /dev/null
run_mlr filter -v '     1 || 2 || 3'   /dev/null
run_mlr put    -v '$x = 1 ^^ 2 ^^ 3'   /dev/null
run_mlr filter -v '     1 ^^ 2 ^^ 3'   /dev/null
run_mlr put    -v '$x = 1 && 2 && 3'   /dev/null
run_mlr filter -v '     1 && 2 && 3'   /dev/null

run_mlr put    -v '$x = 1  == 2  == 3' /dev/null
run_mlr filter -v '     1  == 2  == 3' /dev/null
run_mlr put    -v '$x = 1  != 2  != 3' /dev/null
run_mlr filter -v '     1  != 2  != 3' /dev/null
run_mlr put    -v '$x = 1  =~ 2  =~ 3' /dev/null
run_mlr filter -v '     1  =~ 2  =~ 3' /dev/null
run_mlr put    -v '$x = 1 !=~ 2 !=~ 3' /dev/null
run_mlr filter -v '     1 !=~ 2 !=~ 3' /dev/null
run_mlr put    -v '$x = 1  == 2  != 3' /dev/null
run_mlr filter -v '     1  == 2  != 3' /dev/null
run_mlr put    -v '$x = 1  != 2  == 3' /dev/null
run_mlr filter -v '     1  != 2  == 3' /dev/null

run_mlr put    -v '$x = 1  <  2  <  3' /dev/null
run_mlr filter -v '     1  <  2  <  3' /dev/null
run_mlr put    -v '$x = 1  <= 2  <= 3' /dev/null
run_mlr filter -v '     1  <= 2  <= 3' /dev/null
run_mlr put    -v '$x = 1  >  2  >  3' /dev/null
run_mlr filter -v '     1  >  2  >  3' /dev/null
run_mlr put    -v '$x = 1  >= 2  >= 3' /dev/null
run_mlr filter -v '     1  >= 2  >= 3' /dev/null
run_mlr put    -v '$x = 1  <  2  <= 3' /dev/null
run_mlr filter -v '     1  <  2  <= 3' /dev/null
run_mlr put    -v '$x = 1  <= 2  <  3' /dev/null
run_mlr filter -v '     1  <= 2  <  3' /dev/null

run_mlr put    -v '$x = 1 |  2 |  3'   /dev/null
run_mlr filter -v '     1 |  2 |  3'   /dev/null
run_mlr put    -v '$x = 1 ^  2 ^  3'   /dev/null
run_mlr filter -v '     1 ^  2 ^  3'   /dev/null
run_mlr put    -v '$x = 1 &  2 &  3'   /dev/null
run_mlr filter -v '     1 &  2 &  3'   /dev/null
run_mlr put    -v '$x = 1 |  2 &  3'   /dev/null
run_mlr filter -v '     1 |  2 &  3'   /dev/null
run_mlr put    -v '$x = 1 |  2 ^  3'   /dev/null
run_mlr filter -v '     1 |  2 ^  3'   /dev/null
run_mlr put    -v '$x = 1 ^  2 |  3'   /dev/null
run_mlr filter -v '     1 ^  2 |  3'   /dev/null
run_mlr put    -v '$x = 1 ^  2 &  3'   /dev/null
run_mlr filter -v '     1 ^  2 &  3'   /dev/null
run_mlr put    -v '$x = 1 &  2 |  3'   /dev/null
run_mlr filter -v '     1 &  2 |  3'   /dev/null
run_mlr put    -v '$x = 1 &  2 ^  3'   /dev/null
run_mlr filter -v '     1 &  2 ^  3'   /dev/null

run_mlr put    -v '$x = 1  << 2  << 3' /dev/null
run_mlr filter -v '     1  << 2  << 3' /dev/null
run_mlr put    -v '$x = 1  >> 2  >> 3' /dev/null
run_mlr filter -v '     1  >> 2  >> 3' /dev/null
run_mlr put    -v '$x = 1  << 2  >> 3' /dev/null
run_mlr filter -v '     1  << 2  >> 3' /dev/null
run_mlr put    -v '$x = 1  >> 2  << 3' /dev/null
run_mlr filter -v '     1  >> 2  << 3' /dev/null

run_mlr put    -v '$x = 1 + 2 + 3'   /dev/null
run_mlr filter -v '     1 + 2 + 3'   /dev/null
run_mlr put    -v '$x = 1 - 2 - 3'   /dev/null
run_mlr filter -v '     1 - 2 - 3'   /dev/null
run_mlr put    -v '$x = 1 + 2 - 3'   /dev/null
run_mlr filter -v '     1 + 2 - 3'   /dev/null
run_mlr put    -v '$x = 1 - 2 + 3'   /dev/null
run_mlr filter -v '     1 - 2 + 3'   /dev/null
run_mlr put    -v '$x = 1 . 2 . 3'   /dev/null
run_mlr filter -v '     1 . 2 . 3'   /dev/null

run_mlr put    -v '$x = 1 * 2 * 3'   /dev/null
run_mlr filter -v '     1 * 2 * 3'   /dev/null
run_mlr put    -v '$x = 1 / 2 / 3'   /dev/null
run_mlr filter -v '     1 / 2 / 3'   /dev/null
run_mlr put    -v '$x = 1 // 2 // 3' /dev/null
run_mlr filter -v '     1 // 2 // 3' /dev/null
run_mlr put    -v '$x = 1 % 2 % 3'   /dev/null
run_mlr filter -v '     1 % 2 % 3'   /dev/null
run_mlr put    -v '$x = 1 ** 2 ** 3' /dev/null
run_mlr filter -v '     1 ** 2 ** 3' /dev/null


run_mlr put    -v '$x = 1 *  2 /  3'   /dev/null
run_mlr filter -v '     1 *  2 /  3'   /dev/null
run_mlr put    -v '$x = 1 *  2 // 3'   /dev/null
run_mlr filter -v '     1 *  2 // 3'   /dev/null
run_mlr put    -v '$x = 1 *  2 %  3'   /dev/null
run_mlr filter -v '     1 *  2 %  3'   /dev/null
run_mlr put    -v '$x = 1 *  2 ** 3'   /dev/null
run_mlr filter -v '     1 *  2 ** 3'   /dev/null

run_mlr put    -v '$x = 1 /  2 *  3'   /dev/null
run_mlr filter -v '     1 /  2 *  3'   /dev/null
run_mlr put    -v '$x = 1 /  2 // 3'   /dev/null
run_mlr filter -v '     1 /  2 // 3'   /dev/null
run_mlr put    -v '$x = 1 /  2 %  3'   /dev/null
run_mlr filter -v '     1 /  2 %  3'   /dev/null
run_mlr put    -v '$x = 1 /  2 ** 3'   /dev/null
run_mlr filter -v '     1 /  2 ** 3'   /dev/null

run_mlr put    -v '$x = 1 // 2 *  3'   /dev/null
run_mlr filter -v '     1 // 2 *  3'   /dev/null
run_mlr put    -v '$x = 1 // 2 /  3'   /dev/null
run_mlr filter -v '     1 // 2 /  3'   /dev/null
run_mlr put    -v '$x = 1 // 2 %  3'   /dev/null
run_mlr filter -v '     1 // 2 %  3'   /dev/null
run_mlr put    -v '$x = 1 // 2 ** 3'   /dev/null
run_mlr filter -v '     1 // 2 ** 3'   /dev/null

run_mlr put    -v '$x = 1 %  2 *  3'   /dev/null
run_mlr filter -v '     1 %  2 *  3'   /dev/null
run_mlr put    -v '$x = 1 %  2 /  3'   /dev/null
run_mlr filter -v '     1 %  2 /  3'   /dev/null
run_mlr put    -v '$x = 1 %  2 // 3'   /dev/null
run_mlr filter -v '     1 %  2 // 3'   /dev/null
run_mlr put    -v '$x = 1 %  2 ** 3'   /dev/null
run_mlr filter -v '     1 %  2 ** 3'   /dev/null

run_mlr put    -v '$x = 1 ** 2 *  3'   /dev/null
run_mlr filter -v '     1 ** 2 *  3'   /dev/null
run_mlr put    -v '$x = 1 ** 2 /  3'   /dev/null
run_mlr filter -v '     1 ** 2 /  3'   /dev/null
run_mlr put    -v '$x = 1 ** 2 // 3'   /dev/null
run_mlr filter -v '     1 ** 2 // 3'   /dev/null
run_mlr put    -v '$x = 1 ** 2 %  3'   /dev/null
run_mlr filter -v '     1 ** 2 %  3'   /dev/null

run_mlr put    -v '$x = ++1'   /dev/null
run_mlr filter -v '     ++1'   /dev/null
run_mlr put    -v '$x = --1'   /dev/null
run_mlr filter -v '     --1'   /dev/null
run_mlr put    -v '$x = !!1'   /dev/null
run_mlr filter -v '     !!1'   /dev/null
run_mlr put    -v '$x = ~~1'   /dev/null
run_mlr filter -v '     ~~1'   /dev/null

run_mlr put    -v '$x = 1 ? 2 : 3'         /dev/null
run_mlr filter -v '     1 ? 2 : 3'         /dev/null
run_mlr put    -v '$x = 1 ? 2 ? 3 : 4 : 5' /dev/null
run_mlr filter -v '     1 ? 2 ? 3 : 4 : 5' /dev/null
run_mlr put    -v '$x = 1 ? 2 : 3 ? 4 : 5' /dev/null
run_mlr filter -v '     1 ? 2 : 3 ? 4 : 5' /dev/null

# ----------------------------------------------------------------
announce DSL OPERATOR PRECEDENCE
# Note: filter -v and put -v print the AST.

run_mlr put    -v '$x = 1 || 2 ^^ 3'   /dev/null
run_mlr filter -v '     1 || 2 ^^ 3'   /dev/null
run_mlr put    -v '$x = 1 || 2 && 3'   /dev/null
run_mlr filter -v '     1 || 2 && 3'   /dev/null

run_mlr put    -v '$x = 1 ^^ 2 || 3'   /dev/null
run_mlr filter -v '     1 ^^ 2 || 3'   /dev/null
run_mlr put    -v '$x = 1 ^^ 2 && 3'   /dev/null
run_mlr filter -v '     1 ^^ 2 && 3'   /dev/null

run_mlr put    -v '$x = 1 && 2 || 3'   /dev/null
run_mlr filter -v '     1 && 2 || 3'   /dev/null
run_mlr put    -v '$x = 1 && 2 ^^ 3'   /dev/null
run_mlr filter -v '     1 && 2 ^^ 3'   /dev/null

run_mlr put    -v '$x =  1 == 2 <= 3'  /dev/null
run_mlr filter -v '      1 == 2 <= 3'  /dev/null
run_mlr put    -v '$x =  1 <= 2 == 3'  /dev/null
run_mlr filter -v '      1 <= 2 == 3'  /dev/null

run_mlr put    -v '$x =  1 <= 2 |  3'  /dev/null
run_mlr filter -v '      1 <= 2 |  3'  /dev/null
run_mlr put    -v '$x =  1 |  2 <= 3'  /dev/null
run_mlr filter -v '      1 |  2 <= 3'  /dev/null

run_mlr put    -v '$x =  1 |  2 ^  3'  /dev/null
run_mlr filter -v '      1 |  2 ^  3'  /dev/null
run_mlr put    -v '$x =  1 ^  2 |  3'  /dev/null
run_mlr filter -v '      1 ^  2 |  3'  /dev/null

run_mlr put    -v '$x =  1 ^  2 &  3'  /dev/null
run_mlr filter -v '      1 ^  2 &  3'  /dev/null
run_mlr put    -v '$x =  1 &  2 ^  3'  /dev/null
run_mlr filter -v '      1 &  2 ^  3'  /dev/null

run_mlr put    -v '$x =  1 &  2 << 3'  /dev/null
run_mlr filter -v '      1 &  2 << 3'  /dev/null
run_mlr put    -v '$x =  1 << 2 &  3'  /dev/null
run_mlr filter -v '      1 << 2 &  3'  /dev/null

run_mlr put    -v '$x =  1 +  2 * 3'   /dev/null
run_mlr filter -v '      1 +  2 * 3'   /dev/null
run_mlr put    -v '$x =  1 *  2 + 3'   /dev/null
run_mlr filter -v '      1 *  2 + 3'   /dev/null
run_mlr put    -v '$x =  1 + (2 * 3)'  /dev/null
run_mlr filter -v '      1 + (2 * 3)'  /dev/null
run_mlr put    -v '$x =  1 * (2 + 3)'  /dev/null
run_mlr filter -v '      1 * (2 + 3)'  /dev/null
run_mlr put    -v '$x = (1 + 2) * 3'   /dev/null
run_mlr filter -v '     (1 + 2) * 3'   /dev/null
run_mlr put    -v '$x = (1 * 2) + 3'   /dev/null
run_mlr filter -v '     (1 * 2) + 3'   /dev/null

run_mlr put    -v '$x =  1 +   2 ** 3'  /dev/null
run_mlr filter -v '      1 +   2 ** 3'  /dev/null
run_mlr put    -v '$x =  1 **  2 +  3'  /dev/null
run_mlr filter -v '      1 **  2 +  3'  /dev/null
run_mlr put    -v '$x =  1 +  (2 ** 3)' /dev/null
run_mlr filter -v '      1 +  (2 ** 3)' /dev/null
run_mlr put    -v '$x =  1 ** (2 +  3)' /dev/null
run_mlr filter -v '      1 ** (2 +  3)' /dev/null
run_mlr put    -v '$x = (1 +  2) ** 3'  /dev/null
run_mlr filter -v '     (1 +  2) ** 3'  /dev/null
run_mlr put    -v '$x = (1 ** 2) +  3'  /dev/null
run_mlr filter -v '     (1 ** 2) +  3'  /dev/null

run_mlr put    -v '$x =  1 *   2 ** 3'  /dev/null
run_mlr filter -v '      1 *   2 ** 3'  /dev/null
run_mlr put    -v '$x =  1 **  2 *  3'  /dev/null
run_mlr filter -v '      1 **  2 *  3'  /dev/null
run_mlr put    -v '$x =  1 *  (2 ** 3)' /dev/null
run_mlr filter -v '      1 *  (2 ** 3)' /dev/null
run_mlr put    -v '$x =  1 ** (2 *  3)' /dev/null
run_mlr filter -v '      1 ** (2 *  3)' /dev/null
run_mlr put    -v '$x = (1 *  2) ** 3'  /dev/null
run_mlr filter -v '     (1 *  2) ** 3'  /dev/null
run_mlr put    -v '$x = (1 ** 2) *  3'  /dev/null
run_mlr filter -v '     (1 ** 2) *  3'  /dev/null

run_mlr put    -v '$x = -1 +  2 *  3'  /dev/null
run_mlr filter -v '     -1 +  2 *  3'  /dev/null
run_mlr put    -v '$x = -1 *  2 +  3'  /dev/null
run_mlr filter -v '     -1 *  2 +  3'  /dev/null
run_mlr put    -v '$x =  1 + -2 *  3'  /dev/null
run_mlr filter -v '      1 + -2 *  3'  /dev/null
run_mlr put    -v '$x =  1 * -2 +  3'  /dev/null
run_mlr filter -v '      1 * -2 +  3'  /dev/null
run_mlr put    -v '$x =  1 +  2 * -3'  /dev/null
run_mlr filter -v '      1 +  2 * -3'  /dev/null
run_mlr put    -v '$x =  1 *  2 + -3'  /dev/null
run_mlr filter -v '      1 *  2 + -3'  /dev/null

run_mlr put    -v '$x = ~1 |  2 &  3'  /dev/null
run_mlr filter -v '     ~1 |  2 &  3'  /dev/null
run_mlr put    -v '$x = ~1 &  2 |  3'  /dev/null
run_mlr filter -v '     ~1 &  2 |  3'  /dev/null
run_mlr put    -v '$x =  1 | ~2 &  3'  /dev/null
run_mlr filter -v '      1 | ~2 &  3'  /dev/null
run_mlr put    -v '$x =  1 & ~2 |  3'  /dev/null
run_mlr filter -v '      1 & ~2 |  3'  /dev/null
run_mlr put    -v '$x =  1 |  2 & ~3'  /dev/null
run_mlr filter -v '      1 |  2 & ~3'  /dev/null
run_mlr put    -v '$x =  1 &  2 | ~3'  /dev/null
run_mlr filter -v '      1 &  2 | ~3'  /dev/null

run_mlr put    -v '$x = $a==1 && $b == 1 && $c == 1' /dev/null
run_mlr filter -v '     $a==1 && $b == 1 && $c == 1' /dev/null
run_mlr put    -v '$x = $a==1 || $b == 1 && $c == 1' /dev/null
run_mlr filter -v '     $a==1 || $b == 1 && $c == 1' /dev/null
run_mlr put    -v '$x = $a==1 || $b == 1 || $c == 1' /dev/null
run_mlr filter -v '     $a==1 || $b == 1 || $c == 1' /dev/null
run_mlr put    -v '$x = $a==1 && $b == 1 || $c == 1' /dev/null
run_mlr filter -v '     $a==1 && $b == 1 || $c == 1' /dev/null

run_mlr put    -v '$x = $a==1 ? $b == 2 : $c == 3' /dev/null
run_mlr filter -v '     $a==1 ? $b == 2 : $c == 3' /dev/null

run_mlr put    -v '$x = true' /dev/null
run_mlr filter -v '     true' /dev/null

run_mlr put    -v 'true || 1==0; $x = 3' /dev/null
run_mlr filter -v '        true || 1==0' /dev/null

run_mlr put    -v '1==0 || false; $x = 3' /dev/null
run_mlr filter -v '        1==0 || false' /dev/null

run_mlr put    -v 'true && false; $x = 3' /dev/null
run_mlr filter -v '        true && false' /dev/null

run_mlr put    -v 'true && false && true; $x = 3' /dev/null
run_mlr filter -v '        true && false && true' /dev/null

run_mlr put    -v '$y += $x + 3'  /dev/null
run_mlr put    -v '$y += $x * 3'  /dev/null

run_mlr put -v '$y ||= $x' /dev/null
run_mlr put -v '$y ^^= $x' /dev/null
run_mlr put -v '$y &&= $x' /dev/null
run_mlr put -v '$y |=  $x' /dev/null
run_mlr put -v '$y ^=  $x' /dev/null
run_mlr put -v '$y &=  $x' /dev/null
run_mlr put -v '$y <<= $x' /dev/null
run_mlr put -v '$y >>= $x' /dev/null
run_mlr put -v '$y +=  $x' /dev/null
run_mlr put -v '$y -=  $x' /dev/null
run_mlr put -v '$y .=  $x' /dev/null
run_mlr put -v '$y *=  $x' /dev/null
run_mlr put -v '$y /=  $x' /dev/null
run_mlr put -v '$y //= $x' /dev/null
run_mlr put -v '$y %=  $x' /dev/null
run_mlr put -v '$y **= $x' /dev/null

# ----------------------------------------------------------------
announce DSL COMMENTS

run_mlr --from $indir/abixy put '
  $s = 1;
  #$t = 2;
  $u = 3;
'

run_mlr --from $indir/abixy filter '
  NR == 1 ||
  #NR == 2 ||
  NR == 3
'

run_mlr --from $indir/abixy put '
  $s = "here is a pound#sign"; # but this is a comment
  #$t = 2;
  $u = 3;
'

# ----------------------------------------------------------------
announce DSL EMPTY STATEMENTS

run_mlr -n put -v ''
mlr_expect_fail -n filter -v ''

run_mlr -n put -v 'begin {}'
run_mlr -n put -v 'begin {;}'
run_mlr -n put -v 'begin {;;}'
run_mlr -n put -v 'begin {;;;}'
run_mlr -n put -v 'begin {@x=1}'
run_mlr -n put -v 'begin {@x=1;}'
run_mlr -n put -v 'begin {;@x=1}'
run_mlr -n put -v 'begin {@x=1;@y=2}'
run_mlr -n put -v 'begin {@x=1;;@y=2}'

run_mlr -n put -v 'true {}'
run_mlr -n put -v 'true {;}'
run_mlr -n put -v 'true {;;}'
run_mlr -n put -v 'true {;;;}'
run_mlr -n put -v 'true {@x=1}'
run_mlr -n put -v 'true {@x=1;}'
run_mlr -n put -v 'true {;@x=1}'
run_mlr -n put -v 'true {@x=1;@y=2}'
run_mlr -n put -v 'true {@x=1;;@y=2}'

run_mlr -n put -v 'end {}'
run_mlr -n put -v 'end {;}'
run_mlr -n put -v 'end {;;}'
run_mlr -n put -v 'end {;;;}'
run_mlr -n put -v 'end {@x=1}'
run_mlr -n put -v 'end {@x=1;}'
run_mlr -n put -v 'end {;@x=1}'
run_mlr -n put -v 'end {@x=1;@y=2}'
run_mlr -n put -v 'end {@x=1;;@y=2}'

# ----------------------------------------------------------------
announce DSL CONTEXT-SPECIFIC VALIDATION

mention non-top-level begin/end
mlr_expect_fail put -v 'begin{begin{@x=1}}'
mlr_expect_fail put -v 'true{begin{@x=1}}'
mlr_expect_fail put -v 'end{end{@x=1}}'
mlr_expect_fail put -v 'true{end{@x=1}}'

mention srecs in begin/end
mlr_expect_fail put -v 'begin{$x=1}'
mlr_expect_fail put -v 'begin{@x=$y}'
mlr_expect_fail put -v 'end{$x=1}'
mlr_expect_fail put -v 'end{@x=$y}'
mlr_expect_fail put -v 'begin{@v=$*}'
mlr_expect_fail put -v 'end{$*=@v}'

mlr_expect_fail put -v 'begin{unset $x}'
mlr_expect_fail put -v 'end{unset $x}'
mlr_expect_fail put -v 'begin{unset $*}'
mlr_expect_fail put -v 'end{unset $*}'

mention break/continue outside loop
mlr_expect_fail put -v 'break'
mlr_expect_fail put -v 'continue'

mention oosvars etc. in mlr filter
mlr_expect_fail filter -v 'break'
mlr_expect_fail filter -v 'continue'

mention expanded filter

run_mlr --from $indir/abixy filter '
  begin {
    @avoid = 3
  }
  NR != @avoid
'

run_mlr --from $indir/abixy filter -x '
  begin {
    @avoid = 3
  }
  NR != @avoid
'

run_mlr --from $indir/abixy filter '
  func f(n) {
    return n - 1
  }
  f(NR) == 5
'

run_mlr --from $indir/abixy filter '
  subr s(n) {
    print "NR is ".n
  }
  call s(NR);
  false
'

run_mlr --from $indir/abixy filter '
  int a = 5;
  int b = 7;
  a <= NR && NR <= b
'

mlr_expect_fail --from $indir/abixy filter 'filter false'
mlr_expect_fail --from $indir/abixy filter 'filter false; true'

# ----------------------------------------------------------------
announce DSL FUNCTIONAL TESTS

run_mlr filter '$x>.3'    $indir/abixy
run_mlr filter '$x>.3;'   $indir/abixy
run_mlr filter '$x>0.3'   $indir/abixy
run_mlr filter '$x>0.3 && $y>0.3'   $indir/abixy
run_mlr filter '$x>0.3 || $y>0.3'   $indir/abixy
run_mlr filter 'NR>=4 && NR <= 7'   $indir/abixy

run_mlr filter -x '$x>.3'    $indir/abixy
run_mlr filter -x '$x>0.3'   $indir/abixy
run_mlr filter -x '$x>0.3 && $y>0.3'   $indir/abixy
run_mlr filter -x '$x>0.3 || $y>0.3'   $indir/abixy
run_mlr filter -x 'NR>=4 && NR <= 7'   $indir/abixy

run_mlr filter '$nosuchfield>.3'    $indir/abixy

run_mlr put '$x2 = $x**2'  $indir/abixy
run_mlr put '$x2 = $x**2;' $indir/abixy
run_mlr put '$z = -0.024*$x+0.13' $indir/abixy
run_mlr put '$c = $a . $b' $indir/abixy
run_mlr put '$ii = $i + $i' $indir/abixy
run_mlr put '$emptytest = $i + $nosuch' $indir/abixy

run_mlr --opprint put '$nr=NR;$fnr=FNR;$nf=NF;$filenum=FILENUM' $indir/abixy $indir/abixy

run_mlr --opprint put '$y=madd($x,10,37)' then put '$z=msub($x,10,37)' $indir/modarith.dat
run_mlr --opprint put '$y=mexp($x,35,37)' then put '$z=mmul($x,$y,37)' $indir/modarith.dat

run_mlr put '$z=min($x, $y)' $indir/minmax.dkvp
run_mlr put '$z=max($x, $y)' $indir/minmax.dkvp

echo 'x=1,y=2,z=3' | run_mlr put '$o=min()'
echo 'x=1,y=2,z=3' | run_mlr put '$o=max()'
echo 'x=1,y=2,z=3' | run_mlr put '$o=min($x)'
echo 'x=1,y=2,z=3' | run_mlr put '$o=max($x)'
echo 'x=1,y=2,z=3' | run_mlr put '$o=min($x,$y)'
echo 'x=1,y=2,z=3' | run_mlr put '$o=max($x,$y)'
echo 'x=1,y=2,z=3' | run_mlr put '$o=min($x,$y,$z)'
echo 'x=1,y=2,z=3' | run_mlr put '$o=max($x,$y,$z)'

echo 'x=1,y=b' | run_mlr put '$u=min($x,$y);$v=max($x,$y)'
echo 'x=a,y=2' | run_mlr put '$u=min($x,$y);$v=max($x,$y)'
echo 'x=a,y=b' | run_mlr put '$u=min($x,$y);$v=max($x,$y)'

run_mlr --icsvlite --oxtab put '${x+y} = ${name.x} + ${name.y}; ${x*y} = ${name.x} * ${name.y}' $indir/braced.csv
run_mlr --icsvlite --oxtab filter '${name.y} < ${z}' $indir/braced.csv

run_mlr --opprint put '$z = $x < 0.5 ? 0 : 1' $indir/abixy

run_mlr --csvlite filter 'true  && true'  $indir/b.csv
run_mlr --csvlite filter 'true  && false' $indir/b.csv
run_mlr --csvlite filter 'false && true'  $indir/b.csv
run_mlr --csvlite filter 'false && false' $indir/b.csv

run_mlr --csvlite filter 'true  || true'  $indir/b.csv
run_mlr --csvlite filter 'true  || false' $indir/b.csv
run_mlr --csvlite filter 'false || true'  $indir/b.csv
run_mlr --csvlite filter 'false || false' $indir/b.csv

run_mlr --csvlite filter 'true  ^^ true'  $indir/b.csv
run_mlr --csvlite filter 'true  ^^ false' $indir/b.csv
run_mlr --csvlite filter 'false ^^ true'  $indir/b.csv
run_mlr --csvlite filter 'false ^^ false' $indir/b.csv

# This tests boolean short-circuiting
run_mlr put '$x==2 && $a =~ "....." { $y=4 }'  $indir/short-circuit.dkvp

export X=97
export Y=98
run_mlr put '$x = ENV["X"]; $y = ENV[$name]' $indir/env-var.dkvp
export X=
export Y=
run_mlr put '$x = ENV["X"]; $y = ENV[$name]' $indir/env-var.dkvp

run_mlr -n put 'begin{ENV["HOME"]="foobar"} end{print ENV["HOME"]}'

echo 'x=hello' | run_mlr put '$y = toupper($x)'
echo 'x=HELLO' | run_mlr put '$y = toupper($x)'
echo 'x='      | run_mlr put '$y = toupper($x)'
echo 'x=hello' | run_mlr put '$y = toupper($z)'

echo 'x=hello' | run_mlr put '$y = tolower($x)'
echo 'x=HELLO' | run_mlr put '$y = tolower($x)'
echo 'x='      | run_mlr put '$y = tolower($x)'
echo 'x=hello' | run_mlr put '$y = tolower($z)'

echo 'x=hello' | run_mlr put '$y = capitalize($x)'
echo 'x=HELLO' | run_mlr put '$y = capitalize($x)'
echo 'x='      | run_mlr put '$y = capitalize($x)'
echo 'x=hello' | run_mlr put '$y = capitalize($z)'

mention LHS value on first record should result in ZYX for process creation
export indir; run_mlr --from $indir/abixy put -q 'ENV["ZYX"]="CBA".NR; print | ENV["indir"]."/env-assign.sh" , "a is " . $a'

# ----------------------------------------------------------------
announce POSITIONAL INDEXING

run_mlr --opprint put '$NEW = $[[3]]'     $indir/abixy
run_mlr --opprint put '$NEW = $[[[3]]]'   $indir/abixy

run_mlr --opprint put '$NEW = $[[11]]'    $indir/abixy
run_mlr --opprint put '$NEW = $[[[11]]]'  $indir/abixy

run_mlr --opprint put '$[[3]]   = "NEW"'  $indir/abixy
run_mlr --opprint put '$[[[3]]] = "NEW"'  $indir/abixy

run_mlr --opprint put '$[[11]]   = "NEW"' $indir/abixy
run_mlr --opprint put '$[[[11]]] = "NEW"' $indir/abixy

run_mlr --opprint put '$[[1]] = $[[2]]' $indir/abixy

run_mlr --opprint put '$a     = $[[2]]; unset $["a"]' $indir/abixy
run_mlr --opprint put '$[[1]] = $b;     unset $[[1]]' $indir/abixy
run_mlr --opprint put '$[[1]] = $[[2]]; unset $["a"]' $indir/abixy

# xxx to do -- there is an old bug here with lack of lhmsmv_unset on the typed overlay at unset
run_mlr --opprint put 'unset $c' $indir/abixy
run_mlr --opprint put 'unset $c; $c="new"' $indir/abixy
run_mlr --opprint put '$c=$a.$b; unset $c; $c="new"' $indir/abixy
run_mlr --opprint put '$c=$a.$b; unset $c' $indir/abixy

# ----------------------------------------------------------------
announce IS-PREDICATES

run_mlr --opprint put '$f=is_absent($x)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_absent($y)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_absent($z)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_absent($nosuch)'                     $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_absent(@nosuch)'                     $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_absent(@somesuch)'       $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_bool($x>1)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_bool($y>1)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_bool($z>1)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_bool($nosuch>1)'                     $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_bool(@nosuch>1)'                     $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_bool(@somesuch>1)'       $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_boolean($x>1)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_boolean($y>1)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_boolean($z>1)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_boolean($nosuch>1)'                  $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_boolean(@nosuch>1)'                  $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_boolean(@somesuch>1)'    $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_empty($x)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty($y)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty($z)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty($nosuch)'                      $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty(@nosuch)'                      $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty($*)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty({1:2})'                        $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_empty(@somesuch)'        $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_empty_map($x)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty_map($y)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty_map($z)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty_map($nosuch)'                  $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty_map(@nosuch)'                  $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty_map($*)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty_map({1:2})'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_empty_map({})'                       $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_empty_map(@somesuch)'    $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_float($x)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_float($y)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_float($z)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_float($nosuch)'                      $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_float(@nosuch)'                      $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_float($*)'                           $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_float({1:2})'                        $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_float(@somesuch)'        $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_int($x)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_int($y)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_int($z)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_int($nosuch)'                        $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_int(@nosuch)'                        $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_int($*)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_int({1:2})'                          $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_int(@somesuch)'          $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_map($x)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_map($y)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_map($z)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_map($nosuch)'                        $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_map(@nosuch)'                        $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_map($*)'                             $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_map({1:2})'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_map({})'                             $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_map(@somesuch)'          $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_nonempty_map($x)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_nonempty_map($y)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_nonempty_map($z)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_nonempty_map($nosuch)'               $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_nonempty_map(@nosuch)'               $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_nonempty_map($*)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_nonempty_map({1:2})'                 $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_nonempty_map({})'                    $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_nonempty_map(@somesuch)' $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_not_empty($x)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_empty($y)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_empty($z)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_empty($nosuch)'                  $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_empty(@nosuch)'                  $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_empty($*)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_empty({1:2})'                    $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_not_empty(@somesuch)'    $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_not_map($x)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_map($y)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_map($z)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_map($nosuch)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_map(@nosuch)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_map($*)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_map({1:2})'                      $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_map({})'                         $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_not_map(@somesuch)'      $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_not_null($x)'                        $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_null($y)'                        $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_null($z)'                        $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_null($nosuch)'                   $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_not_null(@nosuch)'                   $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_not_null(@somesuch)'     $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_null($x)'                            $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_null($y)'                            $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_null($z)'                            $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_null($nosuch)'                       $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_null(@nosuch)'                       $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_null(@somesuch)'         $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_numeric($x)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_numeric($y)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_numeric($z)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_numeric($nosuch)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_numeric(@nosuch)'                    $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_numeric(@somesuch)'      $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_present($x)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_present($y)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_present($z)'                         $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_present($nosuch)'                    $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_present(@nosuch)'                    $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_present(@somesuch)'      $indir/nullvals.dkvp

run_mlr --opprint put '$f=is_string($x)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_string($y)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_string($z)'                          $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_string($nosuch)'                     $indir/nullvals.dkvp
run_mlr --opprint put '$f=is_string(@nosuch)'                     $indir/nullvals.dkvp
run_mlr --opprint put '@somesuch=1;$f=is_string(@somesuch)'       $indir/nullvals.dkvp

# ----------------------------------------------------------------
announce ASSERTION PASS-THROUGHS

run_mlr         --opprint put '$f=asserting_absent($nosuch)'                     $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_absent(@nosuch)'                     $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_absent($x)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_absent($y)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_absent($z)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put '@somesuch=1;$f=asserting_absent(@somesuch)'       $indir/nullvals.dkvp
mlr_expect_fail --opprint put 'foo=asserting_absent($*)'                         $indir/nullvals.dkvp
mlr_expect_fail --opprint put 'foo=asserting_absent({1:2})'                      $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_empty($z)'                           $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty($x)'                           $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty($y)'                           $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty($nosuch)'                      $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty(@nosuch)'                      $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty({1:2})'                        $indir/nullvals.dkvp
mlr_expect_fail --opprint put '@somesuch=1;$f=asserting_empty(@somesuch)'        $indir/nullvals.dkvp
mlr_expect_fail --opprint put 'foo=asserting_empty($*)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put 'foo=asserting_empty({1:2})'                       $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_empty_map({})'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty_map($*)'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty_map($x)'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty_map($y)'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty_map($z)'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty_map($nosuch)'                  $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty_map(@nosuch)'                  $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_empty_map({1:2})'                    $indir/nullvals.dkvp
mlr_expect_fail --opprint put '@somesuch=1;$f=asserting_empty_map(@somesuch)'    $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_map($*)'                             $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_map({1:2})'                          $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_map({})'                             $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_map($x)'                             $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_map($y)'                             $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_map($z)'                             $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_map($nosuch)'                        $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_map(@nosuch)'                        $indir/nullvals.dkvp
mlr_expect_fail --opprint put '@somesuch=1;$f=asserting_map(@somesuch)'          $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_nonempty_map($*)'                    $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_nonempty_map({1:2})'                 $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_nonempty_map($x)'                    $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_nonempty_map($y)'                    $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_nonempty_map($z)'                    $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_nonempty_map($nosuch)'               $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_nonempty_map(@nosuch)'               $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_nonempty_map({})'                    $indir/nullvals.dkvp
mlr_expect_fail --opprint put '@somesuch=1;$f=asserting_nonempty_map(@somesuch)' $indir/nullvals.dkvp

run_mlr         --opprint put '$*=asserting_not_empty($*)'                       $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_not_empty($nosuch)'                  $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_not_empty(@nosuch)'                  $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_not_empty({1:2})'                    $indir/nullvals.dkvp
run_mlr         --opprint put '$nosuch=asserting_not_empty($nosuch)'             $indir/nullvals.dkvp
run_mlr         --opprint put '@somesuch=1;$f=asserting_not_empty(@somesuch)'    $indir/nullvals.dkvp
run_mlr         --opprint put '$*=asserting_not_empty($*)'                       $indir/nullvals.dkvp
run_mlr         --opprint put '$*=asserting_not_empty({1:2})'                    $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_empty($x)'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_empty($y)'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_empty($z)'                       $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_not_map($x)'                         $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_not_map($y)'                         $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_not_map($z)'                         $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_not_map($nosuch)'                    $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_not_map(@nosuch)'                    $indir/nullvals.dkvp
run_mlr         --opprint put '@somesuch=1;$f=asserting_not_map(@somesuch)'      $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_map($*)'                         $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_map({1:2})'                      $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_map({})'                         $indir/nullvals.dkvp

run_mlr         --opprint put '@somesuch=1;$f=asserting_not_null(@somesuch)'     $indir/nullvals.dkvp
run_mlr         --opprint put '$*=asserting_not_null($*)'                        $indir/nullvals.dkvp
run_mlr         --opprint put '$*=asserting_not_null({1:2})'                     $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_null($x)'                        $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_null($y)'                        $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_null($z)'                        $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_null($nosuch)'                   $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_not_null(@nosuch)'                   $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_null($z)'                            $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_null($nosuch)'                       $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_null(@nosuch)'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_null($x)'                            $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_null($y)'                            $indir/nullvals.dkvp
mlr_expect_fail --opprint put '@somesuch=1;$f=asserting_null(@somesuch)'         $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$*=asserting_null($*)'                            $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$*=asserting_null({1:2})'                         $indir/nullvals.dkvp

mlr_expect_fail --opprint put '$f=asserting_numeric($x)'                         $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_numeric($y)'                         $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_numeric($z)'                         $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$*=asserting_numeric($*)'                         $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$*=asserting_numeric({1:2})'                      $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_numeric($nosuch)'                    $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_present($x)'                         $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_present($y)'                         $indir/nullvals.dkvp
run_mlr         --opprint put '$f=asserting_present($z)'                         $indir/nullvals.dkvp
run_mlr         --opprint put '@somesuch=1;$f=asserting_present(@somesuch)'      $indir/nullvals.dkvp
run_mlr         --opprint put '$*=asserting_present($*)'                         $indir/nullvals.dkvp
run_mlr         --opprint put '$*=asserting_present({1:2})'                      $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_present($nosuch)'                    $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_present(@nosuch)'                    $indir/nullvals.dkvp

run_mlr         --opprint put '$f=asserting_string($z)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$*=asserting_string($*)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$*=asserting_string({1:2})'                       $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_string($x)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_string($y)'                          $indir/nullvals.dkvp
mlr_expect_fail --opprint put '$f=asserting_string($nosuch)'                     $indir/nullvals.dkvp

# ----------------------------------------------------------------
announce DSL NULL/EMPTY HANDLING

run_mlr put '$z = $s . $s'     $indir/null-vs-empty.dkvp
run_mlr put '$z = $s == ""'    $indir/null-vs-empty.dkvp
run_mlr put '$z = $s == $s'    $indir/null-vs-empty.dkvp
run_mlr put '$z = is_empty($s)' $indir/null-vs-empty.dkvp

run_mlr put '$z = $x + $y'      $indir/null-vs-empty.dkvp
run_mlr put '$z = $y + $y'      $indir/null-vs-empty.dkvp
run_mlr put '$z = $x + $nosuch' $indir/null-vs-empty.dkvp
run_mlr put '$t = sub($s,       "ell", "X")' $indir/null-vs-empty.dkvp
run_mlr put '$t = sub($s,       "ell", "")'  $indir/null-vs-empty.dkvp
run_mlr put '$t = sub($nosuch,  "ell", "X")' $indir/null-vs-empty.dkvp
run_mlr put '$t = gsub($s,      "l",   "X")' $indir/null-vs-empty.dkvp
run_mlr put '$t = gsub($s,      "l",   "")'  $indir/null-vs-empty.dkvp
run_mlr put '$t = gsub($nosuch, "l",   "X")' $indir/null-vs-empty.dkvp

mention EMIT
run_mlr put -q '@v=1; @nonesuch       {emit @v}' $indir/abixy
run_mlr put -q '@v=1; @nonesuch==true {emit @v}' $indir/abixy
run_mlr put -q '@v=1; $nonesuch       {emit @v}' $indir/abixy
run_mlr put -q '@v=1; $nonesuch==true {emit @v}' $indir/abixy

mention PLUS
run_mlr --ofs tab put 'begin{};          $xy = $x + $y; $sy = @s + $y; $xt = $x + @t; $st = @s + @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x + $y; $sy = @s + $y; $xt = $x + @t; $st = @s + @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x + $y; $sy = @s + $y; $xt = $x + @t; $st = @s + @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x + $y; $sy = @s + $y; $xt = $x + @t; $st = @s + @t' $indir/typeof.dkvp

mention MINUS
run_mlr --ofs tab put 'begin{};          $xy = $x - $y; $sy = @s - $y; $xt = $x - @t; $st = @s - @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x - $y; $sy = @s - $y; $xt = $x - @t; $st = @s - @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x - $y; $sy = @s - $y; $xt = $x - @t; $st = @s - @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x - $y; $sy = @s - $y; $xt = $x - @t; $st = @s - @t' $indir/typeof.dkvp

mention TIMES
run_mlr --ofs tab put 'begin{};          $xy = $x * $y; $sy = @s * $y; $xt = $x * @t; $st = @s * @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x * $y; $sy = @s * $y; $xt = $x * @t; $st = @s * @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x * $y; $sy = @s * $y; $xt = $x * @t; $st = @s * @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x * $y; $sy = @s * $y; $xt = $x * @t; $st = @s * @t' $indir/typeof.dkvp

mention DIVIDE
run_mlr --ofs tab put 'begin{};          $xy = $x / $y; $sy = @s / $y; $xt = $x / @t; $st = @s / @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x / $y; $sy = @s / $y; $xt = $x / @t; $st = @s / @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x / $y; $sy = @s / $y; $xt = $x / @t; $st = @s / @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x / $y; $sy = @s / $y; $xt = $x / @t; $st = @s / @t' $indir/typeof.dkvp

mention INTEGER DIVIDE
run_mlr --ofs tab put 'begin{};          $xy = $x // $y; $sy = @s // $y; $xt = $x // @t; $st = @s // @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x // $y; $sy = @s // $y; $xt = $x // @t; $st = @s // @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x // $y; $sy = @s // $y; $xt = $x // @t; $st = @s // @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x // $y; $sy = @s // $y; $xt = $x // @t; $st = @s // @t' $indir/typeof.dkvp

mention REMAINDER
run_mlr --ofs tab put 'begin{};          $xy = $x % $y; $sy = @s % $y; $xt = $x % @t; $st = @s % @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x % $y; $sy = @s % $y; $xt = $x % @t; $st = @s % @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x % $y; $sy = @s % $y; $xt = $x % @t; $st = @s % @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x % $y; $sy = @s % $y; $xt = $x % @t; $st = @s % @t' $indir/typeof.dkvp

mention BITWISE AND
run_mlr --ofs tab put 'begin{};          $xy = $x & $y; $sy = @s & $y; $xt = $x & @t; $st = @s & @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x & $y; $sy = @s & $y; $xt = $x & @t; $st = @s & @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x & $y; $sy = @s & $y; $xt = $x & @t; $st = @s & @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x & $y; $sy = @s & $y; $xt = $x & @t; $st = @s & @t' $indir/typeof.dkvp

mention BITWISE OR
run_mlr --ofs tab put 'begin{};          $xy = $x | $y; $sy = @s | $y; $xt = $x | @t; $st = @s | @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x | $y; $sy = @s | $y; $xt = $x | @t; $st = @s | @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x | $y; $sy = @s | $y; $xt = $x | @t; $st = @s | @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x | $y; $sy = @s | $y; $xt = $x | @t; $st = @s | @t' $indir/typeof.dkvp

mention BITWISE XOR
run_mlr --ofs tab put 'begin{};          $xy = $x ^ $y; $sy = @s ^ $y; $xt = $x ^ @t; $st = @s ^ @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3};      $xy = $x ^ $y; $sy = @s ^ $y; $xt = $x ^ @t; $st = @s ^ @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@t=4};      $xy = $x ^ $y; $sy = @s ^ $y; $xt = $x ^ @t; $st = @s ^ @t' $indir/typeof.dkvp
run_mlr --ofs tab put 'begin{@s=3;@t=4}; $xy = $x ^ $y; $sy = @s ^ $y; $xt = $x ^ @t; $st = @s ^ @t' $indir/typeof.dkvp

# ----------------------------------------------------------------
announce DSL TYPE PREDICATES

run_mlr --from $indir/abixy --opprint put ' for (k, v in $*) { $[k."_type"]      = typeof(v)     } '

run_mlr --from $indir/abixy-het put -q 'for (k,v in $*) {if (is_float(v))    {@float[NR][k]   = v}}    end{ emit @float,   "NR", "k" }'
run_mlr --from $indir/abixy-het put -q 'for (k,v in $*) {if (is_int(v))      {@int[NR][k]     = v}}    end{ emit @int,     "NR", "k" }'
run_mlr --from $indir/abixy-het put -q 'for (k,v in $*) {if (is_numeric(v))  {@numeric[NR][k] = v}}    end{ emit @numeric, "NR", "k" }'
run_mlr --from $indir/abixy-het put -q 'for (k,v in $*) {if (is_string(v))   {@string[NR][k]  = v}}    end{ emit @string,  "NR", "k" }'
run_mlr --from $indir/abixy-het put -q 'for (k,v in $*) {if (is_bool(v))     {@bool[NR][k]    = v}}    end{ emit @bool,    "NR", "k" }'
run_mlr --from $indir/abixy-het put -q 'for (k,v in $*) {if (is_bool(NR==2)) {@bool[NR][k]    = "NR==2"}} end{ emit @bool,    "NR", "k" }'

# ----------------------------------------------------------------
announce DSL TYPE-INFERENCE

run_mlr --xtab put       '$y     = $pi1 + $pi2' $indir/mixed-types.xtab
run_mlr --xtab put    -F '$y     = $pi1 + $pi2' $indir/mixed-types.xtab
run_mlr --xtab put    -S '$y     = $pi1 . $pi2' $indir/mixed-types.xtab
run_mlr --xtab filter    '999   != $pi1 + $pi2' $indir/mixed-types.xtab
run_mlr --xtab filter -F '999   != $pi1 + $pi2' $indir/mixed-types.xtab
run_mlr --xtab filter -S '"999" != $pi1 . $pi2' $indir/mixed-types.xtab

echo a=1,b=2.0 | run_mlr --oxtab put    '$s = $a; $t = $b; $u = 3; $v = 4.0; $ts=typeof($s); $tt=typeof($t); $tu=typeof($u); $tv=typeof($v);'
echo a=1,b=2.0 | run_mlr --oxtab put -F '$s = $a; $t = $b; $u = 3; $v = 4.0; $ts=typeof($s); $tt=typeof($t); $tu=typeof($u); $tv=typeof($v);'
echo a=1,b=2.0 | run_mlr --oxtab put -S '$s = $a; $t = $b; $u = 3; $v = 4.0; $ts=typeof($s); $tt=typeof($t); $tu=typeof($u); $tv=typeof($v);'

run_mlr --xtab put    '$y=abs($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=abs($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=abs($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put    '$y=abs($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=abs($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=abs($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put -F '$y=abs($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=abs($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=abs($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=abs($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=abs($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=abs($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put    '$y=ceil($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=ceil($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=ceil($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put    '$y=ceil($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=ceil($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=ceil($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put -F '$y=floor($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=floor($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=floor($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=floor($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=floor($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=floor($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put    '$y=round($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=round($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=round($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put    '$y=round($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=round($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=round($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put -F '$y=round($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=round($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=round($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=round($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=round($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=round($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put    '$y=sgn($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=sgn($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=sgn($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put    '$y=sgn($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=sgn($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put    '$y=sgn($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put -F '$y=sgn($pf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=sgn($nf1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=sgn($zf)'  $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=sgn($pi1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=sgn($ni1)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$y=sgn($zi)'  $indir/mixed-types.xtab

run_mlr --xtab put    '$min=min($pf1,$pf2);$max=max($pf1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put    '$min=min($pf1,$pi2);$max=max($pf1,$pi2)' $indir/mixed-types.xtab
run_mlr --xtab put    '$min=min($pi1,$pf2);$max=max($pi1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put    '$min=min($pi1,$pi2);$max=max($pi1,$pi2)' $indir/mixed-types.xtab

run_mlr --xtab put -F '$min=min($pf1,$pf2);$max=max($pf1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$min=min($pf1,$pi2);$max=max($pf1,$pi2)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$min=min($pi1,$pf2);$max=max($pi1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$min=min($pi1,$pi2);$max=max($pi1,$pi2)' $indir/mixed-types.xtab

run_mlr --xtab put    '$min=min($pf1,$pf2);$max=max($pf1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put    '$min=min($pf1,$pi2);$max=max($pf1,$pi2)' $indir/mixed-types.xtab
run_mlr --xtab put    '$min=min($pi1,$pf2);$max=max($pi1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put    '$min=min($pi1,$pi2);$max=max($pi1,$pi2)' $indir/mixed-types.xtab

run_mlr --xtab put -F '$min=min($pf1,$pf2);$max=max($pf1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$min=min($pf1,$pi2);$max=max($pf1,$pi2)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$min=min($pi1,$pf2);$max=max($pi1,$pf2)' $indir/mixed-types.xtab
run_mlr --xtab put -F '$min=min($pi1,$pi2);$max=max($pi1,$pi2)' $indir/mixed-types.xtab

run_mlr --xtab put    '$sum=$pf1+$pf2;$diff=$pf1-$pf2' $indir/mixed-types.xtab
run_mlr --xtab put    '$sum=$pf1+$pi2;$diff=$pf1-$pi2' $indir/mixed-types.xtab
run_mlr --xtab put    '$sum=$pi1+$pf2;$diff=$pi1-$pf2' $indir/mixed-types.xtab
run_mlr --xtab put    '$sum=$pi1+$pi2;$diff=$pi1-$pi2' $indir/mixed-types.xtab

run_mlr --xtab put -F '$sum=$pf1+$pf2;$diff=$pf1-$pf2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$sum=$pf1+$pi2;$diff=$pf1-$pi2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$sum=$pi1+$pf2;$diff=$pi1-$pf2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$sum=$pi1+$pi2;$diff=$pi1-$pi2' $indir/mixed-types.xtab

run_mlr --xtab put    '$prod=$pf1*$pf2;$quot=$pf1/$pf2' $indir/mixed-types.xtab
run_mlr --xtab put    '$prod=$pf1*$pi2;$quot=$pf1/$pi2' $indir/mixed-types.xtab
run_mlr --xtab put    '$prod=$pi1*$pf2;$quot=$pi1/$pf2' $indir/mixed-types.xtab
run_mlr --xtab put    '$prod=$pi1*$pi2;$quot=$pi1/$pi2' $indir/mixed-types.xtab

run_mlr --xtab put -F '$prod=$pf1*$pf2;$quot=$pf1/$pf2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$prod=$pf1*$pi2;$quot=$pf1/$pi2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$prod=$pi1*$pf2;$quot=$pi1/$pf2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$prod=$pi1*$pi2;$quot=$pi1/$pi2' $indir/mixed-types.xtab

run_mlr --xtab put    '$iquot=$pf1//$pf2;$mod=$pf1%$pf2' $indir/mixed-types.xtab
run_mlr --xtab put    '$iquot=$pf1//$pi2;$mod=$pf1%$pi2' $indir/mixed-types.xtab
run_mlr --xtab put    '$iquot=$pi1//$pf2;$mod=$pi1%$pf2' $indir/mixed-types.xtab
run_mlr --xtab put    '$iquot=$pi1//$pi2;$mod=$pi1%$pi2' $indir/mixed-types.xtab

run_mlr --xtab put -F '$iquot=$pf1//$pf2;$mod=$pf1%$pf2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$iquot=$pf1//$pi2;$mod=$pf1%$pi2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$iquot=$pi1//$pf2;$mod=$pi1%$pf2' $indir/mixed-types.xtab
run_mlr --xtab put -F '$iquot=$pi1//$pi2;$mod=$pi1%$pi2' $indir/mixed-types.xtab

run_mlr --xtab put    '$a=roundm($pf1,10.0);$b=roundm($pf1,-10.0)' $indir/mixed-types.xtab
run_mlr --xtab put    '$a=roundm($pf1,10)  ;$b=roundm($pf1,-10)  ' $indir/mixed-types.xtab
run_mlr --xtab put    '$a=roundm($pi1,10.0);$b=roundm($pi1,-10.0)' $indir/mixed-types.xtab
run_mlr --xtab put    '$a=roundm($pi1,10)  ;$b=roundm($pi1,-10)  ' $indir/mixed-types.xtab

echo 'x=3,y=4' | run_mlr --oxtab put '$z=$x+$y; $a=3+4; $b="3"."4"; $c="3"+4'

# ----------------------------------------------------------------
announce DSL SCIENTIFIC NOTATION IN FIELD VALUES

run_mlr --opprint put '$y=$x+1' $indir/scinot.dkvp

# ----------------------------------------------------------------
announce DSL SCIENTIFIC NOTATION IN EXPRESSION LITERALS

run_mlr --opprint put '$y = 123     + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 123.    + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 123.4   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = .234    + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 1e2     + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 1e-2    + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 1.2e3   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 1.e3    + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 1.2e-3  + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 1.e-3   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = .2e3    + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = .2e-3   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = 1.e-3   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -123    + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -123.   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -123.4  + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -.234   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -1e2    + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -1e-2   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -1.2e3  + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -1.e3   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -1.2e-3 + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -1.e-3  + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -.2e3   + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -.2e-3  + $i' $indir/scinot1.dkvp
run_mlr --opprint put '$y = -1.e-3  + $i' $indir/scinot1.dkvp

# ----------------------------------------------------------------
announce DSL FROM-FILE FEATURE

run_mlr put    -f $indir/put-example.dsl $indir/abixy
run_mlr filter -f $indir/filter-example.dsl $indir/abixy

run_mlr --from $indir/abixy put    -f $indir/put-example.dsl
run_mlr --from $indir/abixy filter -f $indir/filter-example.dsl

run_mlr --from $indir/abixy --from $indir/abixy-het put    -f $indir/put-example.dsl
run_mlr --from $indir/abixy --from $indir/abixy-het filter -f $indir/filter-example.dsl

# ----------------------------------------------------------------
announce DSL MULTI-PART SCRIPTS

run_mlr --opprint --from $indir/abixy put -f $indir/put-script-piece-1
run_mlr --opprint --from $indir/abixy put -f $indir/put-script-piece-1 -f $indir/put-script-piece-2
run_mlr --opprint --from $indir/abixy put -f $indir/put-script-piece-1 -f $indir/put-script-piece-2 -f $indir/put-script-piece-3

run_mlr --opprint --from $indir/abixy put -e '$xy = $x**2 + $y**2'
run_mlr --opprint --from $indir/abixy filter -e 'NR == 7'

run_mlr --opprint --from $indir/abixy put -e 'print "PRE";' -f $indir/put-script-piece-1 -f $indir/put-script-piece-2 -f $indir/put-script-piece-3 -e 'print "POST"'

run_mlr --opprint --from $indir/abixy filter -f $indir/filter-script-piece-1
run_mlr --opprint --from $indir/abixy filter -f $indir/filter-script-piece-1 -f $indir/filter-script-piece-2

# ----------------------------------------------------------------
announce UTF-8 STRLEN

run_mlr --inidx --ifs comma --oxtab put '$s1=strlen($1);$s2=strlen($2);$s3=strlen($3);$s4=strlen($4)' $indir/utf8-align.dkvp

# ----------------------------------------------------------------
announce TRUNCATE

for n in 0 1 2 3 4 5; do
    echo "x=abcd" | run_mlr put '$y=truncate($x, '$n')'
done
for n in 0 1 2 3 4 5; do
    echo "x=abcdefgh" | run_mlr put '$y=truncate($x, '$n')'
done

# ----------------------------------------------------------------
announce STATS1/STEP INT/FLOAT

run_mlr --opprint step      -a rsum,delta,counter  -f x,y,z $indir/int-float.dkvp
run_mlr --opprint step   -F -a rsum,delta,counter  -f x,y,z $indir/int-float.dkvp
run_mlr --oxtab   stats1    -a min,max,sum,count   -f x,y,z $indir/int-float.dkvp
run_mlr --oxtab   stats1 -F -a min,max,sum,count   -f x,y,z $indir/int-float.dkvp

# ----------------------------------------------------------------
announce DSL PYTHONIC DIVISION

run_mlr --xtab put    '$quot=$pf1/10.0;$iquot=$pf1//10.0;$mod=$pf1%10.0' $indir/mixed-types.xtab
run_mlr --xtab put    '$quot=$pi1/10  ;$iquot=$pi1//10  ;$mod=$pi1%10  ' $indir/mixed-types.xtab
run_mlr --xtab put    '$quot=$nf1/10.0;$iquot=$nf1//10.0;$mod=$nf1%10.0' $indir/mixed-types.xtab
run_mlr --xtab put    '$quot=$ni1/10  ;$iquot=$ni1//10  ;$mod=$ni1%10  ' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$pf1/10.0;$iquot=$pf1//10.0;$mod=$pf1%10.0' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$pi1/10  ;$iquot=$pi1//10  ;$mod=$pi1%10  ' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$nf1/10.0;$iquot=$nf1//10.0;$mod=$nf1%10.0' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$ni1/10  ;$iquot=$ni1//10  ;$mod=$ni1%10  ' $indir/mixed-types.xtab

run_mlr --xtab put    '$quot=$pf1/-10.0;$iquot=$pf1//-10.0;$mod=$pf1%-10.0' $indir/mixed-types.xtab
run_mlr --xtab put    '$quot=$pi1/-10  ;$iquot=$pi1//-10  ;$mod=$pi1%-10  ' $indir/mixed-types.xtab
run_mlr --xtab put    '$quot=$nf1/-10.0;$iquot=$nf1//-10.0;$mod=$nf1%-10.0' $indir/mixed-types.xtab
run_mlr --xtab put    '$quot=$ni1/-10  ;$iquot=$ni1//-10  ;$mod=$ni1%-10  ' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$pf1/-10.0;$iquot=$pf1//-10.0;$mod=$pf1%-10.0' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$pi1/-10  ;$iquot=$pi1//-10  ;$mod=$pi1%-10  ' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$nf1/-10.0;$iquot=$nf1//-10.0;$mod=$nf1%-10.0' $indir/mixed-types.xtab
run_mlr --xtab put -F '$quot=$ni1/-10  ;$iquot=$ni1//-10  ;$mod=$ni1%-10  ' $indir/mixed-types.xtab

# ----------------------------------------------------------------
announce DSL REGEX MATCHING

run_mlr filter -v '$x =~ "bcd"'       $indir/regex.dkvp
run_mlr filter -v '$x =~ "^bcd"'      $indir/regex.dkvp
run_mlr filter -v '$x =~ "^abc"'      $indir/regex.dkvp
run_mlr filter -v '$x =~ "^abc$"'     $indir/regex.dkvp
run_mlr filter -v '$x =~ "^a.*d$"'    $indir/regex.dkvp
run_mlr filter -v '$x =~ "^a.*"."d$"' $indir/regex.dkvp
run_mlr filter -v '$y =~ "\".."'      $indir/regex.dkvp

run_mlr filter -v '$x =~ "bcd"i'       $indir/regex.dkvp
run_mlr filter -v '$x =~ "^bcd"i'      $indir/regex.dkvp
run_mlr filter -v '$x =~ "^abc"i'      $indir/regex.dkvp
run_mlr filter -v '$x =~ "^abc$"i'     $indir/regex.dkvp
run_mlr filter -v '$x =~ "^a.*d$"i'    $indir/regex.dkvp
run_mlr filter -v '$x =~ "^a.*"."d$"i' $indir/regex.dkvp

run_mlr --csv filter '$text =~ "."'    $indir/dot-match.csv
run_mlr --csv filter '$text =~ "\."'   $indir/dot-match.csv

# ----------------------------------------------------------------
announce DSL TYPED OVERLAY

run_mlr put '$y = string($x); $z=$y.$y' $indir/int-float.dkvp
run_mlr put '$z=string($x).string($x)' $indir/int-float.dkvp
run_mlr put '$y = string($x)' then put '$z=$y.$y' $indir/int-float.dkvp
run_mlr put '$a="hello"' then put '$b=$a." world";$z=$x+$y;$c=$b;$a=sub($b,"hello","farewell")' $indir/int-float.dkvp

# ----------------------------------------------------------------
announce DSL REGEX CAPTURES

# cat reg_test/input/capture.dkvp
# FIELD=ABC123
# FIELD=ABC..123
# FIELD=..ABC..123..
# FIELD=none of the above

run_mlr --opprint put '$FIELD =~ "([A-Z]+)([0-9]+)";         $F1="\1"; $F2="\2"; $F3="\3"' $indir/capture.dkvp
run_mlr --opprint put '$FIELD =~ "([A-Z]+)[^0-9]*([0-9]+)";  $F1="\1"; $F2="\2"; $F3="\3"' $indir/capture.dkvp

run_mlr --opprint put '$FIELD =~ "([A-Z]+)([0-9]+)"'         then put '$F1="\1"; $F2="\2"; $F3="\3"' $indir/capture.dkvp
run_mlr --opprint put '$FIELD =~ "([A-Z]+)[^0-9]*([0-9]+)"'  then put '$F1="\1"; $F2="\2"; $F3="\3"' $indir/capture.dkvp

# cat reg_test/input/capture-lengths.dkvp
# FIELD=
# FIELD=a
# FIELD=ab
# FIELD=abc
# FIELD=abcd
# FIELD=abcde
# FIELD=abcdef
# FIELD=abcdefg
# FIELD=abcdefgh
# FIELD=abcdefghi
# FIELD=abcdefghij
# FIELD=abcdefghijk
# FIELD=abcdefghijkl

run_mlr --opprint put '       $FIELD =~ "....."; $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"'  $indir/capture-lengths.dkvp
run_mlr --opprint put '       $FIELD =~ "....." {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "....."; $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"'  $indir/capture-lengths.dkvp

run_mlr --opprint put '$FIELD =~ "(.)";                            $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)";                         $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)";                      $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)";                   $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)";                $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)";             $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)";          $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)";       $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)(.)";    $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)"; $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp

run_mlr --opprint put '$FIELD =~ "(.)"                            {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)"                         {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)"                      {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)"                   {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)"                {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)"             {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)"          {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)"       {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)(.)"    {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp
run_mlr --opprint put '$FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)" {$F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"}' $indir/capture-lengths.dkvp

run_mlr --opprint put 'filter $FIELD =~ "(.)";                            $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)";                         $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)";                      $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)(.)";                   $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)(.)(.)";                $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)(.)(.)(.)";             $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)(.)(.)(.)(.)";          $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)";       $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)(.)";    $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp
run_mlr --opprint put 'filter $FIELD =~ "(.)(.)(.)(.)(.)(.)(.)(.)(.)(.)"; $F0="\0";$F1="\1";$F2="\2";$F3="\3";$F4="\4";$F5="\5";$F6="\6";$F7="\7";$F8="\8";$F9="\9"' $indir/capture-lengths.dkvp

echo 'abcdefg' | run_mlr --inidx --odkvp put '$1 =~ "ab(.)d(..)g"  { $c1 = "\1"; $c2 = "\2"}'
echo 'abcdefg' | run_mlr --inidx --odkvp put '$1 =~ "ab(.)?d(..)g" { $c1 = "\1"; $c2 = "\2"}'
echo 'abXdefg' | run_mlr --inidx --odkvp put '$1 =~ "ab(c)?d(..)g" { $c1 = "\1"; $c2 = "\2"}'
echo 'abdefg'  | run_mlr --inidx --odkvp put '$1 =~ "ab(c)?d(..)g" { $c1 = "\1"; $c2 = "\2"}'

# ----------------------------------------------------------------
announce DSL FILTER/PATTERN-ACTION

run_mlr --opprint put '         $x > 0.5;  $z = "flag"'  $indir/abixy
run_mlr --opprint put '       !($x > 0.5); $z = "flag"'  $indir/abixy
run_mlr --opprint put 'filter   $x > 0.5;  $z = "flag"'  $indir/abixy
run_mlr --opprint put '         $x > 0.5  {$z = "flag"}' $indir/abixy
run_mlr --opprint put 'filter !($x > 0.5); $z = "flag"'  $indir/abixy
run_mlr --opprint put '       !($x > 0.5) {$z = "flag"}' $indir/abixy

# ----------------------------------------------------------------
announce DSL GMT DATE/TIME FUNCTIONS

run_mlr --csvlite put '$gmt = sec2gmt($sec)' $indir/sec2gmt
run_mlr --csvlite put '$gmt = sec2gmt($sec,1)' $indir/sec2gmt
run_mlr --csvlite put '$gmt = sec2gmt($sec,3)' $indir/sec2gmt
run_mlr --csvlite put '$gmt = sec2gmt($sec,6)' $indir/sec2gmt
run_mlr --csvlite put '$sec = gmt2sec($gmt)' $indir/gmt2sec
run_mlr --csvlite put '$gmtdate = sec2gmtdate($sec)' $indir/sec2gmt

run_mlr --icsv --opprint put '$gmt = strftime($sec, "%Y-%m-%dT%H:%M:%SZ")'  $indir/sec2gmt
run_mlr --icsv --opprint put '$gmt = strftime($sec, "%Y-%m-%dT%H:%M:%1SZ")' $indir/sec2gmt
run_mlr --icsv --opprint put '$gmt = strftime($sec, "%Y-%m-%dT%H:%M:%3SZ")' $indir/sec2gmt
run_mlr --icsv --opprint put '$gmt = strftime($sec, "%Y-%m-%dT%H:%M:%6SZ")' $indir/sec2gmt
run_mlr --icsv --opprint put '$sec = strptime($gmt, "%Y-%m-%dT%H:%M:%SZ")'  $indir/gmt2sec

run_mlr --csvlite sec2gmt sec $indir/sec2gmt

run_mlr --opprint put '$hms=sec2hms($sec);   $resec=hms2sec($hms);   $diff=$resec-$sec' $indir/sec2xhms
run_mlr --opprint put '$hms=fsec2hms($sec);  $resec=hms2fsec($hms);  $diff=$resec-$sec' $indir/fsec2xhms
run_mlr --opprint put '$hms=sec2dhms($sec);  $resec=dhms2sec($hms);  $diff=$resec-$sec' $indir/sec2xhms
run_mlr --opprint put '$hms=fsec2dhms($sec); $resec=dhms2fsec($hms); $diff=$resec-$sec' $indir/fsec2xhms

run_mlr --csvlite sec2gmt     sec $indir/sec2gmt
run_mlr --csvlite sec2gmtdate sec $indir/sec2gmt

# ----------------------------------------------------------------
announce DSL LOCAL DATE/TIME FUNCTIONS

# See also the system date command:
# export TZ=America/Sao_Paulo; date -j -f "%Y-%m-%d %H:%M:%S %Z" "2017-02-19 00:30:00" +%s
# export TZ=America/Sao_Paulo; date -r  86400 +"%Y-%m-%d %H:%M:%S %Z"

export TZ=America/Sao_Paulo
echo TZ=$TZ
run_mlr --opprint put '$b=localtime2sec($a); $c=sec2localtime($b); $d=sec2localdate($b)' <<_EOF
a=2017-02-18 23:00:00
a=2017-02-18 23:59:59
a=2017-02-19 00:00:00
a=2017-02-19 00:30:00
a=2017-02-19 01:00:00
a=2017-10-14 23:00:00
a=2017-10-14 23:59:59
a=2017-10-15 00:00:00
a=2017-10-15 00:30:00
a=2017-10-15 01:00:00
_EOF
export TZ=

export TZ=America/Sao_Paulo
echo TZ=$TZ
run_mlr --opprint put '$b=localtime2sec($a); $c=sec2localtime($b); $d=sec2localdate($b)' <<_EOF
a=2017-02-14 00:00:00
a=2017-02-15 00:00:00
a=2017-02-16 00:00:00
a=2017-02-17 00:00:00
a=2017-02-18 00:00:00
a=2017-02-19 00:00:00
a=2017-02-20 00:00:00
a=2017-10-12 00:00:00
a=2017-10-13 00:00:00
a=2017-10-14 00:00:00
a=2017-10-15 00:00:00
a=2017-10-16 00:00:00
a=2017-10-17 00:00:00
a=2017-10-18 00:00:00
a=2017-10-19 00:00:00
_EOF
export TZ=

export TZ=America/Sao_Paulo
echo TZ=$TZ
run_mlr --opprint put '$b=strptime_local($a, "%Y-%m-%d %H:%M:%S"); $c=strftime_local($b, "%Y-%m-%d %H:%M:%S")' <<_EOF
a=2017-02-18 23:00:00
a=2017-02-18 23:59:59
a=2017-02-19 00:00:00
a=2017-02-19 00:30:00
a=2017-02-19 01:00:00
a=2017-10-14 23:00:00
a=2017-10-14 23:59:59
a=2017-10-15 00:00:00
a=2017-10-15 00:30:00
a=2017-10-15 01:00:00
_EOF
export TZ=

export TZ=America/Sao_Paulo
echo TZ=$TZ
run_mlr --opprint put '$b=strptime_local($a, "%Y-%m-%d %H:%M:%S"); $c=strftime_local($b, "%Y-%m-%d %H:%M:%S")' <<_EOF
a=2017-02-18 23:00:00
a=2017-02-18 23:59:59
a=2017-02-19 00:00:00
a=2017-02-19 00:30:00
a=2017-02-19 01:00:00
a=2017-10-14 23:00:00
a=2017-10-14 23:59:59
a=2017-10-15 00:00:00
a=2017-10-15 00:30:00
a=2017-10-15 01:00:00
_EOF
export TZ=

# ----------------------------------------------------------------
announce DSL SUB/GSUB/REGEX_EXTRACT

run_mlr --opprint put '$y = sub($x, "e.*l",        "")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "e.*l"i,       "")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "e.*"."l",     "")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "e.*l",        "y123y")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "e.*l"i,       "y123y")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "e.*"."l",     "y123y")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "([hg])e.*l(.)", "y\1y123\2y")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "([hg])e.*l.",   "y\1y123\2y")' $indir/sub.dat
run_mlr --opprint put '$y = sub($x, "([hg])e.*l(.)", "y\1y123.y")'  $indir/sub.dat

run_mlr --opprint put '$y = sub($x,  "a",    "aa")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "a",    "aa")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "A",    "Aa")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "a"i,   "Aa")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "A"i,   "Aa")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "a(.)", "aa\1\1\1")' $indir/gsub.dat

run_mlr --opprint put '$y = sub($x,  "a",    "")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "a",    "")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "A",    "")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "a"i,   "")'   $indir/gsub.dat
run_mlr --opprint put '$y = gsub($x, "A"i,   "")'   $indir/gsub.dat

run_mlr --oxtab cat                       $indir/subtab.dkvp
run_mlr --oxtab put -f $indir/subtab1.mlr $indir/subtab.dkvp
run_mlr --oxtab put -f $indir/subtab2.mlr $indir/subtab.dkvp
run_mlr --oxtab put -f $indir/subtab3.mlr $indir/subtab.dkvp
run_mlr --oxtab put -f $indir/subtab4.mlr $indir/subtab.dkvp

run_mlr --opprint put '$y = ssub($x, "HE",       "")'           $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "HE",       "HE")'         $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "HE",       "12345")'      $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "LL",       "1")'          $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "LL",       "12")'         $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "LL",       "12345")'      $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "LLO",      "")'           $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "LLO",      "12")'         $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "LLO",      "123")'        $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "LLO",      "123456")'     $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "HELLO",    "")'           $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "HELLO",    "1234")'       $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "HELLO",    "12345")'      $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "HELLO",    "1234678")'    $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "nonesuch", "")'           $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "nonesuch", "1234")'       $indir/sub.dat
run_mlr --opprint put '$y = ssub($x, "nonesuch", "1234567890")' $indir/sub.dat

run_mlr --oxtab put '$y = regextract($x, "[A-Z]+")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[A-Z]*")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[a-z]+")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[a-z]*")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[0-9]+")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[0-9]*")' $indir/sub.dat

run_mlr --oxtab put '$y = regextract($x, "[ef]+")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[ef]*")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[hi]+")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[hi]*")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[op]+")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract($x, "[op]*")' $indir/sub.dat

run_mlr --oxtab put '$y = regextract_or_else($x, "[A-Z]+", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[A-Z]*", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[a-z]+", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[a-z]*", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[0-9]+", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[0-9]*", "DEFAULT")' $indir/sub.dat

run_mlr --oxtab put '$y = regextract_or_else($x, "[ef]+", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[ef]*", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[hi]+", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[hi]*", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[op]+", "DEFAULT")' $indir/sub.dat
run_mlr --oxtab put '$y = regextract_or_else($x, "[op]*", "DEFAULT")' $indir/sub.dat

echo 'abcdefg' | run_mlr --nidx put '$1 = sub($1, "ab(.)d(..)g",  "ab<<\1>>d<<\2>>g")'
echo 'abcdefg' | run_mlr --nidx put '$1 = sub($1, "ab(c)?d(..)g", "ab<<\1>>d<<\2>>g")'
echo 'abXdefg' | run_mlr --nidx put '$1 = sub($1, "ab(c)?d(..)g", "ab<<\1>>d<<\2>>g")'
echo 'abdefg'  | run_mlr --nidx put '$1 = sub($1, "ab(c)?d(..)g", "ab<<\1>>d<<\2>>g")'

# ----------------------------------------------------------------
announce DSL SUBSTR

run_mlr put -q '
  int n = strlen($x);
  print "input= <<".$x.">>";
  for (i = -n-2; i <= n+2; i += 1) {
    for (j = -n-2; j <= n+2; j += 1) {
      print "i: ".fmtnum(i,"%3lld")
        ."   j:".fmtnum(j,"%3lld")
        ."   substr(".$x.",".fmtnum(i,"%3lld").",".fmtnum(j,"%3lld")."): <<"
        .substr($x, i, j) .">>";
    }
    print;
}
' << EOF
x=
x=o
x=o1
x=o123456789
EOF

# ----------------------------------------------------------------
announce DSL SYSTEM

run_mlr put '$counter = system("echo X".NR."Y")' $indir/abixy

# ----------------------------------------------------------------
announce DSL OOSVARS

run_mlr --opprint put -v 'begin{@ox=0}; $d=$x-@ox; @ox=$x' $indir/abixy
run_mlr --opprint put -v 'begin{@ox="no"}; $d=@ox == "no" ? 1.0 : $x/@ox; @ox=$x' then step -a ratio -f x $indir/abixy
run_mlr --opprint put -v '$d=$x/@ox; @ox=$x' then step -a ratio -f x $indir/abixy
run_mlr --opprint put -v 'begin{@ox="no"}; $d=@ox == "no" ? 1.0 : $x/@ox; @ox=$x' then step -a ratio -f x $indir/abixy
run_mlr --opprint put -v 'begin{@rsum = 0}; @rsum = @rsum + $x; $rsum = @rsum' $indir/abixy
run_mlr --opprint put -v 'begin{@a=0; @b=0; @c=0}; $za=@a; $zb=@b; $zc=@c; $d=@a+@b+@c; @a=@b; @b=@c; @c=$i' $indir/abixy
run_mlr --opprint put -v 'begin {@a=0; @b=0; @c=0}; $za=@a; $zb=@b; $zc=@c; $d=@a+@b+@c; @a=@b; @b=@c; @c=$i' $indir/abixy
run_mlr --opprint put -v 'begin{@ox=0}; $d=$x-@ox; @ox=$x' $indir/abixy

run_mlr put -v '@a=$a; @b=$b; @c=$x; end {emitf @a; emitf @b; emitf @c}' $indir/abixy
run_mlr put -v '@a=$a; @b=$b; @c=$x; end{emitf @a, @b, @c}' $indir/abixy

run_mlr --opprint put -v 'begin {@count=0; @sum=0.0}; @count=@count+1; @sum=@sum+$x; end{@mean=@sum/@count; emitf @mean}' $indir/abixy
run_mlr --opprint put -v 'end{@mean=@sum/@count; emitf @mean}; begin {@count=0; @sum=0.0}; @count=@count+1; @sum=@sum+$x' $indir/abixy

run_mlr put -v 'begin{ @a = @b[1] }; $c = @d; @e[$i][2+$j][3] = $4; end{@f[@g[5][@h]] = 6}' /dev/null

run_mlr put '@y[$a]=$y; end{dump}' $indir/abixy

run_mlr stats1 -a sum -f y -g a $indir/abixy
run_mlr put '@y_sum[$a] = $y; end{dump}' $indir/abixy


run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @s      ; dump}' $indir/unset1.dkvp

run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @t      ; dump}' $indir/unset1.dkvp
run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @t[1]   ; dump}' $indir/unset1.dkvp

run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @u      ; dump}' $indir/unset1.dkvp
run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @u[1]   ; dump}' $indir/unset1.dkvp
run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @u[1][2]; dump}' $indir/unset1.dkvp


run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @s      ; dump}' $indir/unset4.dkvp

run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @t      ; dump}' $indir/unset4.dkvp
run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @t[1]   ; dump}' $indir/unset4.dkvp

run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @u      ; dump}' $indir/unset4.dkvp
run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @u[1]   ; dump}' $indir/unset4.dkvp
run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @u[1][2]; dump}' $indir/unset4.dkvp

run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset all;      dump}' $indir/unset4.dkvp
run_mlr put -q '@s=$x; @t[$a]=$x; @u[$a][$b]=$x; end{dump; unset @*;       dump}' $indir/unset4.dkvp

run_mlr put 'unset $x' $indir/unset4.dkvp
run_mlr put 'unset $*; $aaa = 999' $indir/unset4.dkvp
run_mlr --from $indir/abixy put 'x = 1; print "OX=".x; unset x; print "NX=".x'

run_mlr put -q '@{variable.name} += $x; end{emit @{variable.name}}' $indir/abixy
run_mlr put -q '@{variable.name}[$a] += $x; end{emit @{variable.name},"a"}' $indir/abixy

run_mlr put 'for (k,v in $*) { if (k == "i") {unset $[k]}}' $indir/abixy

run_mlr --opprint --from $indir/abixy put -q '
  @output[NR] = $*;
  end {
    for ((nr, k), v in @output) {
      if (nr == 4 || k == "i") {
        unset @output[nr][k]
      }
    }
    emitp @output, "NR", "k"
  }
'

# ----------------------------------------------------------------
announce DSL PATTERN-ACTION BLOCKS

run_mlr put -v 'begin{@a=1}; $e=2; $f==$g||$h==$i {};               $x=6; end{@z=9}' /dev/null
run_mlr put -v 'begin{@a=1}; $e=2; $f==$g||$h==$i {$s=1};           $x=6; end{@z=9}' /dev/null
run_mlr put -v 'begin{@a=1}; $e=2; $f==$g||$h==$i {$s=1;$t=2};      $x=6; end{@z=9}' /dev/null
run_mlr put -v 'begin{@a=1}; $e=2; $f==$g||$h==$i {$s=1;$t=2;$u=3}; $x=6; end{@z=9}' /dev/null
run_mlr put -v 'begin{@a=1}; $e=2; $f==$g||$h==$i {$s=1;@t["u".$5]=2;emitf @v,@w;dump}; $x=6; end{@z=9}' /dev/null
run_mlr put -v 'begin{true{@x=1}}; true{@x=2}; end{true{@x=3}}' /dev/null

# ----------------------------------------------------------------
announce DSL STACK-ALLOCATION

# This important test validates the local-stack allocator: which variables are
# assigned which offsets in the stack, and how the local-extent contract is
# satisfied by the clear-at-enter-subframe logic. The -v flag gives context on
# the AST; the -a flag provides the essential output on variable placement; the
# Miller script per se validates semantics.

run_mlr --from $indir/abixy put -v -a -f $indir/test-dsl-stack-allocation.mlr

# These test absent-null handing for as-yet-undefined localvars in expression RHSs.
run_mlr --from $indir/abixy put 'a=a; $oa = a'
run_mlr --from $indir/abixy put 'a=a; $oa = a; a = a; $ob = a'
run_mlr --from $indir/abixy put 'a=a; $oa = a; a = a; $ob = a; a = b; $oc = a'
run_mlr --from $indir/abixy put 'a=a; $oa = a; a = a; $ob = a; a = b; $oc = a; b = 3; b = a; $od = a'
run_mlr --from $indir/abixy put 'a=a; $oa = a; a = a; $ob = a; a = b; $oc = a; b = 3; b = a; $od = a; b = 4;a = b; $oe= a'

# ----------------------------------------------------------------
announce DSL IF-CHAINING

mention IF/ELIF WITH ELSE
run_mlr --from $indir/xy40.dkvp put -v '
  if (NR==1) {
    $x = 2;
    $y = 3
  }'

run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 4) {
    $x = 5;
    $y = 6
  } else {
    $x = 1007;
    $y = 1008
  }'

run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 9) {
    $x = 10;
    $y = 11
  } elif (NR == 12) {
    $x = 13;
    $y = 14
  } else {
    $x = 1015;
    $y = 1016
  }'

run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 17) {
    $x = 18;
    $y = 19
  } elif (NR == 20) {
    $x = 21;
    $y = 22
  } elif (NR == 23) {
    $x = 24;
    $y = 25
  } else {
    $x = 1026;
    $y = 1027
  }'

run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 28) {
    $x = 29;
    $y = 30
  } elif (NR == 31) {
    $x = 32;
    $y = 33
  } elif (NR == 34) {
    $x = 35;
    $y = 36
  } elif (NR == 37) {
    $x = 38;
    $y = 39
  } else {
    $x = 1040;
    $y = 1041
  }'

mention IF/ELIF WITHOUT ELSE
run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 1) {
    $x = 2;
    $y = 3
  }'

run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 4) {
    $x = 5;
    $y = 6
  } elif (NR == 7) {
    $x = 8;
    $y = 9
  }'

run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 10) {
    $x = 11;
    $y = 12
  } elif (NR == 13) {
    $x = 14;
    $y = 15
  } elif (NR == 16) {
    $x = 17;
    $y = 18
  }'

run_mlr --from $indir/xy40.dkvp put -v '
  if (NR == 19) {
    $x = 20;
    $y = 21
  } elif (NR == 22) {
    $x = 23;
    $y = 24
  } elif (NR == 25) {
    $x = 26;
    $y = 37
  } elif (NR == 28) {
    $x = 29;
    $y = 30
  }'

# ----------------------------------------------------------------
announce DSL INDIRECT SREC ASSIGNMENTS

run_mlr put -v '$["a"] = $["b"]; $["x"] = 10 * $["y"]' $indir/abixy
run_mlr --from $indir/abixy put 'while (NF < 256) { $["k".string(NF+1)] = "v".string(NF) }'

# ----------------------------------------------------------------
announce DSL INDIRECT OOSVAR ASSIGNMENTS

run_mlr --opprint put -v '@s = NR; $t = @s; $u=@["s"]; $v = $t - $u' $indir/abixy

run_mlr put -v '@t["u"] = NR; $tu = @["t"]["u"]; emitp all' $indir/abixy
run_mlr put -v '@t["u"] = NR; $tu = @["t"]["u"]; emitp @*' $indir/abixy

run_mlr put -v '@["s"] = $x; emitp all' $indir/abixy

run_mlr put -v '@["t"]["u"] = $y; emitp all' $indir/abixy

# xxx @* on the right
# xxx @* on the left

# ----------------------------------------------------------------
announce OOSVAR-FROM-SREC ASSIGNMENT

run_mlr put -v '@v     = $*' /dev/null
run_mlr put -v '@v[1]  = $*' /dev/null
run_mlr put -v '@v[$2] = $*' /dev/null
run_mlr put -v 'NR == 3 {@v     = $*}' /dev/null
run_mlr put -v 'NR == 3 {@v[1]  = $*}' /dev/null
run_mlr put -v 'NR == 3 {@v[$2] = $*}' /dev/null

run_mlr --oxtab put -q '@v = $*; end {emitp @v }' $indir/abixy-het

run_mlr --oxtab put -q '@v[$a] = $*; end {emitp @v      }' $indir/abixy-het
run_mlr --oxtab put -q '@v[$a] = $*; end {emitp @v, "a" }' $indir/abixy-het

run_mlr --oxtab put -q '@v[$a][$b] = $*; end {emitp @v          }' $indir/abixy-het
run_mlr --oxtab put -q '@v[$a][$b] = $*; end {emitp @v, "a"     }' $indir/abixy-het
run_mlr --oxtab put -q '@v[$a][$b] = $*; end {emitp @v, "a", "b"}' $indir/abixy-het

# ----------------------------------------------------------------
announce SREC-FROM-OOSVAR ASSIGNMENT

run_mlr put -v '$* = @v    ' /dev/null
run_mlr put -v '$* = @v[1] ' /dev/null
run_mlr put -v '$* = @v[$2]' /dev/null
run_mlr put -v 'NR == 3 {$* = @v    }' /dev/null
run_mlr put -v 'NR == 3 {$* = @v[1] }' /dev/null
run_mlr put -v 'NR == 3 {$* = @v[$2]}' /dev/null

run_mlr put '@v[NR] = $a; NR == 7 { @v = $*} ; $* = @v' $indir/abixy-het

# ----------------------------------------------------------------
announce OOSVAR-FROM-OOSVAR ASSIGNMENT

run_mlr put -v '@u    = @v'    /dev/null
run_mlr put -v '@u    = @v[1]' /dev/null
run_mlr put -v '@u[2] = @v'    /dev/null
run_mlr put -v '@u[2] = @v[1]' /dev/null

run_mlr put -v 'begin { @u    = @v }'    /dev/null
run_mlr put -v 'begin { @u    = @v[1] }' /dev/null
run_mlr put -v 'begin { @u[2] = @v }'    /dev/null
run_mlr put -v 'begin { @u[2] = @v[1] }' /dev/null

run_mlr put -v 'NR == 3 { @u    = @v }'    /dev/null
run_mlr put -v 'NR == 3 { @u    = @v[1] }' /dev/null
run_mlr put -v 'NR == 3 { @u[2] = @v }'    /dev/null
run_mlr put -v 'NR == 3 { @u[2] = @v[1] }' /dev/null

run_mlr put -v 'end { @u    = @v }'    /dev/null
run_mlr put -v 'end { @u    = @v[1] }' /dev/null
run_mlr put -v 'end { @u[2] = @v }'    /dev/null
run_mlr put -v 'end { @u[2] = @v[1] }' /dev/null


run_mlr put -q '@s    += $i; @t=@s;             end{dump; emitp@s; emitp @t}' $indir/abixy

run_mlr put -q '@s[1] += $i; @t=@s;             end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1] += $i; @t=@s[1];          end{dump; emitp@s; emitp @t}' $indir/abixy

run_mlr put -q '@s[1] += $i; @t[3]=@s;          end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1] += $i; @t[3]=@s[1];       end{dump; emitp@s; emitp @t}' $indir/abixy

run_mlr put -q '@s[1][2] += $i; @t=@s;             end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1][2] += $i; @t=@s[1];          end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1][2] += $i; @t=@s[1][2];       end{dump; emitp@s; emitp @t}' $indir/abixy

run_mlr put -q '@s[1][2] += $i; @t[3]=@s;          end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1][2] += $i; @t[3]=@s[1];       end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1][2] += $i; @t[3]=@s[1][2];    end{dump; emitp@s; emitp @t}' $indir/abixy

run_mlr put -q '@s[1][2] += $i; @t[3][4]=@s;       end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1][2] += $i; @t[3][4]=@s[1];    end{dump; emitp@s; emitp @t}' $indir/abixy
run_mlr put -q '@s[1][2] += $i; @t[3][4]=@s[1][2]; end{dump; emitp@s; emitp @t}' $indir/abixy

run_mlr --opprint put -q '@s[NR][NR] = $i/100; @t[NR*10]=@s; end{emitp@s,"A","B"; emitp @t,"C","D","E"}' $indir/abixy

# ----------------------------------------------------------------
announce DSL WHILE/DO-WHILE LOOPS

run_mlr put -v 'while($i < 5) { $i += 1}' $indir/abixy
run_mlr put -v 'do {$i += 1} while($i < 5)' $indir/abixy

# ----------------------------------------------------------------
announce DSL FOR-SREC LOOPS

mention empty for-srec
run_mlr --from $indir/abixy put -v 'for(k,v in $*) { }'

mention for-srec without boundvars
run_mlr --from $indir/abixy put -v 'for(k,v in $*) {$nr= NR}'

mention for-srec modifying the srec
run_mlr --from $indir/abixy put -v 'for(k,v in $*) {unset $[k]}; $j = NR'
run_mlr --from $indir/abixy put -v 'for(k,v in $*) {if (k != "x") {unset $[k]}}; $j = NR'
run_mlr --from $indir/abixy --opprint put -S -v 'for(k,v in $*) {$[k."_orig"]=v; $[k] = "other"}'
run_mlr --from $indir/abixy put -S -v 'for(k,v in $*) {$[v]=k}'

run_mlr --from $indir/abixy put -v '
  $sum = 0;
  for(k,v in $*) {
    if (k =~ "^[xy]$") {
      $sum += $[k]
    }
  }'

run_mlr --from $indir/abixy put -S -v '
  $sum = float(0);
  for(k,v in $*) {
    if (k =~ "^[xy]$") {
      $sum += float($[k])
    }
  }'

# ----------------------------------------------------------------
announce DSL FOR-OOSVAR LOOPS

run_mlr --opprint -n put -v '
  @o[1][1]["text1"][NR] = $a;
  @o[1][2]["text2"][NR] = $b;
  @o[1][2][$a][$i*100] = $x;
  for((k1,k2),v in @o[1][2]) {
    @n[3][4][k2][k1] = v;
  }
  end {
    emit @n, "a", "b", "c", "d"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @o[1][1]["text1"][NR] = $a;
  @o[1][2]["text2"][NR] = $b;
  @o[1][2][$a][$i*100] = $x;
  for((k1,k2),v in @o[1][2]) {
    @n[3][4][k2][k1] = v;
  }
  end {
    emit @n, "a", "b", "c", "d"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @sum[$a][$b] += $x;
  @count[$a][$b] += 1;
  end {
    for ((k1, k2), v in @sum) {
      @mean[k1][k2] = @sum[k1][k2] / @count[k1][k2]
    }
    emitp @sum, "a", "b";
    emitp @count, "a", "b";
    emitp @mean, "a", "b"
  }
'

run_mlr --opprint --from $indir/abixy-wide put -q '
  @value["sum"][$a][$b] += $x;
  @value["count"][$a][$b] += 1;
  end {
    for ((k1, k2), v in @value["sum"]) {
      @value["mean"][k1][k2] = @value["sum"][k1][k2] / @value["count"][k1][k2]
    }
    emitp @value, "stat", "a", "b";
  }
'

mlr_expect_fail -n put -v 'for (k, k in $*) {}'

mlr_expect_fail -n put -v 'for (k, k in @*) {}'

mlr_expect_fail -n put -v 'for ((a,a), c in @*) {}'
mlr_expect_fail -n put -v 'for ((a,b), a in @*) {}'
mlr_expect_fail -n put -v 'for ((a,b), b in @*) {}'

mlr_expect_fail -n put -v 'for ((a,a,c), d in @*) {}'
mlr_expect_fail -n put -v 'for ((a,b,a), d in @*) {}'
mlr_expect_fail -n put -v 'for ((a,b,c), a in @*) {}'
mlr_expect_fail -n put -v 'for ((a,b,b), d in @*) {}'
mlr_expect_fail -n put -v 'for ((a,b,c), b in @*) {}'
mlr_expect_fail -n put -v 'for ((a,b,c), c in @*) {}'

run_mlr --from $indir/xyz2 put -q 'func f() { return {"a"."b":"c"."d",3:4}}; for (k,v in f()){print "k=".k.",v=".v}'
run_mlr --from $indir/xyz2 put -q 'for (k,v in {"a"."b":"c"."d",3:"c"}) {print "k=".k.",v=".v}'
run_mlr --from $indir/xyz2 put -q 'o["a"."b"]="c"."d"; for (k,v in o) {print "k=".k.",v=".v}'
run_mlr --from $indir/xyz2 put -q '@o["a"."b"]="c"."d"; for (k,v in @o) {print "k=".k.",v=".v}'
run_mlr --from $indir/xyz2 put 'for (k in $*) { print k}'
run_mlr --from $indir/xyz2 put 'm=$*; for (k in m) { print k}'

# ----------------------------------------------------------------
announce DSL FOR-BIND LOOPS FOR VALGRIND

mention key-only fors

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  map o = {};
  o[ab] = xy;
  for (k in o) {
    print "k is " . k;
  }
'

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  unset @o;
  @o[ab] = xy;
  for (k in @o) {
    print "k is " . k;
  }
'

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  for (k in {ab : xy}) {
    print "k is " . k;
  }
'

run_mlr --from $indir/abixy-het put '
  func f(a, b, x, y): map {
    ab = $a . "_" . $b;
    xy = $x . "_" . $y;
    return {ab : xy};
  }
  for (k in f($a, $b, $x, $y)) {
    print "k is " . k;
  }
'

mention key-value fors with scalar values

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  map o = {};
  o[ab] = xy;
  for (k, v in o) {
    print "k is " . k . "  v is " . v;
  }
'

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  unset @o;
  @o[ab] = xy;
  for (k, v in @o) {
    print "k is " . k . "  v is " . v;
  }
'

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  for (k, v in {ab : xy}) {
    print "k is " . k . "  v is " . v;
  }
'

run_mlr --from $indir/abixy-het put '
  func f(a, b, x, y): map {
    ab = $a . "_" . $b;
    xy = $x . "_" . $y;
    return {ab : xy};
  }
  for (k, v in f($a, $b, $x, $y)) {
    print "k is " . k . "  v is " . v;
  }
'


mention key-value fors with map values

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  map o = {};
  o[ab] = {"foo": xy};
  for (k, v in o) {
    print "k is " . k . "  v is ";
    dump v;
  }
'

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  unset @o;
  @o[ab]["foo"] = xy;
  for (k, v in @o) {
    print "k is " . k . "  v is ";
    dump v;
  }
'

run_mlr --from $indir/abixy-het put '
  ab = $a . "_" . $b;
  xy = $x . "_" . $y;
  for (k, v in {ab : {"foo": xy}}) {
    print "k is " . k . "  v is ";
    dump v;
  }
'

run_mlr --from $indir/abixy-het put '
  func f(a, b, x, y): map {
    ab = $a . "_" . $b;
    xy = $x . "_" . $y;
    return {ab : {"foo" : xy}};
  }
  for (k, v in f($a, $b, $x, $y)) {
    print "k is " . k . "  v is ";
    dump v;
  }
'

# ----------------------------------------------------------------
announce DSL BREAK/CONTINUE IN SINGLE WHILE/DO-WHILE

run_mlr --opprint --from $indir/abixy put '
  while ($i < 5) {
    $i += 1;
    break;
    $a = "ERROR";
  }
'

run_mlr --opprint --from $indir/abixy put '
  while ($i < 5) {
    $i += 1;
    continue;
    $a = "ERROR";
  }
'

run_mlr --opprint --from $indir/abixy put '
  do {
    $i += 1;
    break;
    $a = "ERROR";
  } while ($i < 5);
'

run_mlr --opprint --from $indir/abixy put '
  do {
    $i += 1;
    continue;
    $a = "ERROR";
  } while ($i < 5);
'

run_mlr --opprint --from $indir/abixy put '
  $NR = NR;
  while ($i < 5) {
    $i += 1;
    if (NR == 2) {
      break;
    }
    $a = "reached";
  }
'

run_mlr --opprint --from $indir/abixy put '
  $NR = NR;
  while ($i < 5) {
    $i += 1;
    if (NR == 2) {
      continue;
    }
    $a = "reached";
  }
'

run_mlr --opprint --from $indir/abixy put '
$NR = NR;
  do {
    $i += 1;
    if (NR == 2) {
      break;
    }
    $a = "reached";
  } while ($i < 5);
'

run_mlr --opprint --from $indir/abixy put '
  $NR = NR;
  do {
    $i += 1;
    if (NR == 2) {
      continue;
    }
    $a = "reached";
  } while ($i < 5);
'

# ----------------------------------------------------------------
announce DSL BREAK/CONTINUE IN NESTED WHILE/DO-WHILE

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    break;
    while ($k < 7) {
      $k += 1
    }
  }
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    continue;
    while ($k < 7) {
      $k += 1
    }
  }
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    while ($k < 7) {
      $k += 1;
      break;
      $k += 10000;
    }
  }
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    while ($k < 7) {
      $k += 1;
      continue;
      $k += 10000;
    }
  }
'


run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    if (NR == 2 || NR == 8) {
      break;
    }
    while ($k < 7) {
      $k += 1
    }
  }
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    if (NR == 2 || NR == 8) {
      continue;
    }
    while ($k < 7) {
      $k += 1
    }
  }
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    while ($k < 7) {
      $k += 1;
      if (NR == 2 || NR == 8) {
        break;
      }
      $k += 10000;
    }
  }
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  while ($j < 4) {
    $k = NR;
    $j += 1;
    while ($k < 7) {
      $k += 1;
      if (NR == 2 || NR == 8) {
        continue;
      }
      $k += 10000;
    }
  }
'


run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    break;
    do {
      $k += 1
    } while ($k < 7);
  } while ($j < 4);
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    continue;
    do {
      $k += 1
    } while ($k < 7);
  } while ($j < 4);
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    do {
      $k += 1;
      break;
      $k += 10000;
    } while ($k < 7);
  } while ($j < 4);
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    do {
      $k += 1;
      continue;
      $k += 10000;
    } while ($k < 7);
  } while ($j < 4);
'


run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    if (NR == 2 || NR == 8) {
      break;
    }
    do {
      $k += 1
    } while ($k < 7);
  } while ($j < 4);
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    if (NR == 2 || NR == 8) {
      continue;
    }
    do {
      $k += 1
    } while ($k < 7);
  } while ($j < 4);
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    do {
      $k += 1;
      if (NR == 2 || NR == 8) {
        break;
      }
      $k += 10000;
    } while ($k < 7);
  } while ($j < 4);
'

run_mlr --opprint --from $indir/abixy put '
  $j = NR;
  do {
    $k = NR;
    $j += 1;
    do {
      $k += 1;
      if (NR == 2 || NR == 8) {
        continue;
      }
      $k += 10000;
    } while ($k < 7);
  } while ($j < 4);
'


# ----------------------------------------------------------------
announce DSL BREAK/CONTINUE IN SINGLE FOR-SREC

run_mlr --opprint --from $indir/abixy put -q '
  for (k,v in $*) {
      @logging1[NR][k] = v;
      if (k == "x") {
          break;
      }
  }
  end {
    emitp @logging1, "NR", "k";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k,v in $*) {
      if (k == "x") {
          break;
      }
      @logging2[NR][k] = v;
  }
  end {
    emitp @logging2, "NR", "k";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k,v in $*) {
      @logging3[NR][k] = v;
      if (k == "x") {
          continue;
      }
  }
  end {
    emitp @logging3, "NR", "k";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k,v in $*) {
      if (k == "x") {
          continue;
      }
      @logging4[NR][k] = v;
  }
  end {
    emitp @logging4, "NR", "k"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k,v in $*) {
      @logging1[NR][k] = v;
      if (k == "x") {
          break;
      }
  }

  for (k,v in $*) {
      if (k == "x") {
          break;
      }
      @logging2[NR][k] = v;
  }

  for (k,v in $*) {
      @logging3[NR][k] = v;
      if (k == "x") {
          continue;
      }
  }

  for (k,v in $*) {
      if (k == "x") {
          continue;
      }
      @logging4[NR][k] = v;
  }

  end {
    emitp @logging1, "NR", "k";
    emitp @logging2, "NR", "k";
    emitp @logging3, "NR", "k";
    emitp @logging4, "NR", "k"
  }
'

# ----------------------------------------------------------------
announce DSL BREAK/CONTINUE IN NESTED FOR-SREC

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    break;
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    continue;
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      break;
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      continue;
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    break;
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      break;
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    continue;
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      break;
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'


run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    break;
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      continue;
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    continue;
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      continue;
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'


run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    if (k1 == "b") {
        break
    }
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    if (k1 == "b") {
        continue
    }
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      if (k2 == "a") {
          break
      }
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      if (k2 == "b") {
          continue
      }
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'


run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    if (k1 == "b") {
        break
    }
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      if (k2 == "a") {
          break
      }
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    if (k1 == "b") {
        continue
    }
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      if (k2 == "a") {
          break
      }
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'


run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    if (k1 == "b") {
        break
    }
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      if (k2 == "a") {
          continue
      }
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  for (k1, v1 in $*) {
    @output1[NR][k1] = "before";
    if (k1 == "b") {
        continue
    }
    @output1[NR][k1] = v1;
    for (k2, v2 in $*) {
      @output2[NR][k1."_".k2] = "before";
      if (k2 == "a") {
          continue
      }
      @output2[NR][k1."_".k2] = v2;
    }
  }
  end {
    emit @output1, "NR", "name";
    emit @output2, "NR", "names";
  }
'


# ----------------------------------------------------------------
announce FOR-MAP DEPTH TESTS

mention 'for full oosvar'
run_mlr --from $indir/abixy put '@o[1][2] = 7; for(k1,v in @*) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put '@o[1][2] = 7; for((k1),v in @*) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put '@o[1][2] = 7; for((k1,k2),v in @*) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put '@o[1][2] = 7; for((k1,k2,k3),v in @*) {$x+=10;$y+=100}'

mention 'for oosvar submap'
run_mlr --from $indir/abixy put '@o[1][2][3] = 7; for(k1,v in @o[1][2]) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put '@o[1][2][3] = 7; for((k1),v in @o[1][2]) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put '@o[1][2][3] = 7; for((k1,k2),v in @o[1][2]) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put '@o[1][2][3] = 7; for((k1,k2,k3),v in @o[1][2]) {$x+=10;$y+=100}'

mention 'for local'
run_mlr --from $indir/abixy put 'o[1][2] = 7; for(k1,v in o) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put 'o[1][2] = 7; for((k1),v in o) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put 'o[1][2] = 7; for((k1,k2),v in o) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put 'o[1][2] = 7; for((k1,k2,k3),v in o) {$x+=10;$y+=100}'

mention 'for map-literal'
run_mlr --from $indir/abixy put 'for(k1,v in {1:{2:7}}) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put 'for((k1),v in {1:{2:7}}) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put 'for((k1,k2),v in {1:{2:7}}) {$x+=10;$y+=100}'
run_mlr --from $indir/abixy put 'for((k1,k2,k3),v in {1:{2:7}}) {$x+=10;$y+=100}'

# ----------------------------------------------------------------
announce DSL BREAK/CONTINUE IN SINGLE FOR-OOSVAR

mention single-key tests, direct break/continue

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        break;
        @output[k1] = v;
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        @output[k1] = v;
        break;
        @output[k1] = "ERROR";
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        continue;
        @output[k1] = v
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        @output[k1] = v;
        continue;
        @output[k1] = "ERROR";
    }
    emit @output, "NR", "name"
  }
'

mention single-key tests, indirect break/continue

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        if (k1 == "i") {
          break;
        }
        @output[k1] = v;
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        @output[k1] = v;
        if (k1 == "i") {
          break;
        }
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        if (k1 == "i") {
          continue;
        }
        @output[k1] = v
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for (k1, v in @logging[2]) {
        @output[k1] = v;
        if (k1 == "i") {
          continue;
        }
        @output[k1] = "reached";
    }
    emit @output, "NR", "name"
  }
'

mention multiple-key tests, direct break/continue

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        break;
        @output[k1][k2] = v;
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        @output[k1][k2] = v;
        break;
        @output[k1][k2] = "ERROR"
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        continue;
        @output[k1][k2] = v
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        @output[k1][k2] = v;
        continue;
        @output[k1][k2] = "ERROR";
    }
    emit @output, "NR", "name"
  }
'

mention multiple-key tests, indirect break/continue

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        if (k1 == 5) {
          break;
        }
        @output[k1][k2] = v;
    }
    emit @output, "NR", "name"
  }
'
run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        if (k2 == "i") {
          break;
        }
        @output[k1][k2] = v;
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        @output[k1][k2] = v;
        if (k1 == 5) {
          break;
        }
    }
    emit @output, "NR", "name"
  }
'
run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        @output[k1][k2] = v;
        if (k2 == "i") {
          break;
        }
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        if (k1 == 5) {
          continue;
        }
        @output[k1][k2] = v
    }
    emit @output, "NR", "name"
  }
'
run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        if (k2 == "i") {
          continue;
        }
        @output[k1][k2] = v
    }
    emit @output, "NR", "name"
  }
'

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        @output[k1][k2] = "before";
        if (k1 == 5) {
          continue;
        }
        @output[k1][k2] = v;
    }
    emit @output, "NR", "name"
  }
'
run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        @output[k1][k2] = "before";
        if (k2 == "i") {
          continue;
        }
        @output[k1][k2] = v;
    }
    emit @output, "NR", "name"
  }
'


# ----------------------------------------------------------------
announce DSL BREAK/CONTINUE IN NESTED FOR-OOSVAR

run_mlr --opprint --from $indir/abixy put -q '
  @logging[NR] = $*;
  end {
    for ((k1, k2), v in @logging) {
        if (k1 != 2) {
          continue
        }
        for ((k3, k4), v in @logging) {
          if (k3 != 4) {
            continue
          }
          @output[k1][k2][k3][k4] = v;
        }
    }
    emit @output, "NR1", "name1", "NR2", "name2"
  }
'

# ----------------------------------------------------------------
announce DSL PRINT

run_mlr put -q 'print  1; print  "two"; print  $a; print;  print  $i < 4; print  "y is ".string($y); print ""' $indir/abixy
run_mlr put -q 'printn 1; printn "two"; printn $a; printn; printn $i < 4; printn "y is ".string($y); print ""' $indir/abixy

run_mlr put -q 'print  $*; print  $*; print  {}; print' $indir/abixy
run_mlr put -q 'printn $*; printn $*; printn {}; print' $indir/abixy

# ----------------------------------------------------------------
announce ABSENT/EMPTY

run_mlr put -q '@sum     += $x; end{emitp @sum}'      $indir/abixy
run_mlr put -q '@sum[$a] += $x; end{emitp @sum, "a"}' $indir/abixy
run_mlr put    '$nonesuch = @nonesuch' $indir/abixy

run_mlr put -q '@sum     += $x; end{emitp @sum}'      $indir/abixy-het
run_mlr put -q '@sum[$a] += $x; end{emitp @sum, "a"}' $indir/abixy-het
run_mlr put    '$nonesuch = @nonesuch' $indir/abixy-het

run_mlr put -q '@sum += $x; @sumtype = typeof(@sum); @xtype = typeof($x); emitf @sumtype, @xtype, @sum; end{emitp @sum}' $indir/abixy
run_mlr put -q '@sum += $x; @sumtype = typeof(@sum); @xtype = typeof($x); emitf @sumtype, @xtype, @sum; end{emitp @sum}' $indir/abixy-het

run_mlr put '$z = $x + $y' $indir/typeof.dkvp
run_mlr put '$z = $x + $u' $indir/typeof.dkvp

run_mlr put '@s = @s + $y; emitp @s' $indir/typeof.dkvp
run_mlr put '@s = @s + $u; emitp @s' $indir/typeof.dkvp

run_mlr put '$z = $x + $y; $x=typeof($x);$y=typeof($y);$z=typeof($z)' $indir/typeof.dkvp
run_mlr put '$z = $x + $u; $x=typeof($x);$y=typeof($y);$z=typeof($z)' $indir/typeof.dkvp

run_mlr put '@s = @s + $y; $x=typeof($x);$y=typeof($y);$z=typeof($z);$s=typeof(@s)' $indir/typeof.dkvp
run_mlr put '@s = @s + $u; $x=typeof($x);$y=typeof($y);$z=typeof($z);$s=typeof(@s)' $indir/typeof.dkvp

run_mlr cat << EOF
x=1
x=
x=7
EOF

run_mlr --ofs tab put '$osum=@sum; $ostype=typeof(@sum);$xtype=typeof($x);@sum+=$x; $nstype=typeof(@sum);$nsum=@sum; end { emit @sum }' <<EOF
x=1
x=
x=7
EOF

run_mlr --ofs tab put '$osum=@sum; $ostype=typeof(@sum);$xtype=typeof($x);is_present($x){@sum+=$x}; $nstype=typeof(@sum);$nsum=@sum; end { emit @sum }' <<EOF
x=1
x=
x=7
EOF

run_mlr cat << EOF
x=1
xxx=
x=7
EOF

run_mlr --ofs tab put '$osum=@sum; $ostype=typeof(@sum);$xtype=typeof($x);@sum+=$x; $nstype=typeof(@sum);$nsum=@sum; end { emit @sum }' <<EOF
x=1
xxx=
x=7
EOF

run_mlr --ofs tab put '$osum=@sum; $ostype=typeof(@sum);$xtype=typeof($x);is_present($x){@sum+=$x}; $nstype=typeof(@sum);$nsum=@sum; end { emit @sum }' <<EOF
x=1
xxx=
x=7
EOF

run_mlr cat << EOF
x=1
x=
y=
x=7
EOF

run_mlr --ofs tab put '$xtype=typeof($x);$sum = $x + 10; $stype=typeof($sum)' <<EOF
x=1
x=
y=
x=7
EOF

run_mlr --ofs tab put '$xtype=typeof($x);$sum = is_present($x) ? $x + 10 : 999; $stype=typeof($sum)' <<EOF
x=1
x=
y=
x=7
EOF


# ----------------------------------------------------------------
announce MAP-VARIANT DUMPS

run_mlr --from $indir/abixy-het put -q 'dump {"a"."b":$a.$b}'
run_mlr --from $indir/abixy-het put -q 'func f(a, b) { return {"a"."b":a.b} } dump f($a, $b)'

# ----------------------------------------------------------------
announce PARAMETERIZED EMIT

run_mlr put -q '@sum[$a] = $x; end{ emitp @sum; }'         $indir/abixy
run_mlr put -q '@sum[$a] = $x; end{ emitp @sum,"a"; }'     $indir/abixy
run_mlr put -q '@sum[$a] = $x; end{ emitp @sum,"a","b"; }' $indir/abixy

run_mlr put -q '@sum[$a][$b] = $x; end{ emitp @sum; }'         $indir/abixy
run_mlr put -q '@sum[$a][$b] = $x; end{ emitp @sum,"a"; }'     $indir/abixy
run_mlr put -q '@sum[$a][$b] = $x; end{ emitp @sum,"a","b"; }' $indir/abixy

run_mlr put -q '@v = $a;        end {emitf @v }' $indir/abixy
run_mlr put -q '@v = $i;        end {emitf @v }' $indir/abixy
run_mlr put -q '@v = $x;        end {emitf @v }' $indir/abixy
run_mlr put -q '@v = $nonesuch; end {emitf @v }' $indir/abixy

run_mlr put -q '@v = $a;        end {emitp @v }' $indir/abixy
run_mlr put -q '@v = $i;        end {emitp @v }' $indir/abixy
run_mlr put -q '@v = $x;        end {emitp @v }' $indir/abixy
run_mlr put -q '@v = $nonesuch; end {emitp @v }' $indir/abixy

run_mlr put -q '@sum += $i;        end {emitf @sum }' $indir/abixy
run_mlr put -q '@sum += $x;        end {emitf @sum }' $indir/abixy
run_mlr put -q '@sum += $nonesuch; end {emitf @sum }' $indir/abixy

run_mlr put -q '@sum += $i;        end {emitp  @sum          }' $indir/abixy
run_mlr put -q '@sum += $x;        end {emitp  @sum          }' $indir/abixy
run_mlr put -q '@sum += $nonesuch; end {emitp  @sum          }' $indir/abixy
run_mlr put -q '@sum += $i;        end {emitp  @sum, "extra" }' $indir/abixy
run_mlr put -q '@sum += $x;        end {emitp  @sum, "extra" }' $indir/abixy
run_mlr put -q '@sum += $nonesuch; end {emitp  @sum, "extra" }' $indir/abixy

run_mlr put -q '@sum[$a] += $i;        end {emitp  @sum               }' $indir/abixy
run_mlr put -q '@sum[$a] += $x;        end {emitp  @sum               }' $indir/abixy
run_mlr put -q '@sum[$a] += $nonesuch; end {emitp  @sum               }' $indir/abixy
run_mlr put -q '@sum[$a] += $i;        end {emitp  @sum, "a"          }' $indir/abixy
run_mlr put -q '@sum[$a] += $x;        end {emitp  @sum, "a"          }' $indir/abixy
run_mlr put -q '@sum[$a] += $nonesuch; end {emitp  @sum, "a"          }' $indir/abixy
run_mlr put -q '@sum[$a] += $i;        end {emitp  @sum, "a", "extra" }' $indir/abixy
run_mlr put -q '@sum[$a] += $x;        end {emitp  @sum, "a", "extra" }' $indir/abixy
run_mlr put -q '@sum[$a] += $nonesuch; end {emitp  @sum, "a", "extra" }' $indir/abixy

run_mlr put -q '@sum[$a][$b] += $i;        end {emitp  @sum                    }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $x;        end {emitp  @sum                    }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $nonesuch; end {emitp  @sum                    }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $i;        end {emitp  @sum, "a"               }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $x;        end {emitp  @sum, "a"               }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $nonesuch; end {emitp  @sum, "a"               }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $i;        end {emitp  @sum, "a", "b"          }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $x;        end {emitp  @sum, "a", "b"          }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $nonesuch; end {emitp  @sum, "a", "b"          }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $i;        end {emitp  @sum, "a", "b", "extra" }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $x;        end {emitp  @sum, "a", "b", "extra" }' $indir/abixy
run_mlr put -q '@sum[$a][$b] += $nonesuch; end {emitp  @sum, "a", "b", "extra" }' $indir/abixy

run_mlr --oxtab put -q '@sum[$a][$b] += $i; NR == 3 { @x = $x }; NR == 7 { @v = $* }; end {emitp all}' $indir/abixy-het

run_mlr --opprint put -q '@v[NR]=$*; end{emitp @v}'     $indir/abixy
run_mlr --opprint put -q '@v[NR]=$*; end{emitp @v,"X"}' $indir/abixy

run_mlr --opprint put -q '@v[NR]=$*; end{emitp @v[1]}'         $indir/abixy
run_mlr --opprint put -q '@v[NR]=$*; end{emitp @v[1],"X"}'     $indir/abixy
run_mlr --opprint put -q '@v[NR]=$*; end{emitp @v[1],"X","Y"}' $indir/abixy

run_mlr --opprint put -q '@v[NR][NR]=$*; end{emitp @v[1]}'         $indir/abixy
run_mlr --opprint put -q '@v[NR][NR]=$*; end{emitp @v[1],"X"}'     $indir/abixy
run_mlr --opprint put -q '@v[NR][NR]=$*; end{emitp @v[1],"X","Y"}' $indir/abixy

run_mlr --opprint put -q '@v[NR][NR]=$*; end{emitp @v[1][1]}'         $indir/abixy
run_mlr --opprint put -q '@v[NR][NR]=$*; end{emitp @v[1][1],"X"}'     $indir/abixy
run_mlr --opprint put -q '@v[NR][NR]=$*; end{emitp @v[1][1],"X","Y"}' $indir/abixy

run_mlr put -q '@a=$a; @b[1]=$b; @c[1][2]=$x; end{emitp all}'                     $indir/abixy-het
run_mlr put -q '@a=$a; @b[1]=$b; @c[1][2]=$x; end{emitp all,"one"}'               $indir/abixy-het
run_mlr put -q '@a=$a; @b[1]=$b; @c[1][2]=$x; end{emitp all,"one","two"}'         $indir/abixy-het
run_mlr put -q '@a=$a; @b[1]=$b; @c[1][2]=$x; end{emitp all,"one","two","three"}' $indir/abixy-het

run_mlr --oxtab put --oflatsep @ -q '@a=$a; @b[1]=$b; @c[1][2]=$x; end{emitp all}' $indir/abixy-het

# ----------------------------------------------------------------
announce PREFIXED/UNPREFIXED EMIT

run_mlr --oxtab put -q '@sum     += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
run_mlr --oxtab put -q '@sum     += $x; end{dump;emit @sum     }'  $indir/abixy-wide


run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emit @sum     }'  $indir/abixy-wide

run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emitp  @sum, "a"}'  $indir/abixy-wide
run_mlr --oxtab put -q '@sum[$a] += $x; end{dump;emit @sum, "a"}'  $indir/abixy-wide


run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emit @sum     }'  $indir/abixy-wide

run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emitp  @sum, "a"}'  $indir/abixy-wide
run_mlr --oxtab put -q '@sum[$a][$b] += $x; end{dump;emit @sum, "a"}'  $indir/abixy-wide

run_mlr --opprint put -q '@sum[$a][$b] += $x; end{dump;emitp  @sum, "a", "b"}'  $indir/abixy-wide
run_mlr --opprint put -q '@sum[$a][$b] += $x; end{dump;emit @sum, "a", "b"}'  $indir/abixy-wide


run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum     }'  $indir/abixy-wide
run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum     }'  $indir/abixy-wide

run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum, "a"}'  $indir/abixy-wide
run_mlr --oxtab put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum, "a"}'  $indir/abixy-wide

run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum, "a", "b"}'  $indir/abixy-wide
run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum, "a", "b"}'  $indir/abixy-wide

run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emitp  @sum, "a", "b", "ab"}'  $indir/abixy-wide
run_mlr --opprint put -q '@sum[$a][$b][$a.$b] += $x; end{dump;emit @sum, "a", "b", "ab"}'  $indir/abixy-wide



run_mlr --oxtab head -n 2  then put -q '@v       =  $*; end{dump;emitp  @v}'         $indir/abixy
run_mlr --oxtab head -n 2  then put -q '@v       =  $*; end{dump;emit @v}'         $indir/abixy


run_mlr --oxtab head -n 2  then put -q '@v[NR]   =  $*; end{dump;emitp  @v        }' $indir/abixy
run_mlr --oxtab head -n 2  then put -q '@v[NR]   =  $*; end{dump;emit @v        }' $indir/abixy

run_mlr --opprint head -n 2  then put -q '@v[NR]   =  $*; end{dump;emitp  @v,   "I"}' $indir/abixy
run_mlr --opprint head -n 2  then put -q '@v[NR]   =  $*; end{dump;emit @v,   "I"}' $indir/abixy


run_mlr --oxtab head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emitp  @v        }' $indir/abixy
run_mlr --oxtab head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emit @v        }' $indir/abixy

run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emitp  @v,   "I"}' $indir/abixy
run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emit @v,   "I"}' $indir/abixy

run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emitp  @v,   "I", "J"}' $indir/abixy
run_mlr --opprint head -n 2  then put -q '@v[NR][NR]   =  $*; end{dump;emit @v,   "I", "J"}' $indir/abixy


run_mlr --oxtab head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v        }' $indir/abixy
run_mlr --oxtab head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v        }' $indir/abixy

run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v,   "I"}' $indir/abixy
run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v,   "I"}' $indir/abixy

run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v,   "I", "J"}' $indir/abixy
run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v,   "I", "J"}' $indir/abixy

run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emitp  @v,   "I", "J", "K"}' $indir/abixy
run_mlr --opprint head -n 2  then put -q '@v[NR][NR][NR]   =  $*; end{dump;emit @v,   "I", "J", "K"}' $indir/abixy


# ----------------------------------------------------------------
announce LASHED EMITP SINGLES

run_mlr -n put 'end {
  @a = 111;
  emitp @a
}'
run_mlr -n put 'end {
  @a = 111;
  emitp (@a)
}'

run_mlr -n put 'end {
  @a[111] = 222;
  emitp @a, "s"
}'
run_mlr -n put 'end {
  @a[111] = 222;
  emitp (@a), "s"
}'

run_mlr -n put 'end {
  @a[111] = 222;
  @a[333] = 444;
  emitp @a, "s"
}'
run_mlr -n put 'end {
  @a[111] = 222;
  @a[333] = 444;
  emitp (@a), "s"
}'

run_mlr -n put 'end {
  @a[111][222] = 333;
  emitp @a, "s"
}'
run_mlr -n put 'end {
  @a[111][222] = 333;
  emitp (@a), "s"
}'

run_mlr -n put 'end {
  @a[111][222] = 333;
  @a[444][555] = 666;
  emitp @a, "s"
}'
run_mlr -n put 'end {
  @a[111][222] = 333;
  @a[444][555] = 666;
  emitp (@a), "s"
}'

run_mlr -n put 'end {
  @a[111][222] = 333;
  emitp @a, "s", "t"
}'
run_mlr -n put 'end {
  @a[111][222] = 333;
  emitp (@a), "s", "t"
}'

run_mlr -n put 'end {
  @a[111][222] = 333;
  emitp @a[111], "t"
}'
run_mlr -n put 'end {
  @a[111][222] = 333;
  emitp (@a[111]), "t"
}'

# ----------------------------------------------------------------
announce LASHED EMIT SINGLES

run_mlr -n put 'end {
  @a = 111;
  emit @a
}'
run_mlr -n put 'end {
  @a = 111;
  emit (@a)
}'

run_mlr -n put 'end {
  @a[111] = 222;
  emit @a, "s"
}'
run_mlr -n put 'end {
  @a[111] = 222;
  emit (@a), "s"
}'

run_mlr -n put 'end {
  @a[111] = 222;
  @a[333] = 444;
  emit @a, "s"
}'
run_mlr -n put 'end {
  @a[111] = 222;
  @a[333] = 444;
  emit (@a), "s"
}'

run_mlr -n put 'end {
  @a[111][222] = 333;
  emit @a, "s"
}'
run_mlr -n put 'end {
  @a[111][222] = 333;
  emit (@a), "s"
}'

# ----------------------------------------------------------------
announce LASHED EMITP PAIRS

run_mlr -n put 'end {
  @a = 111;
  @b = 222;
  emitp (@a, @b)
}'

run_mlr -n put 'end {
  @a[1] = 111;
  @b[1] = 222;
  emitp (@a[1], @b[1])
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[1][2][3] = 8;
  emitp (@a, @b), "s", "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emitp (@a[1], @b[5]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][6][3] = 8;
  emitp (@a[1][2], @b[5][6]), "u"
}'

# ----------------------------------------------------------------
announce LASHED EMIT PAIRS

run_mlr -n put 'end {
  @a = 111;
  @b = 222;
  emit (@a, @b)
}'

run_mlr -n put 'end {
  @a[1] = 111;
  @b[1] = 222;
  emit (@a[1], @b[1])
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[1][2][3] = 8;
  emit (@a, @b), "s", "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emit (@a[1], @b[5]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][6][3] = 8;
  emit (@a[1][2], @b[5][6]), "u"
}'

# ----------------------------------------------------------------
announce LASHED EMIT WITH VARYING DEPTH

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emit (@a[1], @b[2]), "t"
}'

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emit (@a, @b), "s", "t"
}'

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @a[3] = 10;
  @a[4] = 11;
  @a[5][6][7] = 12;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emit (@a, @b), "s", "t"
}'

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @a[3] = 10;
  @a[4] = 11;
  @a[5][6][7] = 12;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emit (@b, @a), "s", "t"
}'


run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emit (@a[1], @b[3]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emit (@a[1][2], @b[5][9]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emit (@a[1][2], @b[9][2]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emit (@a[9], @b[5]), "t", "u"
}'

# ----------------------------------------------------------------
announce LASHED EMITP WITH VARYING DEPTH

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emitp (@a[1], @b[2]), "t"
}'

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emitp (@a, @b), "s", "t"
}'

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @a[3] = 10;
  @a[4] = 11;
  @a[5][6][7] = 12;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emitp (@a, @b), "s", "t"
}'

run_mlr -n put 'end {
  @a[1][1] = 1;
  @a[1][2] = 2;
  @a[2][1] = 3;
  @a[2][2] = 4;
  @a[3] = 10;
  @a[4] = 11;
  @a[5][6][7] = 12;
  @b[1][1] = 5;
  @b[1][2] = 6;
  @b[2][1] = 7;
  @b[2][2] = 8;
  emitp (@b, @a), "s", "t"
}'


run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emitp (@a[1], @b[3]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emitp (@a[1][2], @b[5][9]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emitp (@a[1][2], @b[9][2]), "t", "u"
}'

run_mlr -n put 'end {
  @a[1][2][3] = 4;
  @b[5][2][3] = 8;
  emitp (@a[9], @b[5]), "t", "u"
}'

# ----------------------------------------------------------------
announce CANONICAL LASHED EMIT

run_mlr --from $indir/abixy-wide --opprint put -q '
  @count[$a] += 1;
  @sum[$a] += $x;
  end {
      for (a, c in @count) {
          @mean[a] = @sum[a] / @count[a]
      }
      emit (@sum, @count, @mean), "a"
  }
'

run_mlr --from $indir/abixy-wide --opprint put -q '
  @count[$a][$b] += 1;
  @sum[$a][$b] += $x;
  end {
      for ((a, b), c in @count) {
          @mean[a][b] = @sum[a][b] / @count[a][b]
      }
      emit (@sum, @count, @mean), "a", "b"
  }
'

# ----------------------------------------------------------------
announce MAP-VARIANT EMITS

run_mlr         --from $indir/abixy-het --opprint put -q 'o=$a.$b; emit o'
run_mlr         --from $indir/abixy-het --opprint put -q 'o={"ab":$a.$b}; emit o'

run_mlr         --from $indir/abixy-het --opprint put -q '@o=$a.$b; emit @o'
run_mlr         --from $indir/abixy-het --opprint put -q '@o={"ab":$a.$b}; emit @o'

run_mlr         --from $indir/abixy-het --opprint put -q '@o=$a.$b; emit @*'
run_mlr         --from $indir/abixy-het --opprint put -q '@o={"ab":$a.$b}; emit @*'

mlr_expect_fail --from $indir/abixy-het --opprint put -q 'emit $a.$b'
run_mlr         --from $indir/abixy-het --opprint put -q 'emit {"ab":$a.$b}'

run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a,b) { return a.b } o = f($a, $b); emit o'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a,b) { return a.b } emit f($a, $b)'

run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a,b) { return {"ab": a.b} } o = f($a, $b); emit o'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a,b) { return {"ab": a.b} } emit f($a, $b)'

# ----------------------------------------------------------------
announce MAP-VARIANT LASHED EMITS

# scalar emits aren't reasonable ... but they shouldn't segv

mention scalar lashed emits
mlr_expect_fail --from $indir/abixy-het --opprint put -q 'emit ($a . "_" . $b, $x . "_" . $y)'
run_mlr         --from $indir/abixy-het --opprint put -q ' o = $a . "_" . $b;  p = $x . "_" . $y; emit  (o,  p)'
run_mlr         --from $indir/abixy-het --opprint put -q '@o = $a . "_" . $b; @p = $x . "_" . $y; emit (@o, @p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return a . "_" . b }  o = f($a, $b);  p = f($x, $y); emit  (o,  p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return a . "_" . b } @o = f($a, $b); @p = f($x, $y); emit (@o, @p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return a . "_" . b } emit (f($a, $b), f($x, $y))'

mention non-scalar non-keyed lashed emits
run_mlr         --from $indir/abixy-het --opprint put -q 'emit ({"ab": $a . "_" . $b}, {"ab": $x . "_" . $y})'
run_mlr         --from $indir/abixy-het --opprint put -q ' o = {"ab": $a . "_" . $b};  p = {"ab": $x . "_" . $y}; emit  (o, p)'
run_mlr         --from $indir/abixy-het --opprint put -q '@o = {"ab": $a . "_" . $b}; @p = {"ab": $x . "_" . $y}; emit (@o, @p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} }  o = f($a, $b);  p = f($x, $y); emit  (o, p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } @o = f($a, $b); @p = f($x, $y); emit (@o, @p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } emit (f($a, $b), f($x, $y))'

mention non-scalar non-keyed lashed emits
run_mlr         --from $indir/abixy-het --opprint put -q 'emitp ({"ab": $a . "_" . $b}, {"ab": $x . "_" . $y})'
run_mlr         --from $indir/abixy-het --opprint put -q ' o = {"ab": $a . "_" . $b};  p = {"ab": $x . "_" . $y}; emitp  (o, p)'
run_mlr         --from $indir/abixy-het --opprint put -q '@o = {"ab": $a . "_" . $b}; @p = {"ab": $x . "_" . $y}; emitp (@o, @p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} }  o = f($a, $b);  p = f($x, $y); emitp  (o, p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } @o = f($a, $b); @p = f($x, $y); emitp (@o, @p)'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } emit (f($a, $b), f($x, $y))'

mention non-scalar keyed lashed emits
run_mlr         --from $indir/abixy-het --opprint put -q 'emit ({"ab": $a . "_" . $b}, {"ab": $x . "_" . $y}), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q ' o = {"ab": $a . "_" . $b};  p = {"ab": $x . "_" . $y}; emit  (o, p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q '@o = {"ab": $a . "_" . $b}; @p = {"ab": $x . "_" . $y}; emit (@o, @p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} }  o = f($a, $b);  p = f($x, $y); emit  (o, p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } @o = f($a, $b); @p = f($x, $y); emit (@o, @p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } emit (f($a, $b), f($x, $y)), "ab"'

mention non-scalar keyed lashed emits
run_mlr         --from $indir/abixy-het --opprint put -q 'emitp ({"ab": $a . "_" . $b}, {"ab": $x . "_" . $y}), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q ' o = {"ab": $a . "_" . $b};  p = {"ab": $x . "_" . $y}; emitp  (o, p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q '@o = {"ab": $a . "_" . $b}; @p = {"ab": $x . "_" . $y}; emitp (@o, @p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} }  o = f($a, $b);  p = f($x, $y); emitp  (o, p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } @o = f($a, $b); @p = f($x, $y); emitp (@o, @p), "ab"'
run_mlr         --from $indir/abixy-het --opprint put -q 'func f(a, b) { return {"ab": a . "_" . b} } emitp (f($a, $b), f($x, $y)), "ab"'

# ----------------------------------------------------------------
announce MAPPER TEE REDIRECTS

tee1=$reloutdir/tee1
mkdir -p $tee1

run_mlr --from $indir/abixy tee $tee1/out then nothing
run_cat $tee1/out

run_mlr --from $indir/abixy tee --no-fflush $tee1/out then nothing
run_cat $tee1/out

run_mlr --from $indir/abixy tee -a $tee1/out then nothing
run_cat $tee1/out

run_mlr --from $indir/abixy tee -o json $tee1/out then nothing
run_cat $tee1/out

# ----------------------------------------------------------------
announce DSL TEE REDIRECTS

tee2=$reloutdir/tee2
mkdir -p $tee2

run_mlr put -q 'tee > "'$tee2'/out.".$a, $*' $indir/abixy
run_cat $tee2/out.eks
run_cat $tee2/out.hat
run_cat $tee2/out.pan
run_cat $tee2/out.wye
run_cat $tee2/out.zee

run_mlr put -q --no-fflush 'tee > "'$tee2'/out.".$a, $*' $indir/abixy
run_cat $tee2/out.eks
run_cat $tee2/out.hat
run_cat $tee2/out.pan
run_cat $tee2/out.wye
run_cat $tee2/out.zee

run_mlr put -q 'tee >> "'$tee2'/out.".$a, $*' $indir/abixy
run_cat $tee2/out.eks
run_cat $tee2/out.hat
run_cat $tee2/out.pan
run_cat $tee2/out.wye
run_cat $tee2/out.zee

run_mlr put -q -o json 'tee > "'$tee2'/out.".$a, $*' $indir/abixy
run_cat $tee2/out.eks
run_cat $tee2/out.hat
run_cat $tee2/out.pan
run_cat $tee2/out.wye
run_cat $tee2/out.zee

run_mlr put -q 'tee | "tr \[a-z\] \[A-Z\]", $*' $indir/abixy

run_mlr put -q -o json 'tee | "tr \[a-z\] \[A-Z\]", $*' $indir/abixy

touch $tee2/err1
run_mlr put -q 'tee > stdout, $*' $indir/abixy 2> $tee2/err1
run_cat $tee2/err1

touch $tee2/err2
run_mlr put -q 'tee > stderr, $*' $indir/abixy 2> $tee2/err2
run_cat $tee2/err2

# ----------------------------------------------------------------
announce DSL PRINT REDIRECTS

print1=$reloutdir/print1
mkdir -p $print1

run_mlr put -q 'print > "'$print1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
run_cat $print1/out.eks
run_cat $print1/out.hat
run_cat $print1/out.pan
run_cat $print1/out.wye
run_cat $print1/out.zee

run_mlr put -q 'print > "'$print1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
run_cat $print1/out.eks
run_cat $print1/out.hat
run_cat $print1/out.pan
run_cat $print1/out.wye
run_cat $print1/out.zee

run_mlr put -q 'print >> "'$print1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
run_cat $print1/out.eks
run_cat $print1/out.hat
run_cat $print1/out.pan
run_cat $print1/out.wye
run_cat $print1/out.zee

run_mlr put -q 'print | "tr \[a-z\] \[A-Z\]",  "abi:".$a.$b.$i' $indir/abixy

touch $print1/err1
run_mlr put -q 'print > stdout, "abi:".$a.$b.$i' $indir/abixy 2> $print1/err1
run_cat $print1/err1

touch $print1/err2
run_mlr put -q 'print > stderr, "abi:".$a.$b.$i' $indir/abixy 2> $print1/err2
run_cat $print1/err2

# ----------------------------------------------------------------
announce DSL PRINTN REDIRECTS

printn1=$reloutdir/printn1
mkdir -p $printn1

run_mlr put -q 'printn > "'$printn1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
run_cat $printn1/out.eks
run_cat $printn1/out.hat
run_cat $printn1/out.pan
run_cat $printn1/out.wye
run_cat $printn1/out.zee

run_mlr put -q 'printn > "'$printn1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
run_cat $printn1/out.eks
run_cat $printn1/out.hat
run_cat $printn1/out.pan
run_cat $printn1/out.wye
run_cat $printn1/out.zee

run_mlr put -q 'printn >> "'$printn1'/out.".$a, "abi:".$a.$b.$i' $indir/abixy
run_cat $printn1/out.eks
run_cat $printn1/out.hat
run_cat $printn1/out.pan
run_cat $printn1/out.wye
run_cat $printn1/out.zee

run_mlr put -q 'printn | "tr \[a-z\] \[A-Z\]",  "abi:".$a.$b.$i' $indir/abixy

touch $printn1/err1
run_mlr put -q 'printn > stdout, "abi:".$a.$b.$i' $indir/abixy 2> $printn1/err1
run_cat $printn1/err1

touch $printn1/err2
run_mlr put -q 'printn > stderr, "abi:".$a.$b.$i' $indir/abixy 2> $printn1/err2
run_cat $printn1/err2

# ----------------------------------------------------------------
announce DSL DUMP REDIRECTS

dump1=$reloutdir/dump1
mkdir -p $dump1

run_mlr put -q '@v=$*; dump > "'$dump1'/out.".$a' $indir/abixy
run_cat $dump1/out.eks
run_cat $dump1/out.hat
run_cat $dump1/out.pan
run_cat $dump1/out.wye
run_cat $dump1/out.zee

run_mlr put -q '@v=$*; dump > "'$dump1'/out.".$a' $indir/abixy
run_cat $dump1/out.eks
run_cat $dump1/out.hat
run_cat $dump1/out.pan
run_cat $dump1/out.wye
run_cat $dump1/out.zee

run_mlr put -q '@v=$*; dump >> "'$dump1'/out.".$a' $indir/abixy
run_cat $dump1/out.eks
run_cat $dump1/out.hat
run_cat $dump1/out.pan
run_cat $dump1/out.wye
run_cat $dump1/out.zee

run_mlr put -q '@v=$*; dump | "tr \[a-z\] \[A-Z\]"' $indir/abixy

touch $dump1/err1
run_mlr put -q '@v[NR] = $*; NR == 2 { dump > stdout }' $indir/abixy 2> $dump1/err1
run_cat $dump1/err1

touch $dump1/err2
run_mlr put -q '@v[NR] = $*; NR == 2 { dump > stderr }' $indir/abixy 2> $dump1/err2
run_cat $dump1/err2

# ----------------------------------------------------------------
announce DSL EMITF REDIRECTS

emitf1=$reloutdir/emitf1
mkdir -p $emitf1

run_mlr put -q '@a=$a; @b=$b; emitf > "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
run_cat $emitf1/out.ekspan
run_cat $emitf1/out.ekswye
run_cat $emitf1/out.ekszee
run_cat $emitf1/out.hatwye
run_cat $emitf1/out.panpan
run_cat $emitf1/out.panwye
run_cat $emitf1/out.wyepan
run_cat $emitf1/out.wyewye
run_cat $emitf1/out.zeepan
run_cat $emitf1/out.zeewye

run_mlr put -q '@a=$a; @b=$b; emitf > "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
run_cat $emitf1/out.ekspan
run_cat $emitf1/out.ekswye
run_cat $emitf1/out.ekszee
run_cat $emitf1/out.hatwye
run_cat $emitf1/out.panpan
run_cat $emitf1/out.panwye
run_cat $emitf1/out.wyepan
run_cat $emitf1/out.wyewye
run_cat $emitf1/out.zeepan
run_cat $emitf1/out.zeewye

run_mlr put -q '@a=$a; @b=$b; emitf >> "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
run_cat $emitf1/out.ekspan
run_cat $emitf1/out.ekswye
run_cat $emitf1/out.ekszee
run_cat $emitf1/out.hatwye
run_cat $emitf1/out.panpan
run_cat $emitf1/out.panwye
run_cat $emitf1/out.wyepan
run_cat $emitf1/out.wyewye
run_cat $emitf1/out.zeepan
run_cat $emitf1/out.zeewye

run_mlr put -q -o json '@a=$a; @b=$b; emitf > "'$emitf1'/out.".$a.$b, @a, @b' $indir/abixy
run_cat $emitf1/out.ekspan
run_cat $emitf1/out.ekswye
run_cat $emitf1/out.ekszee
run_cat $emitf1/out.hatwye
run_cat $emitf1/out.panpan
run_cat $emitf1/out.panwye
run_cat $emitf1/out.wyepan
run_cat $emitf1/out.wyewye
run_cat $emitf1/out.zeepan
run_cat $emitf1/out.zeewye

run_mlr put -q '@a=$a; @b=$b; emitf | "tr \[a-z\] \[A-Z\]", @a, @b' $indir/abixy

touch $emitf1/err1
run_mlr put -q '@a=$a; @b=$b; emitf > stdout, @a, @b' $indir/abixy 2> $emitf1/err1
run_cat $emitf1/err1

touch $emitf1/err2
run_mlr put -q '@a=$a; @b=$b; emitf > stderr, @a, @b' $indir/abixy 2> $emitf1/err2
run_cat $emitf1/err2

# ----------------------------------------------------------------
announce DSL EMITP REDIRECTS

emitp1=$reloutdir/emitp1
mkdir -p $emitp1

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp1'/out.".$a.$b, @a' $indir/abixy
run_cat $emitp1/out.ekspan
run_cat $emitp1/out.ekswye
run_cat $emitp1/out.panpan
run_cat $emitp1/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp1'/out.".$a.$b, @a' $indir/abixy
run_cat $emitp1/out.ekspan
run_cat $emitp1/out.ekswye
run_cat $emitp1/out.panpan
run_cat $emitp1/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp1'/out.".$a.$b, @a' $indir/abixy
run_cat $emitp1/out.ekspan
run_cat $emitp1/out.ekswye
run_cat $emitp1/out.panpan
run_cat $emitp1/out.wyewye

run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp1'/out.".$a.$b, @a' $indir/abixy
run_cat $emitp1/out.ekspan
run_cat $emitp1/out.ekswye
run_cat $emitp1/out.panpan
run_cat $emitp1/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @a' $indir/abixy

touch $emitp1/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @a' $indir/abixy 2> $emitp1/err1
run_cat $emitp1/err1

touch $emitp1/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @a' $indir/abixy 2> $emitp1/err2
run_cat $emitp1/err2


emitp2=$reloutdir/emitp2
mkdir -p $emitp2

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emitp2/out.ekspan
run_cat $emitp2/out.ekswye
run_cat $emitp2/out.panpan
run_cat $emitp2/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emitp2/out.ekspan
run_cat $emitp2/out.ekswye
run_cat $emitp2/out.panpan
run_cat $emitp2/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emitp2/out.ekspan
run_cat $emitp2/out.ekswye
run_cat $emitp2/out.panpan
run_cat $emitp2/out.wyewye

run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emitp2/out.ekspan
run_cat $emitp2/out.ekswye
run_cat $emitp2/out.panpan
run_cat $emitp2/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @a, "NR"' $indir/abixy

touch $emitp2/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @a, "NR"' $indir/abixy 2> $emitp2/err1
run_cat $emitp2/err1

touch $emitp2/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @a, "NR"' $indir/abixy 2> $emitp2/err2
run_cat $emitp2/err2


emitp3=$reloutdir/emitp3
mkdir -p $emitp3

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emitp3/out.ekspan
run_cat $emitp3/out.ekswye
run_cat $emitp3/out.panpan
run_cat $emitp3/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emitp3/out.ekspan
run_cat $emitp3/out.ekswye
run_cat $emitp3/out.panpan
run_cat $emitp3/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emitp3/out.ekspan
run_cat $emitp3/out.ekswye
run_cat $emitp3/out.panpan
run_cat $emitp3/out.wyewye

run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emitp3/out.ekspan
run_cat $emitp3/out.ekswye
run_cat $emitp3/out.panpan
run_cat $emitp3/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", (@a, @b)' $indir/abixy

touch $emitp3/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, (@a, @b)' $indir/abixy 2> $emitp3/err1
run_cat $emitp3/err1

touch $emitp3/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, (@a, @b)' $indir/abixy 2> $emitp3/err2
run_cat $emitp3/err2


emitp4=$reloutdir/emitp4
mkdir -p $emitp4

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emitp4/out.ekspan
run_cat $emitp4/out.ekswye
run_cat $emitp4/out.panpan
run_cat $emitp4/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emitp4/out.ekspan
run_cat $emitp4/out.ekswye
run_cat $emitp4/out.panpan
run_cat $emitp4/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp >> "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emitp4/out.ekspan
run_cat $emitp4/out.ekswye
run_cat $emitp4/out.panpan
run_cat $emitp4/out.wyewye

run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emitp4/out.ekspan
run_cat $emitp4/out.ekswye
run_cat $emitp4/out.panpan
run_cat $emitp4/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", (@a, @b), "NR"' $indir/abixy

touch $emitp4/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, (@a, @b), "NR"' $indir/abixy 2> $emitp4/err1
run_cat $emitp4/err1

touch $emitp4/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, (@a, @b), "NR"' $indir/abixy 2> $emitp4/err2
run_cat $emitp4/err2


emitp5=$reloutdir/emitp5
mkdir -p $emitp5
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp5'/out.".$a.$b, @*' $indir/abixy
run_cat $emitp5/out.ekspan
run_cat $emitp5/out.ekswye
run_cat $emitp5/out.panpan
run_cat $emitp5/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @*' $indir/abixy

touch $emitp5/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @*' $indir/abixy 2> $emitp5/err1
run_cat $emitp5/err1

touch $emitp5/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @*' $indir/abixy 2> $emitp5/err2
run_cat $emitp5/err2


emitp6=$reloutdir/emitp6
mkdir -p $emitp6
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp6'/out.".$a.$b, all' $indir/abixy
run_cat $emitp6/out.ekspan
run_cat $emitp6/out.ekswye
run_cat $emitp6/out.panpan
run_cat $emitp6/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", all' $indir/abixy

touch $emitp6/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, all' $indir/abixy 2> $emitp6/err1
run_cat $emitp6/err1

touch $emitp6/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, all' $indir/abixy 2> $emitp6/err2
run_cat $emitp6/err2


emitp7=$reloutdir/emitp7
mkdir -p $emitp7
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp7'/out.".$a.$b, @*, "NR"' $indir/abixy
run_cat $emitp7/out.ekspan
run_cat $emitp7/out.ekswye
run_cat $emitp7/out.panpan
run_cat $emitp7/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", @*, "NR"' $indir/abixy

touch $emitp7/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, @*, "NR"' $indir/abixy 2> $emitp7/err1
run_cat $emitp7/err1

touch $emitp7/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, @*, "NR"' $indir/abixy 2> $emitp7/err2
run_cat $emitp7/err2


emitp8=$reloutdir/emitp8
mkdir -p $emitp8
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > "'$emitp8'/out.".$a.$b, all, "NR"' $indir/abixy
run_cat $emitp8/out.ekspan
run_cat $emitp8/out.ekswye
run_cat $emitp8/out.panpan
run_cat $emitp8/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp | "tr \[a-z\] \[A-Z\]", all, "NR"' $indir/abixy

touch $emitp8/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stdout, all, "NR"' $indir/abixy 2> $emitp8/err1
run_cat $emitp8/err1

touch $emitp8/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emitp > stderr, all, "NR"' $indir/abixy 2> $emitp8/err2
run_cat $emitp8/err2


# ----------------------------------------------------------------
announce DSL EMIT REDIRECTS

emit1=$reloutdir/emit1
mkdir -p $emit1

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit1'/out.".$a.$b, @a' $indir/abixy
run_cat $emit1/out.ekspan
run_cat $emit1/out.ekswye
run_cat $emit1/out.panpan
run_cat $emit1/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit1'/out.".$a.$b, @a' $indir/abixy
run_cat $emit1/out.ekspan
run_cat $emit1/out.ekswye
run_cat $emit1/out.panpan
run_cat $emit1/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit1'/out.".$a.$b, @a' $indir/abixy
run_cat $emit1/out.ekspan
run_cat $emit1/out.ekswye
run_cat $emit1/out.panpan
run_cat $emit1/out.wyewye

run_mlr head -n 4 then put -q -o json '@a[NR]=$a; @b[NR]=$b; emit > "'$emit1'/out.".$a.$b, @a' $indir/abixy
run_cat $emit1/out.ekspan
run_cat $emit1/out.ekswye
run_cat $emit1/out.panpan
run_cat $emit1/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @a' $indir/abixy

touch $emit1/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @a' $indir/abixy 2> $emit1/err1
run_cat $emit1/err1

touch $emit1/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @a' $indir/abixy 2> $emit1/err2
run_cat $emit1/err2


emit2=$reloutdir/emit2
mkdir -p $emit2

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emit2/out.ekspan
run_cat $emit2/out.ekswye
run_cat $emit2/out.panpan
run_cat $emit2/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emit2/out.ekspan
run_cat $emit2/out.ekswye
run_cat $emit2/out.panpan
run_cat $emit2/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emit2/out.ekspan
run_cat $emit2/out.ekswye
run_cat $emit2/out.panpan
run_cat $emit2/out.wyewye

run_mlr head -n 4 then put -q -o pprint '@a[NR]=$a; @b[NR]=$b; emit > "'$emit2'/out.".$a.$b, @a, "NR"' $indir/abixy
run_cat $emit2/out.ekspan
run_cat $emit2/out.ekswye
run_cat $emit2/out.panpan
run_cat $emit2/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @a, "NR"' $indir/abixy

touch $emit2/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @a, "NR"' $indir/abixy 2> $emit2/err1
run_cat $emit2/err1

touch $emit2/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @a, "NR"' $indir/abixy 2> $emit2/err2
run_cat $emit2/err2


emit3=$reloutdir/emit3
mkdir -p $emit3

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emit3/out.ekspan
run_cat $emit3/out.ekswye
run_cat $emit3/out.panpan
run_cat $emit3/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emit3/out.ekspan
run_cat $emit3/out.ekswye
run_cat $emit3/out.panpan
run_cat $emit3/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emit3/out.ekspan
run_cat $emit3/out.ekswye
run_cat $emit3/out.panpan
run_cat $emit3/out.wyewye

run_mlr head -n 4 then put -q --oxtab '@a[NR]=$a; @b[NR]=$b; emit > "'$emit3'/out.".$a.$b, (@a, @b)' $indir/abixy
run_cat $emit3/out.ekspan
run_cat $emit3/out.ekswye
run_cat $emit3/out.panpan
run_cat $emit3/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", (@a, @b)' $indir/abixy

touch $emit3/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, (@a, @b)' $indir/abixy 2> $emit3/err1
run_cat $emit3/err1

touch $emit3/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, (@a, @b)' $indir/abixy 2> $emit3/err2
run_cat $emit3/err2


emit4=$reloutdir/emit4
mkdir -p $emit4

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emit4/out.ekspan
run_cat $emit4/out.ekswye
run_cat $emit4/out.panpan
run_cat $emit4/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emit4/out.ekspan
run_cat $emit4/out.ekswye
run_cat $emit4/out.panpan
run_cat $emit4/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit >> "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emit4/out.ekspan
run_cat $emit4/out.ekswye
run_cat $emit4/out.panpan
run_cat $emit4/out.wyewye

run_mlr head -n 4 then put -q --ojson '@a[NR]=$a; @b[NR]=$b; emit > "'$emit4'/out.".$a.$b, (@a, @b), "NR"' $indir/abixy
run_cat $emit4/out.ekspan
run_cat $emit4/out.ekswye
run_cat $emit4/out.panpan
run_cat $emit4/out.wyewye

run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", (@a, @b), "NR"' $indir/abixy

touch $emit4/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, (@a, @b), "NR"' $indir/abixy 2> $emit4/err1
run_cat $emit4/err1

touch $emit4/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, (@a, @b), "NR"' $indir/abixy 2> $emit4/err2
run_cat $emit4/err2


emit5=$reloutdir/emit5
mkdir -p $emit5
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit5'/out.".$a.$b, @*' $indir/abixy
run_cat $emit5/out.ekspan
run_cat $emit5/out.ekswye
run_cat $emit5/out.panpan
run_cat $emit5/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @*' $indir/abixy

touch $emit5/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @*' $indir/abixy 2> $emit5/err1
run_cat $emit5/err1

touch $emit5/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @*' $indir/abixy 2> $emit5/err2
run_cat $emit5/err2


emit6=$reloutdir/emit6
mkdir -p $emit6
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit6'/out.".$a.$b, all' $indir/abixy
run_cat $emit6/out.ekspan
run_cat $emit6/out.ekswye
run_cat $emit6/out.panpan
run_cat $emit6/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", all' $indir/abixy

touch $emit6/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, all' $indir/abixy 2> $emit6/err1
run_cat $emit6/err1

touch $emit6/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, all' $indir/abixy 2> $emit6/err2
run_cat $emit6/err2


emit7=$reloutdir/emit7
mkdir -p $emit7
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit7'/out.".$a.$b, @*, "NR"' $indir/abixy
run_cat $emit7/out.ekspan
run_cat $emit7/out.ekswye
run_cat $emit7/out.panpan
run_cat $emit7/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", @*, "NR"' $indir/abixy

touch $emit7/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, @*, "NR"' $indir/abixy 2> $emit7/err1
run_cat $emit7/err1

touch $emit7/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, @*, "NR"' $indir/abixy 2> $emit7/err2
run_cat $emit7/err2


emit8=$reloutdir/emit8
mkdir -p $emit8
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > "'$emit8'/out.".$a.$b, all, "NR"' $indir/abixy
run_cat $emit8/out.ekspan
run_cat $emit8/out.ekswye
run_cat $emit8/out.panpan
run_cat $emit8/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", all, "NR"' $indir/abixy

touch $emit8/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, all, "NR"' $indir/abixy 2> $emit8/err1
run_cat $emit8/err1

touch $emit8/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, all, "NR"' $indir/abixy 2> $emit8/err2
run_cat $emit8/err2


emit9=$reloutdir/emit9
mkdir -p $emit9
run_mlr head -n 4 then put -q 'emit > "'$emit9'/out.".$a.$b, $*' $indir/abixy
run_cat $emit9/out.ekspan
run_cat $emit9/out.ekswye
run_cat $emit9/out.panpan
run_cat $emit9/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", $*, "NR"' $indir/abixy

touch $emit9/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, $*, "NR"' $indir/abixy 2> $emit9/err1
run_cat $emit9/err1

touch $emit9/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, $*, "NR"' $indir/abixy 2> $emit9/err2
run_cat $emit9/err2


emit10=$reloutdir/emit10
mkdir -p $emit10
run_mlr head -n 4 then put -q 'emit > "'$emit10'/out.".$a.$b, mapexcept($*, "a", "b")' $indir/abixy
run_cat $emit10/out.ekspan
run_cat $emit10/out.ekswye
run_cat $emit10/out.panpan
run_cat $emit10/out.wyewye
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit | "tr \[a-z\] \[A-Z\]", mapexcept($*, "a", "b"), "NR"' $indir/abixy

touch $emit10/err1
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stdout, mapexcept($*, "a", "b"), "NR"' $indir/abixy 2> $emit10/err1
run_cat $emit10/err1

touch $emit10/err2
run_mlr head -n 4 then put -q '@a[NR]=$a; @b[NR]=$b; emit > stderr, mapexcept($*, "a", "b"), "NR"' $indir/abixy 2> $emit10/err2
run_cat $emit10/err2

# ----------------------------------------------------------------
announce USER-DEFINED FUNCTIONS AND SUBROUTINES

run_mlr --opprint --from $indir/abixy put 'func f(u,v){return u+v} $o=f(NR*1000,$x)'

mlr_expect_fail --opprint --from $indir/abixy put 'func f(x,y,z){$nnn=999; int n=10; return $y} $o=f($i,$x,$y)'

run_mlr --opprint --from $indir/abixy put 'subr s(a,b) { $[a] = b } call s("W", 999)'

run_mlr --opprint --from $indir/abixy put '
  func f(x,y,z) {
    return x + y + z
  }
  subr s(a,b) {
      $[a] = b;
      $DID = "YES";
  }
  $o = f($x, $y, $i);
  call s("W", NR);
'

run_mlr --opprint --from $indir/abixy put '
  func f(x,y,z) {
    return x + y + z
  }
  subr s(a,b) {
      $[a] = b;
      return;
      $DID = "YES";
  }
  $o = f($x, $y, $i);
  call s("W", NR);
'

mlr_expect_fail --from $indir/abixy put '
  func f(x,y,z) {
    return x + y + z
  }
  subr s(a,b) {
      $[a] = b;
      return 1 # subr must not return value
  }
  $o = f($x, $y, $i);
  call s("W", NR);
'

mlr_expect_fail --from $indir/abixy put '
  func f(x,y,z) {
    return # func must return value
  }
  subr s(a,b) {
      $[a] = b;
  }
  $o = f($x, $y, $i);
  call s("W", NR);
'

# Test fencing: function f should not have access to boundvar k from the callsite.
run_mlr --from $indir/abixy --opprint put 'func f(x) {return k} for (k,v in $*) {$o=f($x)}'
run_mlr --from $indir/abixy --opprint put 'subr foo() {print "k is [".k."]"} for (k,v in $*) {call foo()}'

# Test overriding built-ins
mlr_expect_fail --opprint --from $indir/abixy put 'func log(x) { return 0 } $o = log($x)'

run_mlr --from $indir/abixy put 'subr log() { print "hello record  ". NR } call log()'

# Test variable-clear at scope exit; test read of unset locals.
run_mlr --opprint --from $indir/abixy put '$o1 = a; int a=1000+NR; $o2 = a; a=2000+NR; $o3 = a'

# Test recursion
run_mlr --opprint --from $indir/abixy put '
    func f(n) {
        if (is_numeric(n)) {
            if (n > 0) {
                return n * f(n-1)
            } else {
                return 1
            }
        }
        # implicitly return absent
    }
    $o = f(NR)
'

run_mlr --opprint --from $indir/abixy head -n 5 then put '
    subr s(n) {
        print "n = " . n;
        if (is_numeric(n)) {
            if (n > 0) {
                call s(n-1)
            }
        }
    }
    print "";
    call s(NR)
'

run_mlr --from $indir/abixy --opprint put '
  func f(n) {
    return n+1;
  }
  $o1 = f(NR);
  $o2 = f(f(NR));
  $o3 = f(f(f(NR)));
  $o4 = f(f(f(f(NR))));
  $o5 = f(f(f(f(f(NR)))));
  $o6 = f(f(f(f(f(f(NR))))));
'

run_mlr --from $indir/abixy --opprint put '
  func f(n) {
      if (n < 2) {
          return 1
      } else {
          return f(n-1) + f(n-2)
      }
  }
  $o = f(NR)
'

run_mlr --from $indir/abixy --opprint put '
  func f(n) {
    if (is_present(@fcache[n])) {
      return @fcache[n]
    } else {
      num rv = 1;
      if (n >= 2) {
        rv = f(n-1) + f(n-2)
      }
      @fcache[n] = rv;
      return rv
    }
  }
  $o = f(NR)
'

# No nesting of top-levels
mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { begin {} }'
mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { end {} }'
mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { begin {} }'
mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { end {} }'

mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { func g(y) {} }'
mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { subr t(y) {} }'
mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { func g(y) {} }'
mlr_expect_fail --from $indir/abixy --opprint put 'subr s(x) { subr t(y) {} }'

mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { begin {} }; true'
mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { end {} }; true'
mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { begin {} }; true'
mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { end {} }; true'

mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { func g(y) {} }; true'
mlr_expect_fail --from $indir/abixy --opprint filter 'func f(x) { subr t(y) {} }; true'
mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { func g(y) {} }; true'
mlr_expect_fail --from $indir/abixy --opprint filter 'subr s(x) { subr t(y) {} }; true'

# Disallow redefines
mlr_expect_fail --from $indir/abixy --opprint put 'func log(x) { return $x + 1 }'
mlr_expect_fail --from $indir/abixy --opprint put 'func f(x) { return $x + 1 } func f(x) { return $x + 1}'
mlr_expect_fail --from $indir/abixy --opprint put 'subr s() { } subr s() { }'
mlr_expect_fail --from $indir/abixy --opprint put 'subr s() { } subr s(x) { }'
run_mlr --from $indir/abixy --opprint put 'subr log(text) { print "TEXT IS ".text } call log("NR is ".NR)'

# print/dump from subr/func;  no tee/emit from func
run_mlr --from $indir/abixy --opprint put 'subr log(text) { print "TEXT IS ".text } call log("NR is ".NR)'
run_mlr --from $indir/abixy --opprint put 'func f(text) { print "TEXT IS ".text; return text.text } $o = f($a)'
run_mlr --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"                 } $o=f($i)'
mlr_expect_fail --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"; tee  > "x", $* } $o=f($i)'
mlr_expect_fail --from $indir/abixy put 'begin{@x=1} func f(x) { dump; print "hello"; emit > "x", @* } $o=f($i)' 

# not use all args (for valgrind)
run_mlr --from $indir/abixy put 'func f(x,y) { return 2*y } $o = f($x,$y) '

# general programming-language stuff
run_mlr -n put -q -f $indir/sieve.mlr
run_mlr -n put -q -f $indir/mand.mlr -e 'begin {@verbose = true}'

# scoping within distinct begin/end blocks
run_mlr --from $indir/abixy put -v '
    func f(x) {
        return x**2
    }
    func g(y) {
        return y+1
    }
    subr s(a,b,c) {
        print a.b.c
    }
    begin {
        @a = 0;
        var ell = 1;
        print "local1 = ".ell;
    }
    end {
        emit @a;
        var emm = 2;
        print "local2 = ".emm;
    }
    @a += 1;
    begin {
        @b = 0;
        @c = 0;
        print "local3 = ".ell;
    }
    @b += 2;
    @c += 3;
    end {
        emit @b;
        emit @c;
        print "local4 = ".emm;
    }
'

# ----------------------------------------------------------------
announce LOCALVAR SCOPE AND EXTENT

run_mlr --opprint --from $indir/abixy put '
  func f() {
    var a = 1;
    if (NR > 5) {
      a = 2;
    }
    return a;
  }
  func g() {
    var b = 1;
    if (NR > 5) {
      var b = 2;
    }
    return b;
  }
  func h() {
    var a = 1;
    if (NR > 5) {
      a = 2;
      return a;
    }
    return a;
  }
  func i() {
    var b = 1;
    if (NR > 5) {
      var b = 2;
      return b;
    }
    return b;
  }
  $of = f();
  $og = g();
  $oh = h();
  $oi = i();
 '

# test fencing at function entry
run_mlr --opprint --from $indir/abixy put '
  func f() {
    var a = 2;
    var b = 2;
    if (NR > 5) {
      var a = 3;
      b = 3;
    }
    return 1000 * a + b;
  }
  a = 1;
  b = 1;
  $ab = f();
  $oa = a;
  $ob = b;
 '

# ----------------------------------------------------------------
announce LOCALVAR UNSETS

run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset s      ; dump s; dump t; dump u' $indir/unset1.dkvp

run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset t      ; dump s; dump t; dump u' $indir/unset1.dkvp
run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset t[1]   ; dump s; dump t; dump u' $indir/unset1.dkvp

run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset u      ; dump s; dump t; dump u' $indir/unset1.dkvp
run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset u[1]   ; dump s; dump t; dump u' $indir/unset1.dkvp
run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset u[1][2]; dump s; dump t; dump u' $indir/unset1.dkvp

run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset s      ; dump s; dump t; dump u' $indir/unset4.dkvp

run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset t      ; dump s; dump t; dump u' $indir/unset4.dkvp
run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset t[1]   ; dump s; dump t; dump u' $indir/unset4.dkvp

run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset u      ; dump s; dump t; dump u' $indir/unset4.dkvp
run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset u[1]   ; dump s; dump t; dump u' $indir/unset4.dkvp
run_mlr put -q 's=$x; t[$a]=$x; u[$a][$b]=$x; dump s; dump t; dump u; unset u[1][2]; dump s; dump t; dump u' $indir/unset4.dkvp

# ----------------------------------------------------------------
announce LOCALVAR TYPEDECLs

run_mlr --from $indir/abixy put '
  str a = $a;
  a = "a:".NR;
  $c = a;
'

mlr_expect_fail --from $indir/abixy put '
  str a = $a;
  a = NR;
  $c = a;
'

mlr_expect_fail --from $indir/abixy put '
  int a = $a;
  a = NR;
  $c = a;
'

run_mlr --from $indir/abixy put '
  int i = $i;
  i = NR;
  $c = a;
'

# ----------------------------------------------------------------
announce FORBIND TYPEDECLs

run_mlr --from $indir/abixy put '
  for (int i = 0; i < $i; i += 1) {
    $c = i * 10;
  }
'

mlr_expect_fail --from $indir/abixy put '
  for (float i = 0; i < $i; i += 1) {
    $c = i * 10;
  }
'

run_mlr --from $indir/abixy put '
  for (int i = 0; i < $i; i += 1) {
    i += 2;
    $c = i;
  }
'

mlr_expect_fail --from $indir/abixy put '
  for (int i = 0; i < $i; i += 1) {
    i += 1.5;
    $c = i;
  }
'

mlr_expect_fail --from $indir/abixy put '
  for (int i = 0; i < $i; i += 1) {
    i += 1.0;
    $c = i;
  }
'

run_mlr --from $indir/abixy put '
  for (num i = 0; i < $i; i += 1) {
    i += 1.0;
    $c = i;
  }
'

# ----------------------------------------------------------------
announce ARGPASS TYPEDECLs

run_mlr --from $indir/abixy put '
  func f(int i) {
    return i+3;
  }
  $c = f($i);
'

mlr_expect_fail --from $indir/abixy put '
  func f(int i) {
    return i+3;
  }
  $c = f($x);
'

mlr_expect_fail --from $indir/abixy put '
  func f(num i): int {
    return i+3.45;
  }
  $c = f($x);
'

mlr_expect_fail --from $indir/abixy put '
  func f(num i): int {
    return i+3.45;
  }
  $c = f($i);
'

mlr_expect_fail --from $indir/abixy put '
  func f(num i): int {
    i = "a";
    return 2;
  }
  $c = f($x);
'


run_mlr --from $indir/abixy put '
  subr s(int i) {
    print i+3;
  }
  call s($i);
'

mlr_expect_fail --from $indir/abixy put '
  subr s(int i) {
    print i+3;
  }
  call s($x);
'

mlr_expect_fail --from $indir/abixy put '
  subr s(num i) {
    i = "a";
    print 2;
  }
  call s($x);
'

# ----------------------------------------------------------------
announce LOCAL MAP-VARIABLE WRITE/READ

run_mlr --from $indir/xyz345 put -v -a '
    $s = a;
    $t = b[$x];
    $u = c[$x][$y];
    $v = d[$x][$y][$z];
'

run_mlr --from $indir/xyz345 put -v -a '
    d[$x][$y][$z] = 9;
    $d = d[$x][$y][$z];
'

run_mlr --from $indir/xyz345 put -v -a '
    a = 6;
    b[$x] = 7;
    c[$x][$y] = 8;
    d[$x][$y][$z] = 9;

    $a = a;
    $b = b[$x];
    $c = c[$x][$y];
    $d = d[$x][$y][$z];
'

run_mlr --from $indir/xyz345 put -v -a '
    a = 6;
    b[$x] = 7;
    c[$x][$y] = 8;
    d[$x][$y][$z] = 9;

    $a0 = a;
    $a1 = a[$x];
    $a2 = a[$x][$y];
    $a3 = a[$x][$y][$z];

    $b0 = b;
    $b1 = b[$x];
    $b2 = b[$x][$y];
    $b3 = b[$x][$y][$z];

    $c0 = c;
    $c1 = c[$x];
    $c2 = c[$x][$y];
    $c3 = c[$x][$y][$z];

    $d0 = d;
    $d1 = d[$x];
    $d2 = d[$x][$y];
    $d3 = d[$x][$y][$z];
'

# ----------------------------------------------------------------
announce LOCAL MAP-VARIABLE TYPE-DECL

run_mlr --from $indir/xyz345 put '
    map a = {};
'

run_mlr --from $indir/xyz345 put '
    map a = {};
    a[1]=2;
    a[3][4]=5;
'

mlr_expect_fail --from $indir/xyz345 put '
    map a = {};
    a=2;
    a[3][4]=5;
'

mlr_expect_fail --from $indir/xyz345 put '
    map a = {};
    a[3][4]=5;
    a=2;
'

# ----------------------------------------------------------------
announce TRIPLE-FORs

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  num a = 1;
  for (;;) {
    if (a > NR) {
        break;
    }
    sum += a;
    a += 1
  }
  $z = sum
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  num a = 1;
  for (;;) {
    if (a > NR) {
        break;
    }
    sum += a;
    a += 1
  }
  $z = sum
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  for (num a = 1; ;) {
    if (a > NR) {
        break;
    }
    sum += a;
    a += 1
  }
  $z = sum
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  num a = 1;
  for (; ; a += 1) {
    if (a > NR) {
        break;
    }
    sum += a;
  }
  $z = sum
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  for (num a=1; ; a += 1) {
    if (a > NR) {
        break;
    }
    sum += a;
  }
  $z = sum
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  for (num a=1; a <= NR; a += 1) {
    sum += a;
  }
  $z = sum
'

echo x=1 | run_mlr put '
  num a = 100;
  num b = 100;
  for (num a = 200, b = 300; a <= 210; a += 1, b += 1) {
    print "a:".a.",b:".b
  }
  $oa = a;
  $ob = b;
'

run_mlr --from $indir/abixy put '
  for ( ; $x <= 10; $x += 1) {
  }
'

run_mlr --opprint --from $indir/abixy put '
  num a = 100;
  b  = 200;
  @c = 300;
  $d = 400;
  for (num i = 1; i < 1024; i *= 2) {
    a  += 1;
    b  += 1;
    @c += 1;
    $d += 1;
    $oa = a;
    $ob = b;
    $oc = @c;
    $od = $d;
  }
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  for (num a = 1; a <= 10; a += 1) {
    continue;
    sum += a;
  }
  $z = sum
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  for (num a = 1; a <= 10; a += 1) {
    sum += a;
    break;
  }
  $z = sum
'

run_mlr --opprint --from $indir/abixy put '
  num sum = 0;
  for (num a = 1; a <= NR; a += 1) {
    if (a == 4 || a == 5) {
      continue;
    }
    if (a == 8) {
        break;
    }
    sum += a;
  }
  $z = sum
'

# Multi-continutation cases

run_mlr --opprint --from $indir/abixy put '
    for ($o1 = 1; ; $o3 = 3) {
        break;
    }
'

run_mlr --opprint --from $indir/abixy put '
    for ($o1 = 1; $o1 < NR; $o1 += 1) {
    }
'

mlr_expect_fail --opprint --from $indir/abixy put '
    for ($o1 = 1, $o2 = 2; $o3 = 3; $o4 = 4) {
    }
'

mlr_expect_fail --opprint --from $indir/abixy put '
    for ($o1 = 1, $o2 = 2; $o3 < 3, $o4 = 4; $o5 = 5) {
        break;
    }
'

run_mlr --opprint --from $indir/abixy put '
    $o4 = 0;
    for ($o1 = 1, $o2 = 2; $o3 = 3, $o4 < 4; $o5 = 5) {
        break;
    }
'

# ----------------------------------------------------------------
announce MAPVARS IN SCALAR FUNCTION-CALL CONTEXTS

mlr_expect_fail --from $indir/abixy put '$z=strlen($*)'
mlr_expect_fail --from $indir/abixy put '$z=strlen({})'
run_mlr --from $indir/abixy put 'a={}; $z=strlen(a)'

# ----------------------------------------------------------------
announce MAPVAR ASSIGNMENTS TO FULL SREC

run_mlr --from $indir/xyz2 put '$* = {"a":1, "b": {"x":8,"y":9}, "c":3}'
run_mlr --from $indir/xyz2 put '$* = $*'
run_mlr --from $indir/xyz2 put '@a = 1; $* = @a'
run_mlr --from $indir/xyz2 put '@b[1] = 2; $* = @b'
run_mlr --from $indir/xyz2 put '@c[1][2] = 3; $* = @c'
run_mlr --from $indir/xyz2 put '@a = 1; $* = @*'
run_mlr --from $indir/xyz2 put '@b[1] = 2; $* = @*'
run_mlr --from $indir/xyz2 put '@c[1][2] = 3; $* = @*'
run_mlr --from $indir/xyz2 put 'a = 1; $* = a'
run_mlr --from $indir/xyz2 put 'b[1] = 2; $* = b'
run_mlr --from $indir/xyz2 put 'c[1][2] = 3; $* = c'
run_mlr --from $indir/xyz2 put '$* = 3'

run_mlr --from $indir/xyz2 put '
  func map_valued_func() {
    return {"a":1,"b":2}
  }
  map m = map_valued_func();
  $* = m;
'

run_mlr --from $indir/xyz2 put '
  func map_valued_func() {
    return {"a":1,"b":2}
  }
  $* = map_valued_func();
'

# ----------------------------------------------------------------
announce MAPVAR ASSIGNMENTS TO FULL OOSVAR

run_mlr --from $indir/xyz2 put '@* = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump'
run_mlr --from $indir/xyz2 put '@* = $*; dump'
run_mlr --from $indir/xyz2 put '@* = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump; @* = @*; dump'
run_mlr --from $indir/xyz2 put '@a = 1; @* = @a; dump'
run_mlr --from $indir/xyz2 put '@b[1] = 2; @* = @b; dump'
run_mlr --from $indir/xyz2 put '@c[1][2] = 3; @* = @c; dump'
run_mlr --from $indir/xyz2 put '@a = 1; @* = @*; dump'
run_mlr --from $indir/xyz2 put '@b[1] = 2; @* = @*; dump'
run_mlr --from $indir/xyz2 put '@c[1][2] = 3; @* = @*; dump'
run_mlr --from $indir/xyz2 put 'a = 1; @* = a; dump'
run_mlr --from $indir/xyz2 put 'b[1] = 2; @* = b; dump'
run_mlr --from $indir/xyz2 put 'c[1][2] = 3; @* = c; dump'
run_mlr --from $indir/xyz2 put '@* = 3'

run_mlr --from $indir/xyz2 put '
  func map_valued_func() {
    return {"a":1,"b":2}
  }
  map m = map_valued_func();
  @* = m;
  dump
'

run_mlr --from $indir/xyz2 put '
  func map_valued_func() {
    return {"a":1,"b":2}
  }
  @* = map_valued_func();
  dump
'

# ----------------------------------------------------------------
announce MAPVAR ASSIGNMENTS TO OOSVAR

run_mlr --from $indir/xyz2 put -q '@o = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump @o'
run_mlr --from $indir/xyz2 put -q '@o = @o; dump @o'
run_mlr --from $indir/xyz2 put -q '@o = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump; @o = @*; dump'
run_mlr --from $indir/xyz2 put -q '@o = $*; dump @o'
run_mlr --from $indir/xyz2 put -q '@o = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump @o; @o = @o; dump @o'
run_mlr --from $indir/xyz2 put -q '@o = {"a":1, "b": {"x":8,"y":9}, "c":3}; @o = @o; dump @o'
run_mlr --from $indir/xyz2 put -q '@a = 1; @o = @a; dump @o'
run_mlr --from $indir/xyz2 put -q '@b[1] = 2; @o = @b; dump @o'
run_mlr --from $indir/xyz2 put -q '@c[1][2] = 3; @o = @c; dump @o'
run_mlr --from $indir/xyz2 put -q '@a = 1; @o = @*; dump @o'
run_mlr --from $indir/xyz2 put -q '@b[1] = 2; @o = @*; dump @o'
run_mlr --from $indir/xyz2 put -q '@c[1][2] = 3; @o = @*; dump @o'
run_mlr --from $indir/xyz2 put -q 'a = 1; @o = a; dump @o'
run_mlr --from $indir/xyz2 put -q 'b[1] = 2; @o = b; dump @o'
run_mlr --from $indir/xyz2 put -q 'c[1][2] = 3; @o = c; dump @o'
run_mlr --from $indir/xyz2 put -q 'func map_valued_func() { return {"a":1,"b":2}} @o = map_valued_func(); dump @o'

# ----------------------------------------------------------------
announce MAPVAR ASSIGNMENTS TO MAP-TYPED LOCAL

run_mlr         --from $indir/xyz2 put -q 'map o = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump o'
mlr_expect_fail --from $indir/xyz2 put -q 'map o = @o; dump o'
run_mlr         --from $indir/xyz2 put -q 'map o = $*; dump o'
run_mlr         --from $indir/xyz2 put -q 'map o = {"a":1, "b": {"x":8,"y":9}, "c":3}; o = o; dump o'
mlr_expect_fail --from $indir/xyz2 put -q '@a = 1; map o = @a; dump o'
run_mlr         --from $indir/xyz2 put -q '@b[1] = 2; map o = @b; dump o'
run_mlr         --from $indir/xyz2 put -q '@c[1][2] = 3; map o = @c; dump o'
run_mlr         --from $indir/xyz2 put -q '@a = 1; map o = @*; dump o'
run_mlr         --from $indir/xyz2 put -q '@b[1] = 2; map o = @*; dump o'
run_mlr         --from $indir/xyz2 put -q '@c[1][2] = 3; map o = @*; dump o'
mlr_expect_fail --from $indir/xyz2 put -q 'a = 1; map o = a; dump o'
run_mlr         --from $indir/xyz2 put -q 'b[1] = 2; map o = b; dump o'
run_mlr         --from $indir/xyz2 put -q 'c[1][2] = 3; map o = c; dump o'
run_mlr --from $indir/xyz2 put -q 'func map_valued_func() { return {"a":1,"b":2}} map o = map_valued_func(); dump o'

# ----------------------------------------------------------------
announce MAPVAR ASSIGNMENTS TO VAR-TYPED LOCAL

run_mlr --from $indir/xyz2 put -q 'var o = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump o'
run_mlr --from $indir/xyz2 put -q 'var o = @o; dump o'
run_mlr --from $indir/xyz2 put -q 'var o = $*; dump o'
run_mlr --from $indir/xyz2 put -q 'var o = {"a":1, "b": {"x":8,"y":9}, "c":3}; o = o; dump o'
run_mlr --from $indir/xyz2 put -q '@a = 1; var o = @a; dump o'
run_mlr --from $indir/xyz2 put -q '@b[1] = 2; var o = @b; dump o'
run_mlr --from $indir/xyz2 put -q '@c[1][2] = 3; var o = @c; dump o'
run_mlr --from $indir/xyz2 put -q '@a = 1; var o = @*; dump o'
run_mlr --from $indir/xyz2 put -q '@b[1] = 2; var o = @*; dump o'
run_mlr --from $indir/xyz2 put -q '@c[1][2] = 3; var o = @*; dump o'
run_mlr --from $indir/xyz2 put -q 'a = 1; var o = a; dump o'
run_mlr --from $indir/xyz2 put -q 'b[1] = 2; var o = b; dump o'
run_mlr --from $indir/xyz2 put -q 'c[1][2] = 3; var o = c; dump o'
run_mlr --from $indir/xyz2 put -q 'func map_valued_func() { return {"a":1,"b":2}} var o = map_valued_func(); dump o'

# ----------------------------------------------------------------
announce MAPVAR ASSIGNMENTS TO UNTYPED LOCAL

run_mlr --from $indir/xyz2 put -q 'o = {"a":1, "b": {"x":8,"y":9}, "c":3}; dump o'
run_mlr --from $indir/xyz2 put -q 'o = @o; dump o'
run_mlr --from $indir/xyz2 put -q 'o = $*; dump o'
run_mlr --from $indir/xyz2 put -q 'o = {"a":1, "b": {"x":8,"y":9}, "c":3}; o = o; dump o'
run_mlr --from $indir/xyz2 put -q '@a = 1; o = @a; dump o'
run_mlr --from $indir/xyz2 put -q '@b[1] = 2; o = @b; dump o'
run_mlr --from $indir/xyz2 put -q '@c[1][2] = 3; o = @c; dump o'
run_mlr --from $indir/xyz2 put -q '@a = 1; o = @*; dump o'
run_mlr --from $indir/xyz2 put -q '@b[1] = 2; o = @*; dump o'
run_mlr --from $indir/xyz2 put -q '@c[1][2] = 3; o = @*; dump o'
run_mlr --from $indir/xyz2 put -q 'a = 1; o = a; dump o'
run_mlr --from $indir/xyz2 put -q 'b[1] = 2; o = b; dump o'
run_mlr --from $indir/xyz2 put -q 'c[1][2] = 3; o = c; dump o'
run_mlr --from $indir/xyz2 put -q 'func map_valued_func() { return {"a":1,"b":2}} o = map_valued_func(); dump o'

# ----------------------------------------------------------------
announce SPLIT/JOIN

run_mlr --from $indir/abixy-het put -q 'o = joink($*, ":"); print o'
run_mlr --from $indir/abixy-het put -q 'o = joinv($*, ":"); print o'
run_mlr --from $indir/abixy-het put -q 'o = joinkv($*, ":", ";"); print o'

run_mlr --from $indir/abixy-het put -q 'o = joink({1:2,  "abc":4, 5:"xyz"}, ":"); print o'
run_mlr --from $indir/abixy-het put -q 'o = joinv({1:2,  "abc":4, 5:"xyz"}, ":"); print o'
run_mlr --from $indir/abixy-het put -q 'o = joinkv({1:2, "abc":4, 5:"xyz"}, ":", ";"); print o'

run_mlr --from $indir/abixy-het put '$* = splitnv("a,b,c" , ","); for (k,v in $*) { print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitkv("a=1,b=2,c", "=", ","); for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitnv("a,b,c", IFS); print ">>".IRS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitkv("a=1,b=2,c", IPS, IFS); print ">>".IRS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitnv("a,b,c", OFS); print ">>".ORS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitkv("a=1,b=2,c", OPS, OFS); print ">>".ORS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'

run_mlr --from $indir/abixy-het put '$* = splitnvx("a,b,c" , ","); for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitkvx("a=1,b=2,c", "=", ","); for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitnvx("a,b,c", IFS); print ">>".IRS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitkvx("a=1,b=2,c", IPS, IFS); print ">>".IRS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitnvx("a,b,c", OFS); print ">>".ORS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --from $indir/abixy-het put '$* = splitkvx("a=1,b=2,c", OPS, OFS); print ">>".ORS."<<"; for (k, v in $*) {print k.":".typeof(k)." ".v.":".typeof(v)}'

run_mlr --oxtab --from $indir/abixy-het put 's = joink($*, ":"); $* = splitnv(s, ":")'
run_mlr --oxtab --from $indir/abixy-het put 's = joinv($*, ":"); $* = splitnv(s, ":")'
run_mlr --oxtab --from $indir/abixy-het put 's = joinkv($*, ":", ";"); $* = splitkv(s, ":", ";"); for (k,v in $*) { print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --oxtab --from $indir/abixy-het put 's = joinkv($*, ":", ";"); $* = splitkvx(s, ":", ";"); for (k,v in $*) { print k.":".typeof(k)." ".v.":".typeof(v)}'

run_mlr --oxtab --from $indir/abixy-het put 's = joink({1:2, "abc":4, 5:"xyz"}, ":"); $* = splitnv(s, ":")'
run_mlr --oxtab --from $indir/abixy-het put 's = joinv({1:2, "abc":4, 5:"xyz"}, ":"); $* = splitnv(s, ":")'
run_mlr --oxtab --from $indir/abixy-het put 's = joinkv({1:2, "abc":4, 5:"xyz"}, ":", ";"); $* = splitkv(s, ":", ";"); for (k,v in $*) { print k.":".typeof(k)." ".v.":".typeof(v)}'
run_mlr --oxtab --from $indir/abixy-het put 's = joinkv({1:2, "abc":4, 5:"xyz"}, ":", ";"); $* = splitkvx(s, ":", ";"); for (k,v in $*) { print k.":".typeof(k)." ".v.":".typeof(v)}'

# ----------------------------------------------------------------
announce MAPSUM/MAPDIFF/MAPEXCEPT

run_mlr --from $indir/abixy-het put -q 'o = mapsum(); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapdiff(); dump o'
mlr_expect_fail --from $indir/abixy-het put -q 'o = mapexcept(); dump o'
mlr_expect_fail --from $indir/abixy-het put -q 'o = mapselect(); dump o'

run_mlr --from $indir/abixy-het put -q 'o = mapsum($*); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapsum({"a":999}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapdiff($*); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapdiff({"a":999}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapexcept($*); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapexcept({"a":999}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect($*); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect({"a":999}); dump o'

run_mlr --from $indir/abixy-het put -q 'o = mapsum($*, {"a":999}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapsum({"a":999}, $*); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapdiff($*, {"a":999}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapdiff({"a":999}, $*); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapexcept($*, "a"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapexcept({"a":999}, "a"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapexcept({"a":999}, "nonesuch"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect($*, "a"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect({"a":999}, "a"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect({"a":999}, "nonesuch"); dump o'

run_mlr --from $indir/abixy-het put -q 'o = mapsum($*, {"a":999}, {"b": 444}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapsum({"a":999}, $*, {"b": 444}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapdiff($*, {"a":999}, {"b": 444}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapdiff({"a":999}, $*, {"b": 444}); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapexcept($*, "a", "b"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect({"a":999}, "b", "nonesuch"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect($*, "a", "b"); dump o'
run_mlr --from $indir/abixy-het put -q 'o = mapselect({"a":999}, "b", "nonesuch"); dump o'

# ----------------------------------------------------------------
announce EXTENDED TYPEOF

run_mlr --from $indir/xyz2 --oxtab put '
  a = {1:2, 3:4};
  b = {1: {2:3, 4:5}};
  @c = {1:2, 3:4};
  @d = {1: {2:3, 4:5}};

  $ta  = typeof(a);
  $ta1 = typeof(a[1]);
  $ta7 = typeof(a[7]);

  $tb  = typeof(b);
  $tb1 = typeof(b[1]);
  $tb7 = typeof(b[7]);

  $tc  = typeof(@c);
  $tc1 = typeof(@c[1]);
  $tc7 = typeof(@c[7]);

  $td  = typeof(@d);
  $td1 = typeof(@d[1]);
  $td7 = typeof(@d[7]);

  $te1 = typeof(6);
  $te2 = typeof({6:4});

  $tsa = typeof($a);
  $tsx = typeof($x);
  $ts  = typeof($*);
'

# ----------------------------------------------------------------
announce HASKEY

run_mlr --from $indir/abixy-het put '$haskeya = haskey($*, "a")'
run_mlr --from $indir/abixy-het put '$haskey3 = haskey($*, 3)'

run_mlr --from $indir/xyz2 put '$haskeya = haskey({3:4}, "a")'
run_mlr --from $indir/xyz2 put '$haskey3 = haskey({3:4}, 3)'
run_mlr --from $indir/xyz2 put '$haskey3 = haskey({3:4}, 4)'

run_mlr --from $indir/xyz2 put 'o = {3:4}; $haskeya = haskey(o, "a")'
run_mlr --from $indir/xyz2 put 'o = {3:4}; $haskey3 = haskey(o, 3)'
run_mlr --from $indir/xyz2 put 'o = {3:4}; $haskey3 = haskey(o, 4)'

run_mlr --from $indir/xyz2 put '@o = {3:4}; $haskeya = haskey(@o, "a")'
run_mlr --from $indir/xyz2 put '@o = {3:4}; $haskey3 = haskey(@o, 3)'
run_mlr --from $indir/xyz2 put '@o = {3:4}; $haskey3 = haskey(@o, 4)'

run_mlr --from $indir/xyz2 put 'o = "3:4"; $haskeya = haskey(@o, "a")'
run_mlr --from $indir/xyz2 put 'o = "3:4"; $haskey3 = haskey(@o, 3)'
run_mlr --from $indir/xyz2 put 'o = "3:4"; $haskey3 = haskey(@o, 4)'

# ----------------------------------------------------------------
announce LENGTH/DEPTH/LEAFCOUNT

run_mlr --from $indir/abixy-het put '$length = length($a)'
run_mlr --from $indir/abixy-het put '$length = length($*)'
run_mlr --from $indir/xyz2 put '$length= length({3:4, 5:{6:7}, 8:{9:{10:11}}})'
run_mlr --from $indir/xyz2 put 'o = {3:4, 5:{6:7}, 8:{9:{10:11}}}; $length = length(o)'
run_mlr --from $indir/xyz2 put '@o = {3:4, 5:{6:7}, 8:{9:{10:11}}}; $length = length(@o)'

run_mlr --from $indir/abixy-het put '$depth = depth($a)'
run_mlr --from $indir/abixy-het put '$depth = depth($*)'
run_mlr --from $indir/xyz2 put '$depth= depth({3:4, 5:{6:7}, 8:{9:{10:11}}})'
run_mlr --from $indir/xyz2 put 'o = {3:4, 5:{6:7}, 8:{9:{10:11}}}; $depth = depth(o)'
run_mlr --from $indir/xyz2 put '@o = {3:4, 5:{6:7}, 8:{9:{10:11}}}; $depth = depth(@o)'

run_mlr --from $indir/abixy-het put '$leafcount = leafcount($a)'
run_mlr --from $indir/abixy-het put '$leafcount = leafcount($*)'
run_mlr --from $indir/xyz2 put '$leafcount= leafcount({3:4, 5:{6:7}, 8:{9:{10:11}}})'
run_mlr --from $indir/xyz2 put 'o = {3:4, 5:{6:7}, 8:{9:{10:11}}}; $leafcount = leafcount(o)'
run_mlr --from $indir/xyz2 put '@o = {3:4, 5:{6:7}, 8:{9:{10:11}}}; $leafcount = leafcount(@o)'

# xxx ternary operator (and most RHS expressions in the grammar) doesn't handle maps.
# run_mlr --from $indir/abixy-het put -q 'o = haskey(NR==4 ? {"a": NF} : {"b": NF}, "a"); print "NR=".NR.",haskeya=".o'

# ----------------------------------------------------------------
announce MAPVAR EMIT

run_mlr -n put 'end {
  @a[2][3] = 4;
  b[2][3] = 8;
  emit  (@a, b, {2:{3:12}});
  emitp (@a, b, {2:{3:12}});
  emit {};
  emit  (@a, b, {2:{3:12}}), "t";
  emitp (@a, b, {2:{3:12}}), "t";
  emit {};
  emit  (@a, b, {2:{3:12}}), "t", "u";
  emitp (@a, b, {2:{3:12}}), "t", "u";
}'

run_mlr -n put 'end {
  @a[2][3] = 4;
  b[2][3] = 8;
  emitp (@a, b, {2:{3:12}});
  emit  (@a, b, {2:{3:12}});
  emit {};
  emitp (@a, b, {2:{3:12}}), "t";
  emit  (@a, b, {2:{3:12}}), "t";
  emit {};
  emitp (@a, b, {2:{3:12}}), "t", "u";
  emit  (@a, b, {2:{3:12}}), "t", "u";
}'

# ----------------------------------------------------------------
announce MAPVAR FOR-LOOPS

run_mlr --from $indir/abixy put -q '
  func f() {
    return {
      "a:".$a: $i,
      "b:".$b: $y,
      NR: NF,
    }
  }
  for (k,v in f()) {
    print "k=".k;
    print "v=".v;
  }
  print
'

# ----------------------------------------------------------------
announce TRAILING COMMAS

run_mlr --from $indir/abixy put '
  $* = {
    "a": $a,
    "x": $x,
  }
'

run_mlr         --from $indir/xyz345 put 'func f(): int { return 999 } $y=f()'
mlr_expect_fail --from $indir/xyz345 put 'func f(): int { return 999 } $y=f(,)'

run_mlr         --from $indir/xyz345 put 'func f(a,):  int { return a*2 } $y=f(NR)'
mlr_expect_fail --from $indir/xyz345 put 'func f(a,,): int { return a*2 } $y=f(NR)'

run_mlr         --from $indir/xyz345 put 'func f(int a,):  int { return a*2 } $y=f(NR)'
mlr_expect_fail --from $indir/xyz345 put 'func f(int a,,): int { return a*2 } $y=f(NR)'

run_mlr         --from $indir/xyz345 put 'subr s()      { print 999  } call s()'
mlr_expect_fail --from $indir/xyz345 put 'subr s()      { print 999  } call s(,)'

run_mlr         --from $indir/xyz345 put 'subr s(a,)   { print a*2 } call s(NR)'
mlr_expect_fail --from $indir/xyz345 put 'subr s(a,,)  { print a*2 } call s(NR)'

run_mlr         --from $indir/xyz345 put 'subr s(int a,)   { print a*2 } call s(NR)'
mlr_expect_fail --from $indir/xyz345 put 'subr s(int a,,)  { print a*2 } call s(NR)'

run_mlr         --from $indir/xyz345 put '$y=log10($x)'
run_mlr         --from $indir/xyz345 put '$y=log10($x,)'
mlr_expect_fail --from $indir/xyz345 put '$y=log10($x,,)'
mlr_expect_fail --from $indir/xyz345 put '$y=log10(,$x)'
run_mlr         --from $indir/xyz345 put '$y=pow($x,2)'
run_mlr         --from $indir/xyz345 put '$y=pow($x,2,)'

# ----------------------------------------------------------------
announce MAPVARS/UDFs/SUBROUTINES

run_mlr --from $indir/abixy put '
  func f(m) {
    dump m;
    sum = 0;
    for (k, v in m) {
      sum += k
    }
    return sum
  }
  @v[$i] = $a;
  $y = f(@v)
'

run_mlr --from $indir/abixy put '
  subr s(m) {
    dump m;
    sum = 0;
    for (k, v in m) {
      sum += k
    }
    @sum = sum;
  }
  @v[$i] = $a;
  call s(@v);
  $y = @sum;
'

run_mlr --from $indir/abixy-het put    'func f(x) {return {"a":x,"b":x**2}}; map o = f($x); $* = o'
run_mlr --from $indir/abixy-het put -q 'func f(x) {return x**2}; var z = f($x); dump z'
run_mlr --from $indir/abixy-het put -q 'func f(x) {map m = {NR:x};return m}; z = f($y); dump z'

mlr_expect_fail --from $indir/abixy put '
  func f(int x): map {
    if (NR==2) {
      return 2
    } else {
      return {}
    }
  }
  $y=f($x)
'

run_mlr --from $indir/abixy put '
  func f(int x): map {
    if (NR==200) {
      return 2
    } else {
      return {}
    }
  }
  $y=f($i)
'

mlr_expect_fail --from $indir/abixy put '
  func f(int x): map {
    if (NR==200) {
      return 2
    } else {
      return {}
    }
  }
  $y=f($x)
'

run_mlr --from $indir/abixy put '
  func f(int x): var {
    if (NR==2) {
      return 2
    } else {
      return {}
    }
  }
  $y=f($i)
'

mlr_expect_fail --from $indir/abixy put '
  func f(int x): var {
    if (NR==2) {
      return 2
    } else {
      return {}
    }
  }
  $y=f($x)
'

mlr_expect_fail --from $indir/abixy put '
  func f(x): int {
    # fall-through return value is absent-null
  }
  $y=f($x)
'

mlr_expect_fail --from $indir/abixy put '
  int a = 1;
  var b = a[2]; # cannot index localvar declared non-map
'

# This one is intended to particularly look at freeing, e.g.  with './reg_test/run --valgrind'.
run_mlr --oxtab --from $indir/abixy-het put '
 $* = mapdiff(
   mapsum($*, {"a": "newval"}),
   {"b": "nonesuch"},
 )
'

# ----------------------------------------------------------------
announce NUMBER FORMATTING

run_mlr                --opprint stats1 -a sum -f x $indir/ofmt.dat
run_mlr --ofmt '%.3lf' --opprint stats1 -a sum -f x $indir/ofmt.dat
run_mlr --opprint --ofmt '%.3lf' stats1 -a sum -f x $indir/ofmt.dat

# ----------------------------------------------------------------
announce IMPLICIT-HEADER-CSV INPUT

run_mlr --irs crlf                       --icsvlite --ifs ,  --opprint cut -x -f b/ $indir/multi-sep.csv-crlf
run_mlr --irs crlf --implicit-csv-header --icsvlite --ifs ,  --opprint cut -x -f 2  $indir/multi-sep.csv-crlf

run_mlr --irs crlf                       --icsvlite --ifs /, --opprint cut -x -f b  $indir/multi-sep.csv-crlf
run_mlr --irs crlf --implicit-csv-header --icsvlite --ifs /, --opprint cut -x -f 2  $indir/multi-sep.csv-crlf

run_mlr                       --icsv --ifs ,  --opprint cut -x -f b/ $indir/multi-sep.csv-crlf
run_mlr --implicit-csv-header --icsv --ifs ,  --opprint cut -x -f 2  $indir/multi-sep.csv-crlf

run_mlr                       --icsv --ifs /, --opprint cut -x -f b  $indir/multi-sep.csv-crlf
run_mlr --implicit-csv-header --icsv --ifs /, --opprint cut -x -f 2  $indir/multi-sep.csv-crlf

run_mlr --csv -N reorder -f 1,3,2,5,4 $indir/multi-sep.csv-crlf
run_mlr --csv -N reorder -f 5,4,3,2,1 $indir/multi-sep.csv-crlf

run_mlr --icsv --otsv -N cat <<EOF
a,b,c
1,2,3
4,5,6
EOF

run_mlr --ixtab --opprint -N cat <<EOF
a 1
b 2
c 3

a 4
b 5
c 6
EOF

run_mlr --icsv --pprint -N cat <<EOF
1,2,3
4,5,6
EOF

# ----------------------------------------------------------------
announce HET-CSV INPUT

run_mlr --icsvlite --odkvp cat $indir/a.csv
run_mlr --icsvlite --odkvp cat $indir/b.csv
run_mlr --icsvlite --odkvp cat $indir/c.csv
run_mlr --icsvlite --odkvp cat $indir/d.csv
run_mlr --icsvlite --odkvp cat $indir/e.csv
run_mlr --icsvlite --odkvp cat $indir/f.csv
run_mlr --icsvlite --odkvp cat $indir/g.csv

run_mlr --icsvlite --odkvp cat $indir/a.csv $indir/a.csv
run_mlr --icsvlite --odkvp cat $indir/b.csv $indir/b.csv
run_mlr --icsvlite --odkvp cat $indir/c.csv $indir/c.csv
run_mlr --icsvlite --odkvp cat $indir/d.csv $indir/d.csv
run_mlr --icsvlite --odkvp cat $indir/e.csv $indir/e.csv
run_mlr --icsvlite --odkvp cat $indir/f.csv $indir/f.csv
run_mlr --icsvlite --odkvp cat $indir/g.csv $indir/g.csv

run_mlr --icsvlite --odkvp cat $indir/a.csv $indir/b.csv
run_mlr --icsvlite --odkvp cat $indir/b.csv $indir/c.csv
run_mlr --icsvlite --odkvp cat $indir/c.csv $indir/d.csv
run_mlr --icsvlite --odkvp cat $indir/d.csv $indir/e.csv
run_mlr --icsvlite --odkvp cat $indir/e.csv $indir/f.csv
run_mlr --icsvlite --odkvp cat $indir/f.csv $indir/g.csv

run_mlr --icsvlite --odkvp cat $indir/a.csv $indir/b.csv \
  $indir/c.csv $indir/d.csv $indir/e.csv $indir/f.csv $indir/g.csv

run_mlr --icsvlite --odkvp tac $indir/het.csv

run_mlr --headerless-csv-output --csvlite tac $indir/a.csv
run_mlr --headerless-csv-output --csvlite tac $indir/c.csv
run_mlr --headerless-csv-output --csvlite tac $indir/a.csv $indir/c.csv
run_mlr --headerless-csv-output --csvlite tac $indir/het.csv
run_mlr --headerless-csv-output --csvlite group-like $indir/het.csv

# ----------------------------------------------------------------
announce HET-PPRINT INPUT

run_mlr --ipprint --odkvp cat $indir/a.pprint
run_mlr --ipprint --odkvp cat $indir/b.pprint
run_mlr --ipprint --odkvp cat $indir/c.pprint
run_mlr --ipprint --odkvp cat $indir/d.pprint
run_mlr --ipprint --odkvp cat $indir/e.pprint
run_mlr --ipprint --odkvp cat $indir/f.pprint
run_mlr --ipprint --odkvp cat $indir/g.pprint

run_mlr --ipprint --odkvp cat $indir/a.pprint $indir/a.pprint
run_mlr --ipprint --odkvp cat $indir/b.pprint $indir/b.pprint
run_mlr --ipprint --odkvp cat $indir/c.pprint $indir/c.pprint
run_mlr --ipprint --odkvp cat $indir/d.pprint $indir/d.pprint
run_mlr --ipprint --odkvp cat $indir/e.pprint $indir/e.pprint
run_mlr --ipprint --odkvp cat $indir/f.pprint $indir/f.pprint
run_mlr --ipprint --odkvp cat $indir/g.pprint $indir/g.pprint

run_mlr --ipprint --odkvp cat $indir/a.pprint $indir/b.pprint
run_mlr --ipprint --odkvp cat $indir/b.pprint $indir/c.pprint
run_mlr --ipprint --odkvp cat $indir/c.pprint $indir/d.pprint
run_mlr --ipprint --odkvp cat $indir/d.pprint $indir/e.pprint
run_mlr --ipprint --odkvp cat $indir/e.pprint $indir/f.pprint
run_mlr --ipprint --odkvp cat $indir/f.pprint $indir/g.pprint

run_mlr --ipprint --odkvp cat $indir/a.pprint $indir/b.pprint \
  $indir/c.pprint $indir/d.pprint $indir/e.pprint $indir/f.pprint $indir/g.pprint

# ----------------------------------------------------------------
announce NULL-FIELD INPUT

run_mlr --icsvlite --odkvp cat $indir/null-fields.csv
run_mlr --inidx --ifs comma --odkvp cat $indir/null-fields.nidx
run_mlr --idkvp --oxtab cat $indir/missings.dkvp

run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f x          $indir/nullvals.dkvp
run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f y          $indir/nullvals.dkvp
run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f z          $indir/nullvals.dkvp
run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f x,y,z      $indir/nullvals.dkvp
run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f x     -g a $indir/nullvals.dkvp
run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f y     -g a $indir/nullvals.dkvp
run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f z     -g a $indir/nullvals.dkvp
run_mlr --oxtab stats1 -a sum,min,max,antimode,mode -f x,y,z -g a $indir/nullvals.dkvp

run_mlr --opprint merge-fields -a sum,min,max,antimode,mode -f x,y,z -o xyz $indir/nullvals.dkvp
run_mlr --opprint merge-fields -a sum,min,max,antimode,mode -r x,y,z -o xyz $indir/nullvals.dkvp
run_mlr --opprint merge-fields -a sum,min,max,antimode,mode -c x,y,z        $indir/nullvals.dkvp

run_mlr --oxtab stats2 -a cov -f x,y        $indir/nullvals.dkvp
run_mlr --oxtab stats2 -a cov -f x,z        $indir/nullvals.dkvp
run_mlr --oxtab stats2 -a cov -f y,z        $indir/nullvals.dkvp
run_mlr --oxtab stats2 -a cov -f x,y   -g a $indir/nullvals.dkvp
run_mlr --oxtab stats2 -a cov -f x,z   -g a $indir/nullvals.dkvp
run_mlr --oxtab stats2 -a cov -f y,z   -g a $indir/nullvals.dkvp

run_mlr --opprint top    -n 5 -f x          $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f y          $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f z          $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f x,y,z      $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f x     -g a $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f y     -g a $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f z     -g a $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f x,y,z -g a $indir/nullvals.dkvp

run_mlr --opprint top -a -n 5 -f x          $indir/nullvals.dkvp
run_mlr --opprint top -a -n 5 -f y          $indir/nullvals.dkvp
run_mlr --opprint top -a -n 5 -f z          $indir/nullvals.dkvp
run_mlr --opprint top -a -n 5 -f x     -g a $indir/nullvals.dkvp
run_mlr --opprint top -a -n 5 -f y     -g a $indir/nullvals.dkvp
run_mlr --opprint top -a -n 5 -f z     -g a $indir/nullvals.dkvp

run_mlr --opprint top    -n 5 -f x          -o foo $indir/nullvals.dkvp
run_mlr --opprint top    -n 5 -f x     -g a -o foo $indir/nullvals.dkvp

run_mlr --opprint top -a -n 5 -f x -o foo      $indir/nullvals.dkvp
run_mlr --opprint top -a -n 5 -f z -o foo -g a $indir/nullvals.dkvp

run_mlr --opprint step -a counter,rsum -f x          $indir/nullvals.dkvp
run_mlr --opprint step -a counter,rsum -f y          $indir/nullvals.dkvp
run_mlr --opprint step -a counter,rsum -f z          $indir/nullvals.dkvp
run_mlr --opprint step -a counter,rsum -f x,y,z      $indir/nullvals.dkvp

run_mlr --opprint step -a counter,rsum -f x     -g a $indir/nullvals.dkvp
run_mlr --opprint step -a counter,rsum -f y     -g a $indir/nullvals.dkvp
run_mlr --opprint step -a counter,rsum -f z     -g a $indir/nullvals.dkvp
run_mlr --opprint step -a counter,rsum -f x,y,z -g a $indir/nullvals.dkvp

# ----------------------------------------------------------------
announce SPACE-PADDING

run_mlr --idkvp    --odkvp --ifs space --repifs cat $indir/space-pad.dkvp
run_mlr --inidx    --odkvp --ifs space --repifs cat $indir/space-pad.nidx
run_mlr --icsvlite --odkvp --ifs space --repifs cat $indir/space-pad.pprint

# ----------------------------------------------------------------
announce DOUBLE PS

run_mlr --opprint cat $indir/double-ps.dkvp

# ----------------------------------------------------------------
announce MISSING FINAL LF

run_mlr --csvlite cat $indir/truncated.csv
run_mlr --dkvp    cat $indir/truncated.dkvp
run_mlr --nidx    cat $indir/truncated.nidx
run_mlr --pprint  cat $indir/truncated.pprint
run_mlr --xtab    cat $indir/truncated.xtab-crlf

# ----------------------------------------------------------------
announce UTF-8 alignment

run_mlr --icsvlite --opprint cat $indir/utf8-1.csv
run_mlr --icsvlite --opprint cat $indir/utf8-2.csv
run_mlr --icsvlite --oxtab   cat $indir/utf8-1.csv
run_mlr --icsvlite --oxtab   cat $indir/utf8-2.csv

run_mlr --inidx --ifs space --opprint         cat $indir/utf8-align.nidx
run_mlr --inidx --ifs space --opprint --right cat $indir/utf8-align.nidx
run_mlr --oxtab cat $indir/utf8-align.dkvp

run_mlr --inidx --ifs space --oxtab --xvright cat $indir/utf8-align.nidx

# ----------------------------------------------------------------
announce UTF-8 BOM

run_mlr --icsv --opprint cat   $indir/bom.csv
run_mlr --icsv --opprint cat < $indir/bom.csv
run_mlr --icsv --opprint cat   $indir/bom-dquote-header.csv
run_mlr --icsv --opprint cat < $indir/bom-dquote-header.csv

# ----------------------------------------------------------------
announce UTF-8 UPPERCASE/LOWERCASE

run_mlr --icsvlite --opprint put '$langue = toupper($langue)' $indir/utf8-1.csv
run_mlr --icsvlite --opprint put '$nom    = toupper($nom)'    $indir/utf8-1.csv
run_mlr --icsvlite --opprint put '$jour   = toupper($jour)'   $indir/utf8-1.csv

run_mlr --icsvlite --opprint put '$langue = capitalize($langue)' $indir/utf8-1.csv
run_mlr --icsvlite --opprint put '$nom    = capitalize($nom)'    $indir/utf8-1.csv
run_mlr --icsvlite --opprint put '$jour   = capitalize($jour)'   $indir/utf8-1.csv

# ----------------------------------------------------------------
announce SKIP/PASS COMMENTS DKVP

mention input comments1.dkvp
run_cat $indir/comments/comments1.dkvp

mention skip comments1.dkvp
run_mlr --skip-comments --idkvp --oxtab cat < $indir/comments/comments1.dkvp
run_mlr --skip-comments --idkvp --oxtab cat   $indir/comments/comments1.dkvp

mention pass comments1.dkvp
run_mlr --pass-comments --idkvp --oxtab cat < $indir/comments/comments1.dkvp
run_mlr --pass-comments --idkvp --oxtab cat   $indir/comments/comments1.dkvp


mention input comments2.dkvp
run_cat $indir/comments/comments2.dkvp

mention skip comments2.dkvp
run_mlr --skip-comments --idkvp --oxtab cat < $indir/comments/comments2.dkvp
run_mlr --skip-comments --idkvp --oxtab cat   $indir/comments/comments2.dkvp

mention pass comments2.dkvp
run_mlr --pass-comments --idkvp --oxtab cat < $indir/comments/comments2.dkvp
run_mlr --pass-comments --idkvp --oxtab cat   $indir/comments/comments2.dkvp


mention input comments3.dkvp
run_cat $indir/comments/comments3.dkvp

mention skip comments3.dkvp
run_mlr --skip-comments --idkvp --oxtab cat < $indir/comments/comments3.dkvp
run_mlr --skip-comments --idkvp --oxtab cat   $indir/comments/comments3.dkvp

mention pass comments3.dkvp
run_mlr --pass-comments --idkvp --oxtab cat < $indir/comments/comments3.dkvp
run_mlr --pass-comments --idkvp --oxtab cat   $indir/comments/comments3.dkvp

# It's annoying trying to check in text files (especially CSV) with CRLF
# to Git, given that it likes to 'fix' line endings for multi-platform use.
# It's easy to simply create CRLF on the fly.
run_mlr_for_auxents_no_output termcvt --lf2crlf < $indir/comments/comments1.dkvp > $outdir/comments1-crlf.dkvp

mention input comments1-crlf.dkvp
run_cat $outdir/comments1-crlf.dkvp

mention skip comments1-crlf.dkvp
run_mlr --skip-comments --idkvp --oxtab cat < $outdir/comments1-crlf.dkvp
run_mlr --skip-comments --idkvp --oxtab cat   $outdir/comments1-crlf.dkvp

mention pass comments1-crlf.dkvp
run_mlr --pass-comments --idkvp --oxtab cat < $outdir/comments1-crlf.dkvp
run_mlr --pass-comments --idkvp --oxtab cat   $outdir/comments1-crlf.dkvp


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
announce SKIP/PASS COMMENTS DKVP WITH ALTERNATE PREFIX

mention input comments1-atat.dkvp
run_cat $indir/comments/comments1-atat.dkvp

mention skip comments1-atat.dkvp
run_mlr --skip-comments-with @@ --idkvp --oxtab cat < $indir/comments/comments1-atat.dkvp
run_mlr --skip-comments-with @@ --idkvp --oxtab cat   $indir/comments/comments1-atat.dkvp

mention pass comments1-atat.dkvp
run_mlr --pass-comments-with @@ --idkvp --oxtab cat < $indir/comments/comments1-atat.dkvp
run_mlr --pass-comments-with @@ --idkvp --oxtab cat   $indir/comments/comments1-atat.dkvp


mention input comments2-atat.dkvp
run_cat $indir/comments/comments2-atat.dkvp

mention skip comments2-atat.dkvp
run_mlr --skip-comments-with @@ --idkvp --oxtab cat < $indir/comments/comments2-atat.dkvp
run_mlr --skip-comments-with @@ --idkvp --oxtab cat   $indir/comments/comments2-atat.dkvp

mention pass comments2-atat.dkvp
run_mlr --pass-comments-with @@ --idkvp --oxtab cat < $indir/comments/comments2-atat.dkvp
run_mlr --pass-comments-with @@ --idkvp --oxtab cat   $indir/comments/comments2-atat.dkvp


mention input comments3-atat.dkvp
run_cat $indir/comments/comments3-atat.dkvp

mention skip comments3-atat.dkvp
run_mlr --skip-comments-with @@ --idkvp --oxtab cat < $indir/comments/comments3-atat.dkvp
run_mlr --skip-comments-with @@ --idkvp --oxtab cat   $indir/comments/comments3-atat.dkvp

mention pass comments3-atat.dkvp
run_mlr --pass-comments-with @@ --idkvp --oxtab cat < $indir/comments/comments3-atat.dkvp
run_mlr --pass-comments-with @@ --idkvp --oxtab cat   $indir/comments/comments3-atat.dkvp

# ----------------------------------------------------------------
announce SKIP/PASS COMMENTS NIDX

mention input comments1.nidx
run_cat $indir/comments/comments1.nidx

mention skip comments1.nidx
run_mlr --skip-comments --inidx --oxtab cat < $indir/comments/comments1.nidx
run_mlr --skip-comments --inidx --oxtab cat   $indir/comments/comments1.nidx

mention pass comments1.nidx
run_mlr --pass-comments --inidx --oxtab cat < $indir/comments/comments1.nidx
run_mlr --pass-comments --inidx --oxtab cat   $indir/comments/comments1.nidx


mention input comments2.nidx
run_cat $indir/comments/comments2.nidx

mention skip comments2.nidx
run_mlr --skip-comments --inidx --oxtab cat < $indir/comments/comments2.nidx
run_mlr --skip-comments --inidx --oxtab cat   $indir/comments/comments2.nidx

mention pass comments2.nidx
run_mlr --pass-comments --inidx --oxtab cat < $indir/comments/comments2.nidx
run_mlr --pass-comments --inidx --oxtab cat   $indir/comments/comments2.nidx


mention input comments3.nidx
run_cat $indir/comments/comments3.nidx

mention skip comments3.nidx
run_mlr --skip-comments --inidx --oxtab cat < $indir/comments/comments3.nidx
run_mlr --skip-comments --inidx --oxtab cat   $indir/comments/comments3.nidx

mention pass comments3.nidx
run_mlr --pass-comments --inidx --oxtab cat < $indir/comments/comments3.nidx
run_mlr --pass-comments --inidx --oxtab cat   $indir/comments/comments3.nidx


# It's annoying trying to check in text files (especially CSV) with CRLF
# to Git, given that it likes to 'fix' line endings for multi-platform use.
# It's easy to simply create CRLF on the fly.
run_mlr_for_auxents_no_output termcvt --lf2crlf < $indir/comments/comments1.nidx > $outdir/comments1-crlf.nidx

mention input comments1-crlf.nidx
run_cat $outdir/comments1-crlf.nidx

mention skip comments1-crlf.nidx
run_mlr --skip-comments --inidx --oxtab cat < $outdir/comments1-crlf.nidx
run_mlr --skip-comments --inidx --oxtab cat   $outdir/comments1-crlf.nidx

mention pass comments1-crlf.nidx
run_mlr --pass-comments --inidx --oxtab cat < $outdir/comments1-crlf.nidx
run_mlr --pass-comments --inidx --oxtab cat   $outdir/comments1-crlf.nidx

# ----------------------------------------------------------------
announce SKIP/PASS COMMENTS JSON

mention input comments1.json
run_cat $indir/comments/comments1.json

mention skip comments1.json
run_mlr --skip-comments --ijson --odkvp cat < $indir/comments/comments1.json
run_mlr --skip-comments --ijson --odkvp cat   $indir/comments/comments1.json

mention pass comments1.json
run_mlr --pass-comments --ijson --odkvp cat < $indir/comments/comments1.json
run_mlr --pass-comments --ijson --odkvp cat   $indir/comments/comments1.json


mention input comments2.json
run_cat $indir/comments/comments2.json

mention skip comments2.json
run_mlr --skip-comments --ijson --odkvp cat < $indir/comments/comments2.json
run_mlr --skip-comments --ijson --odkvp cat   $indir/comments/comments2.json

mention pass comments2.json
run_mlr --pass-comments --ijson --odkvp cat < $indir/comments/comments2.json
run_mlr --pass-comments --ijson --odkvp cat   $indir/comments/comments2.json


mention input comments3.json
run_cat $indir/comments/comments3.json

mention skip comments3.json
run_mlr --skip-comments --ijson --odkvp cat < $indir/comments/comments3.json
run_mlr --skip-comments --ijson --odkvp cat   $indir/comments/comments3.json

mention pass comments3.json
run_mlr --pass-comments --ijson --odkvp cat < $indir/comments/comments3.json
run_mlr --pass-comments --ijson --odkvp cat   $indir/comments/comments3.json


# It's annoying trying to check in text files (especially CSV) with CRLF
# to Git, given that it likes to 'fix' line endings for multi-platform use.
# It's easy to simply create CRLF on the fly.
run_mlr_for_auxents_no_output termcvt --lf2crlf < $indir/comments/comments1.json > $outdir/comments1-crlf.json

mention input comments1-crlf.json
run_cat $outdir/comments1-crlf.json

mention skip comments1-crlf.json
run_mlr --skip-comments --ijson --odkvp cat < $outdir/comments1-crlf.json
run_mlr --skip-comments --ijson --odkvp cat   $outdir/comments1-crlf.json

mention pass comments1-crlf.json
run_mlr --pass-comments --ijson --odkvp cat < $outdir/comments1-crlf.json
run_mlr --pass-comments --ijson --odkvp cat   $outdir/comments1-crlf.json

# ----------------------------------------------------------------
announce SKIP/PASS COMMENTS XTAB

mention input comments1.xtab
run_cat $indir/comments/comments1.xtab

mention skip comments1.xtab
run_mlr --skip-comments --ixtab --odkvp cat < $indir/comments/comments1.xtab
run_mlr --skip-comments --ixtab --odkvp cat   $indir/comments/comments1.xtab

mention pass comments1.xtab
run_mlr --pass-comments --ixtab --odkvp cat < $indir/comments/comments1.xtab
run_mlr --pass-comments --ixtab --odkvp cat   $indir/comments/comments1.xtab


mention input comments2.xtab
run_cat $indir/comments/comments2.xtab

mention skip comments2.xtab
run_mlr --skip-comments --ixtab --odkvp cat < $indir/comments/comments2.xtab
run_mlr --skip-comments --ixtab --odkvp cat   $indir/comments/comments2.xtab

mention pass comments2.xtab
run_mlr --pass-comments --ixtab --odkvp cat < $indir/comments/comments2.xtab
run_mlr --pass-comments --ixtab --odkvp cat   $indir/comments/comments2.xtab


# It's annoying trying to check in text files (especially CSV) with CRLF
# to Git, given that it likes to 'fix' line endings for multi-platform use.
# It's easy to simply create CRLF on the fly.
run_mlr_for_auxents_no_output termcvt --lf2crlf < $indir/comments/comments1.xtab > $outdir/comments1-crlf.xtab

mention input comments1-crlf.xtab
run_cat $outdir/comments1-crlf.xtab

mention skip comments1-crlf.xtab
run_mlr --skip-comments --ixtab --odkvp cat < $outdir/comments1-crlf.xtab
run_mlr --skip-comments --ixtab --odkvp cat   $outdir/comments1-crlf.xtab

mention pass comments1-crlf.xtab
run_mlr --pass-comments --ixtab --odkvp cat < $outdir/comments1-crlf.xtab
run_mlr --pass-comments --ixtab --odkvp cat   $outdir/comments1-crlf.xtab

# ----------------------------------------------------------------
announce SKIP/PASS COMMENTS CSVLITE

mention input comments1.csv
run_cat $indir/comments/comments1.csv

mention skip comments1.csv
run_mlr --skip-comments --icsvlite --odkvp cat < $indir/comments/comments1.csv
run_mlr --skip-comments --icsvlite --odkvp cat   $indir/comments/comments1.csv

mention pass comments1.csv
run_mlr --pass-comments --icsvlite --odkvp cat < $indir/comments/comments1.csv
run_mlr --pass-comments --icsvlite --odkvp cat   $indir/comments/comments1.csv


mention input comments2.csv
run_cat $indir/comments/comments2.csv

mention skip comments2.csv
run_mlr --skip-comments --icsvlite --odkvp cat < $indir/comments/comments2.csv
run_mlr --skip-comments --icsvlite --odkvp cat   $indir/comments/comments2.csv

mention pass comments2.csv
run_mlr --pass-comments --icsvlite --odkvp cat < $indir/comments/comments2.csv
run_mlr --pass-comments --icsvlite --odkvp cat   $indir/comments/comments2.csv


# It's annoying trying to check in text files (especially CSV) with CRLF
# to Git, given that it likes to 'fix' line endings for multi-platform use.
# It's easy to simply create CRLF on the fly.
run_mlr_for_auxents_no_output termcvt --lf2crlf < $indir/comments/comments1.csv > $outdir/comments1-crlf.csv

mention input comments1-crlf.csv
run_cat $outdir/comments1-crlf.csv

mention skip comments1-crlf.csv
run_mlr --skip-comments --icsvlite --odkvp cat < $outdir/comments1-crlf.csv
run_mlr --skip-comments --icsvlite --odkvp cat   $outdir/comments1-crlf.csv

mention pass comments1-crlf.csv
run_mlr --pass-comments --icsvlite --odkvp cat < $outdir/comments1-crlf.csv
run_mlr --pass-comments --icsvlite --odkvp cat   $outdir/comments1-crlf.csv

# ----------------------------------------------------------------
announce SKIP/PASS COMMENTS CSV

mention input comments1.csv
run_cat $indir/comments/comments1.csv

mention skip comments1.csv
run_mlr --skip-comments --icsv --odkvp cat < $indir/comments/comments1.csv
run_mlr --skip-comments --icsv --odkvp cat   $indir/comments/comments1.csv

mention pass comments1.csv
run_mlr --pass-comments --icsv --odkvp cat < $indir/comments/comments1.csv
run_mlr --pass-comments --icsv --odkvp cat   $indir/comments/comments1.csv


mention input comments2.csv
run_cat $indir/comments/comments2.csv

mention skip comments2.csv
run_mlr --skip-comments --icsv --odkvp cat < $indir/comments/comments2.csv
run_mlr --skip-comments --icsv --odkvp cat   $indir/comments/comments2.csv

mention pass comments2.csv
run_mlr --pass-comments --icsv --odkvp cat < $indir/comments/comments2.csv
run_mlr --pass-comments --icsv --odkvp cat   $indir/comments/comments2.csv


# It's annoying trying to check in text files (especially CSV) with CRLF
# to Git, given that it likes to 'fix' line endings for multi-platform use.
# It's easy to simply create CRLF on the fly.
run_mlr_for_auxents_no_output termcvt --lf2crlf < $indir/comments/comments1.csv > $outdir/comments1-crlf.csv

mention input comments1-crlf.csv
run_cat $outdir/comments1-crlf.csv

mention skip comments1-crlf.csv
run_mlr --skip-comments --icsv --odkvp cat < $outdir/comments1-crlf.csv
run_mlr --skip-comments --icsv --odkvp cat   $outdir/comments1-crlf.csv

mention pass comments1-crlf.csv
run_mlr --pass-comments --icsv --odkvp cat < $outdir/comments1-crlf.csv
run_mlr --pass-comments --icsv --odkvp cat   $outdir/comments1-crlf.csv

# ----------------------------------------------------------------
announce INT64 I/O

run_mlr --oxtab put '$c=$a;$d=$b;$e=hexfmt($a);$f=hexfmt($b)' $indir/int64io.dkvp

# There is different rounding on i386 vs. x86_64 but the essential check is
# that overflow has been avoided. Hence the %g output format here.
run_mlr --oxtab --ofmt '%.8g' put '$p0=$p+0;$p1=$p+1;$p2=$p+2;$p3=$p+3' $indir/int64arith.dkvp
run_mlr --oxtab --ofmt '%.8g' put '$p0=$p-0;$p1=$p-1;$p2=$p-2;$p3=$p-3' $indir/int64arith.dkvp
run_mlr --oxtab --ofmt '%.8g' put '$p0=$p*0;$p1=$p*1;$p2=$p*2;$p3=$p*3' $indir/int64arith.dkvp
run_mlr --oxtab --ofmt '%.8g' put '$n0=$n+0;$n1=$n+1;$n2=$n+2;$n3=$n+3' $indir/int64arith.dkvp
run_mlr --oxtab --ofmt '%.8g' put '$n0=$n-0;$n1=$n-1;$n2=$n-2;$n3=$n-3' $indir/int64arith.dkvp
run_mlr --oxtab --ofmt '%.8g' put '$n0=$n*0;$n1=$n*1;$n2=$n*2;$n3=$n*3' $indir/int64arith.dkvp

# ----------------------------------------------------------------
announce COMPRESSED INPUT

run_mlr --csv  --prepipe 'cat'   cat   $indir/rfc-csv/simple.csv-crlf
run_mlr --dkvp --prepipe 'cat'   cat   $indir/abixy
run_mlr --csv  --prepipe 'cat'   cat < $indir/rfc-csv/simple.csv-crlf
run_mlr --dkvp --prepipe 'cat'   cat < $indir/abixy

# ----------------------------------------------------------------
announce STDIN

run_mlr --csv cat < $indir/rfc-csv/simple.csv-crlf

# ----------------------------------------------------------------
announce RFC-CSV

run_mlr --csv cat $indir/rfc-csv/simple.csv-crlf
run_mlr --csv cat $indir/rfc-csv/simple-truncated.csv
run_mlr --csv cat $indir/rfc-csv/narrow.csv
run_mlr --csv cat $indir/rfc-csv/narrow-truncated.csv
run_mlr --csv cat $indir/rfc-csv/quoted-comma.csv
run_mlr --csv cat $indir/rfc-csv/quoted-comma-truncated.csv
run_mlr --csv cat $indir/rfc-csv/quoted-crlf.csv
run_mlr --csv cat $indir/rfc-csv/quoted-crlf-truncated.csv
run_mlr --csv cat $indir/rfc-csv/simple-truncated.csv $indir/rfc-csv/simple.csv-crlf
run_mlr --csv --ifs semicolon --ofs pipe --irs lf --ors lflf cut -x -f b $indir/rfc-csv/modify-defaults.csv
run_mlr --csv --rs lf --quote-original cut -o -f c,b,a $indir/quote-original.csv

run_mlr --icsv --oxtab cat $indir/comma-at-eof.csv

run_mlr --csv --quote-all      cat $indir/rfc-csv/simple.csv-crlf
run_mlr --csv --quote-original cat $indir/rfc-csv/simple.csv-crlf

run_mlr --itsv --rs lf --oxtab cat $indir/simple.tsv

run_mlr --iusv --oxtab cat $indir/example.usv

# ----------------------------------------------------------------
announce RAGGED NON-RFC CSV

run_mlr --icsv     --oxtab --ragged cat $indir/ragged.csv
run_mlr --icsvlite --oxtab --ragged cat $indir/ragged.csv

# ----------------------------------------------------------------
announce MARKDOWN OUTPUT

run_mlr --itsv --rs lf --omd cat $indir/simple.tsv

# ----------------------------------------------------------------
announce CSV/RS ENVIRONMENT DEFAULTS

run_mlr --csv cut -f a $indir/rfc-csv/simple.csv-crlf
run_mlr --csv --rs crlf cut -f a $indir/rfc-csv/simple.csv-crlf
mlr_expect_fail --csv --rs lf cut -f a $indir/rfc-csv/simple.csv-crlf

# ----------------------------------------------------------------
announce MULTI-CHARACTER IRS/IFS/IPS FOR DKVP

run_mlr --oxtab --idkvp --irs lf   --ifs ,  --ips =  cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
run_mlr --oxtab --idkvp --irs lf   --ifs /, --ips =: cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
run_mlr --oxtab --idkvp --irs crlf --ifs ,  --ips =  cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
run_mlr --oxtab --idkvp --irs crlf --ifs /, --ips =: cut -o -f x,a,i $indir/multi-sep.dkvp-crlf

# ----------------------------------------------------------------
announce MULTI-CHARACTER IRS/IFS FOR NIDX

run_mlr --oxtab --inidx --irs lf   --ifs ,  cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
run_mlr --oxtab --inidx --irs lf   --ifs /, cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
run_mlr --oxtab --inidx --irs crlf --ifs ,  cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf
run_mlr --oxtab --inidx --irs crlf --ifs /, cut -o -f 4,1,3 $indir/multi-sep.dkvp-crlf

# ----------------------------------------------------------------
announce MULTI-CHARACTER IRS/IFS FOR CSVLITE

run_mlr --oxtab --icsvlite --irs lf   --ifs ,  cut -o -f x/,a/,i/ $indir/multi-sep.csv-crlf
run_mlr --oxtab --icsvlite --irs lf   --ifs /, cut -o -f x,a,i    $indir/multi-sep.csv-crlf
run_mlr --oxtab --icsvlite --irs crlf --ifs ,  cut -o -f x/,a/,i/ $indir/multi-sep.csv-crlf
run_mlr --oxtab --icsvlite --irs crlf --ifs /, cut -o -f x,a,i    $indir/multi-sep.csv-crlf

# ----------------------------------------------------------------
announce MULTI-CHARACTER SEPARATORS FOR XTAB

run_mlr --xtab --ifs crlf --ofs Z cut -x -f b $indir/truncated.xtab-crlf
run_mlr --xtab --ips . --ops @ cut -x -f b $indir/dots.xtab
run_mlr --xtab --ips ": " --ops '@@@@' put '$sum=int($a+$b)' $indir/multi-ips.dkvp

# ----------------------------------------------------------------
announce EMBEDDED IPS FOR XTAB

run_mlr --xtab cat $indir/embedded-ips.xtab

# ----------------------------------------------------------------
announce MULTI-CHARACTER IRS FOR PPRINT

run_mlr --pprint --irs crlf --ifs / --ofs @ cut -x -f b $indir/dots.pprint-crlf

# ----------------------------------------------------------------
announce BARRED PPRINT

run_mlr --opprint --barred cat $indir/abixy
run_mlr --opprint --barred --right cat $indir/abixy

run_mlr --opprint --barred cat $indir/abixy-het
run_mlr --opprint --barred --right cat $indir/abixy-het

# ----------------------------------------------------------------
announce MULTI-CHARACTER IXS SPECIFIERS

run_mlr --oxtab --idkvp --irs lf   --ifs '\x2c'  --ips '\075'  cut -o -f x,a,i $indir/multi-sep.dkvp-crlf
run_mlr --oxtab --idkvp --irs lf   --ifs /, --ips '\x3d\x3a' cut -o -f x,a,i $indir/multi-sep.dkvp-crlf

# ----------------------------------------------------------------
announce JSON I/O

run_mlr --ijson --opprint cat $indir/small-non-nested.json
run_mlr --ijson --opprint cat $indir/small-non-nested-wrapped.json
run_mlr --ijson --oxtab   cat $indir/small-nested.json

run_mlr --ojson                                       cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack                             cat $indir/json-output-options.dkvp
run_mlr --ojson             --jlistwrap               cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack   --jlistwrap               cat $indir/json-output-options.dkvp
run_mlr --ojson                         --jquoteall   cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack               --jquoteall   cat $indir/json-output-options.dkvp
run_mlr --ojson             --jlistwrap --jquoteall   cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack   --jlistwrap --jquoteall   cat $indir/json-output-options.dkvp
run_mlr --ojson                         --jvquoteall  cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack               --jvquoteall  cat $indir/json-output-options.dkvp
run_mlr --ojson             --jlistwrap --jvquoteall  cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack   --jlistwrap --jvquoteall  cat $indir/json-output-options.dkvp
run_mlr --ojson                         --jknquoteint cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack               --jknquoteint cat $indir/json-output-options.dkvp
run_mlr --ojson             --jlistwrap --jknquoteint cat $indir/json-output-options.dkvp
run_mlr --ojson --jvstack   --jlistwrap --jknquoteint cat $indir/json-output-options.dkvp

run_mlr put -q --jvquoteall 'dump $*'                   $indir/json-output-options.dkvp
run_mlr put -q --jvquoteall 'o = $*; o[7] = 8; dump o'  $indir/json-output-options.dkvp
run_mlr put -q --jknquoteint 'dump $*'                  $indir/json-output-options.dkvp
run_mlr put -q --jknquoteint 'o = $*; o[7] = 8; dump o' $indir/json-output-options.dkvp

run_mlr  --ijson --opprint cat $indir/small-non-nested-wrapped.json $indir/small-non-nested-wrapped.json

run_mlr --icsv --ojson --rs lf cat <<EOF
col
"abc ""def"" \ghi"
EOF

run_mlr --icsv --ojson --jvquoteall --rs lf cat <<EOF
col
"abc ""def"" \ghi"
EOF

run_mlr         --ijson --oxtab                              cat $indir/arrays.json
run_mlr         --ijson --oxtab --json-map-arrays-on-input   cat $indir/arrays.json
run_mlr         --ijson --oxtab --json-skip-arrays-on-input  cat $indir/arrays.json
mlr_expect_fail --ijson --oxtab --json-fatal-arrays-on-input cat $indir/arrays.json

run_mlr --json cat $indir/escapes.json

# ----------------------------------------------------------------
announce FORMAT-CONVERSION KEYSTROKE-SAVERS

run_mlr --d2t cat  $indir/abixy.dkvp
run_mlr --d2n cat  $indir/abixy.dkvp
run_mlr --d2j cat  $indir/abixy.dkvp
run_mlr --d2p cat  $indir/abixy.dkvp
run_mlr --d2x cat  $indir/abixy.dkvp
run_mlr --d2m cat  $indir/abixy.dkvp

run_mlr --c2t cat  $indir/abixy.csv
run_mlr --c2d cat  $indir/abixy.csv
run_mlr --c2n cat  $indir/abixy.csv
run_mlr --c2j cat  $indir/abixy.csv
run_mlr --c2p cat  $indir/abixy.csv
run_mlr --c2x cat  $indir/abixy.csv
run_mlr --c2m cat  $indir/abixy.csv

run_mlr --t2c cat  $indir/abixy.tsv
run_mlr --t2d cat  $indir/abixy.tsv
run_mlr --t2n cat  $indir/abixy.tsv
run_mlr --t2j cat  $indir/abixy.tsv
run_mlr --t2p cat  $indir/abixy.tsv
run_mlr --t2x cat  $indir/abixy.tsv
run_mlr --t2m cat  $indir/abixy.tsv

run_mlr --n2c cat  $indir/abixy.nidx
run_mlr --n2t cat  $indir/abixy.nidx
run_mlr --n2d cat  $indir/abixy.nidx
run_mlr --n2j cat  $indir/abixy.nidx
run_mlr --n2p cat  $indir/abixy.nidx
run_mlr --n2x cat  $indir/abixy.nidx
run_mlr --n2m cat  $indir/abixy.nidx

run_mlr --j2c cat  $indir/abixy.json
run_mlr --j2t cat  $indir/abixy.json
run_mlr --j2d cat  $indir/abixy.json
run_mlr --j2n cat  $indir/abixy.json
run_mlr --j2p cat  $indir/abixy.json
run_mlr --j2x cat  $indir/abixy.json
run_mlr --j2m cat  $indir/abixy.json

run_mlr --p2c cat  $indir/abixy.pprint
run_mlr --p2t cat  $indir/abixy.pprint
run_mlr --p2d cat  $indir/abixy.pprint
run_mlr --p2n cat  $indir/abixy.pprint
run_mlr --p2j cat  $indir/abixy.pprint
run_mlr --p2x cat  $indir/abixy.pprint
run_mlr --p2m cat  $indir/abixy.pprint

run_mlr --x2c cat  $indir/abixy.xtab
run_mlr --x2t cat  $indir/abixy.xtab
run_mlr --x2d cat  $indir/abixy.xtab
run_mlr --x2n cat  $indir/abixy.xtab
run_mlr --x2j cat  $indir/abixy.xtab
run_mlr --x2p cat  $indir/abixy.xtab
run_mlr --x2m cat  $indir/abixy.xtab

# ----------------------------------------------------------------
announce LF/CRLF AND AUTODETECT

run_mlr --irs auto --ors lf cat $indir/line-term-lf.dkvp
run_mlr --irs auto --ors lf cat $indir/line-term-crlf.dkvp
run_mlr cat $indir/line-term-lf.dkvp
run_mlr cat $indir/line-term-crlf.dkvp

mention nidx
run_mlr --irs auto --ors lf --nidx --fs comma cat $indir/line-term-lf.dkvp
run_mlr --irs auto --ors lf --nidx --fs comma cat $indir/line-term-crlf.dkvp
run_mlr --nidx --fs comma cat $indir/line-term-lf.dkvp
run_mlr --nidx --fs comma cat $indir/line-term-crlf.dkvp


mention csvlite
run_mlr --irs auto --ors lf --csvlite cat $indir/line-term-lf.csv
run_mlr --irs auto --ors lf --csvlite cat $indir/line-term-crlf.csv
run_mlr --csvlite cat $indir/line-term-lf.csv
run_mlr --csvlite cat $indir/line-term-crlf.csv


mention pprint
run_mlr --irs auto --ors lf --pprint cat $indir/line-term-lf.csv
run_mlr --irs auto --ors lf --pprint cat $indir/line-term-crlf.csv
run_mlr --pprint cat $indir/line-term-lf.csv
run_mlr --pprint cat $indir/line-term-crlf.csv


mention xtab
run_mlr --ifs auto --xtab cat $indir/line-term-lf.xtab
run_mlr --ifs auto --xtab cat $indir/line-term-crlf.xtab
run_mlr --fs  auto --xtab cat $indir/line-term-lf.xtab
run_mlr --fs  auto --xtab cat $indir/line-term-crlf.xtab

mention xtab
run_mlr --ifs auto --xtab cat $indir/line-term-lf.xtab
run_mlr --ifs auto --xtab cat $indir/line-term-crlf.xtab
run_mlr --fs  auto --xtab cat $indir/line-term-lf.xtab
run_mlr --fs  auto --xtab cat $indir/line-term-crlf.xtab


mention csv
run_mlr --irs auto --ors lf --csv cat $indir/line-term-lf.csv
run_mlr --irs auto --ors lf --csv cat $indir/line-term-crlf.csv
run_mlr --csv cat $indir/line-term-lf.csv
run_mlr --csv cat $indir/line-term-crlf.csv


mention json nowrap nostack
run_mlr --irs auto --ors lf --json cat $indir/line-term-lf.json
run_mlr --irs auto --ors lf --json cat $indir/line-term-crlf.json
run_mlr --json cat $indir/line-term-lf.json
run_mlr --json cat $indir/line-term-crlf.json


mention json yeswrap nostack
run_mlr --irs auto --ors lf --jlistwrap --json cat $indir/line-term-lf-wrap.json
run_mlr --irs auto --ors lf --jlistwrap --json cat $indir/line-term-crlf-wrap.json
run_mlr --jlistwrap --json cat $indir/line-term-lf-wrap.json
run_mlr --jlistwrap --json cat $indir/line-term-crlf-wrap.json


mention json nowrap yesstack
run_mlr --irs auto --json --jvstack cat $indir/line-term-lf.json
run_mlr --irs auto --ors lf --json --jvstack cat $indir/line-term-crlf.json
run_mlr --json --jvstack cat $indir/line-term-lf.json
run_mlr --json --jvstack cat $indir/line-term-crlf.json


mention json yeswrap yesstack
run_mlr --irs auto --ors lf --jlistwrap --json --jvstack cat $indir/line-term-lf-wrap.json
run_mlr --irs auto --ors lf --jlistwrap --json --jvstack cat $indir/line-term-crlf-wrap.json
run_mlr --jlistwrap --json --jvstack cat $indir/line-term-lf-wrap.json
run_mlr --jlistwrap --json --jvstack cat $indir/line-term-crlf-wrap.json

mention json nowrap nostack
run_mlr --irs auto --ors lf --json cat $indir/line-term-lf.json
run_mlr --irs auto --ors lf --json cat $indir/line-term-crlf.json
run_mlr --json cat $indir/line-term-lf.json
run_mlr --json cat $indir/line-term-crlf.json


mention json yeswrap nostack
run_mlr --irs auto --ors lf --jlistwrap --json cat $indir/line-term-lf-wrap.json
run_mlr --irs auto --ors lf --jlistwrap --json cat $indir/line-term-crlf-wrap.json
run_mlr --jlistwrap --json cat $indir/line-term-lf-wrap.json
run_mlr --jlistwrap --json cat $indir/line-term-crlf-wrap.json


mention json nowrap yesstack
run_mlr --irs auto --ors lf --json --jvstack cat $indir/line-term-lf.json
run_mlr --irs auto --ors lf --json --jvstack cat $indir/line-term-crlf.json
run_mlr --json --jvstack cat $indir/line-term-lf.json
run_mlr --json --jvstack cat $indir/line-term-crlf.json


mention json yeswrap yesstack
run_mlr --irs auto --ors lf --jlistwrap --json --jvstack cat $indir/line-term-lf-wrap.json
run_mlr --irs auto --ors lf --jlistwrap --json --jvstack cat $indir/line-term-crlf-wrap.json
run_mlr --jlistwrap --json --jvstack cat $indir/line-term-lf-wrap.json
run_mlr --jlistwrap --json --jvstack cat $indir/line-term-crlf-wrap.json

# ----------------------------------------------------------------
# AUX ENTRIES

run_mlr_for_auxents lecat --mono < $indir/line-ending-cr.bin
run_mlr_for_auxents lecat --mono < $indir/line-ending-lf.bin
run_mlr_for_auxents lecat --mono < $indir/line-ending-crlf.bin

run_mlr_for_auxents_no_output termcvt --cr2lf   < $indir/line-ending-cr.bin   > $outdir/line-ending-temp-1.bin
run_mlr_for_auxents_no_output termcvt --cr2crlf < $indir/line-ending-cr.bin   > $outdir/line-ending-temp-2.bin
run_mlr_for_auxents_no_output termcvt --lf2cr   < $indir/line-ending-lf.bin   > $outdir/line-ending-temp-3.bin
run_mlr_for_auxents_no_output termcvt --lf2crlf < $indir/line-ending-lf.bin   > $outdir/line-ending-temp-4.bin
run_mlr_for_auxents_no_output termcvt --crlf2cr < $indir/line-ending-crlf.bin > $outdir/line-ending-temp-5.bin
run_mlr_for_auxents_no_output termcvt --crlf2lf < $indir/line-ending-crlf.bin > $outdir/line-ending-temp-6.bin

run_mlr_for_auxents hex < $outdir/line-ending-temp-1.bin
run_mlr_for_auxents hex < $outdir/line-ending-temp-2.bin
run_mlr_for_auxents hex < $outdir/line-ending-temp-3.bin
run_mlr_for_auxents hex < $outdir/line-ending-temp-4.bin
run_mlr_for_auxents hex < $outdir/line-ending-temp-5.bin
run_mlr_for_auxents hex < $outdir/line-ending-temp-6.bin

# ================================================================
# A key feature of this regression script is that it can be invoked from any
# directory. Depending on the directory it's invoked from, the path to $outdir
# may vary. Nonetheless for debugging it's crucial that we echo out each
# command being executed -- here we use diff -I to skip the info lines and
# focus the test on program output per se.

echo
echo ================================================================
echo "Differences between $expfile and $outfile:"

# We run with 'set -e' all the way through this script, to die on error -- but
# for the diff command we want to trap the error and die with a message, especially
# when the diff is long.

set +e
diff -a -I '^mlr' -I '^cat' -C5 $expfile $outfile
status=$?

if [ $status -eq 0 ]; then
  echo "No differences were found between $expfile and $outfile"
  echo ================================================================
  echo
  echo ALL REGRESSION TESTS PASSED
  echo Tests completed: $num_completed
  exit 0
else
  echo
  echo "Differences were found between $expfile and $outfile !"
  echo
  echo Tests completed: $num_completed
  exit 1
fi
