// ================================================================
// LEXER

!whitespace : ' ' | '\t' | '\n' | '\r' ;

// ================================================================
// IMPORT

<< import "two/src/dsl" >>

// ================================================================
// PARSER

// ----------------------------------------------------------------
Root
  : StatementBlock
   << dsl.NewASTWithErrorReturn($0) >>
;

// ================================================================
StatementBlock

  // Empty statement. This allows for 'mlr put ""', as well as repeated semicolons.
  : empty
    << dsl.NewASTNodeWithErrorReturn(
        nil,
        dsl.NodeTypeStatementBlock,
        []interface{}{},
    ) >>

  | NonEmptyStatementBlock
    << dsl.WithErrorReturn($0) >>
;

// ----------------------------------------------------------------
NonEmptyStatementBlock
  // ---------------------- Terminal rules

  // Things not ending in a curly brace, like assignments -- and also do-while.
  : BracelessStatement
    << dsl.NewASTNodeWithErrorReturn(
        nil,
        dsl.NodeTypeStatementBlock,
        []interface{}{
              $0,
        },
    ) >>

  // Things ending in a curly brace, like for/do/while, begin/end, and pattern-action blocks
  | BracefulStatement
    << dsl.NewASTNodeWithErrorReturn(
        nil,
        dsl.NodeTypeStatementBlock,
        []interface{}{
          $0,
        },
    ) >>

  // ---------------------- Recursive rules

  // So statements can start with a semicolon
  | ";" StatementBlock
    << dsl.NewASTNodeWithErrorReturn(

  // Normal case for sequential statements like '$x=1; $y=2'
  | BracelessStatement ";" StatementBlock
    <<dsl.WithChildPrepended($2, $0) >>

  // For 'begin {...} ; $x=1'
  | BracefulStatement ";" StatementBlock
    <<dsl.WithChildPrepended($2, $0) >>

  // These are for things like 'begin {...} begin {...} ...' -- where people
  // shouldn't have to put semicolons after the closing curly braces.
  //
  // We get LR-1 conflicts with the following, so we need a pair of more
  // explicit lookahead-by-more production rules instead. (By using ternaries
  // we are effectively getting lookahead-by-two.)
  //
  // | BracefulStatement StatementBlock
  //    <<dsl.WithChildPrepended($1, $0) >>

  // E.g. 'begin {...} begin {...} $x=1'
  | BracefulStatement BracefulStatement StatementBlock
    <<dsl.WithTwoChildrenPreprended($2, $0, $1) >>

  // E.g. 'begin {...} $x=1'
  | BracefulStatement BracelessStatement
    << dsl.NewASTNodeWithErrorReturn(
        nil,
        dsl.NodeTypeStatementBlock,
        []interface{}{
          $0,
          $1,
        },
    ) >>

  // E.g. 'begin {...} $x=1 ;'
  | BracefulStatement BracelessStatement ";"
    << dsl.NewASTNodeWithErrorReturn(
        nil,
        dsl.NodeTypeStatementBlock,
        []interface{}{
          $0,
          $1,
        },
    ) >>

  | BracefulStatement BracelessStatement ";" NonEmptyStatementBlock
    <<dsl.WithTwoChildrenPreprended($3, $0, $1) >>
;

// ----------------------------------------------------------------
BracelessStatement
  : "x"
    << dsl.NewASTNodeWithErrorReturn(
        $0,
        dsl.NodeTypeBareBoolean,
        []interface{}{},
    ) >>
;

// ----------------------------------------------------------------
BracefulStatement
  : "{" StatementBlock "}"
    << dsl.NewASTNodeWithErrorReturn(
;
