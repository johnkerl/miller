// ================================================================
// LEXER

!whitespace : ' ' | '\t' | '\n' | '\r' ;
!comment : '#'  {.} '\n' ;

_letter : 'a'-'z' | 'A'-'Z' ;
_decdig : '0'-'9' ;
_idchar : _letter | _decdig | '_' ;

emit : 'e' 'm' 'i' 't' ;

// ================================================================
// IMPORT

<< import "two/src/dsl" >>

// ================================================================
// PARSER

// ----------------------------------------------------------------
Root
  : EmitStatement
   << dsl.NewASTWithErrorReturn($0) >>
;

// ----------------------------------------------------------------
// Examples:
//   emit @a
//   emit (@a, @b)
//   emit @a, "x", "y"
//   emit (@a, @b), "x", "y"
// First argument (single or in parentheses) must be non-indexed
// oosvar/localvar/fieldname, so we can use their names as keys in the emitted
// record.  These restrictions are enforced in the CST logic, to keep this
// parser/AST logic simpler.

EmitStatement
  : emit Emittable
    <<
      dsl.WithErrorReturn(dsl.NewASTNode(
      $0,
      dsl.NodeTypeEmitStatement,
      []interface{}{
        $1,
      }
      ))
      /*
      dsl.WithErrorReturn(dsl.NewASTNode(
      $0,
      dsl.NodeTypeEmitStatement,
      []interface{}{
        dsl.NewASTNodeTerminal(
          $1,
        ),
      }
      ))
      */
    >>

  | emit "(" EmittableList ")"
    << dsl.WithErrorReturn(dsl.NewASTNode(
    $0,
    dsl.NodeTypeEmitStatement,
    []interface{}{
      $2,
    }
    )) >>

  | emit Emittable "," EmitKeys
    << dsl.WithErrorReturn(dsl.NewASTNode(
    $0,
    dsl.NodeTypeEmitStatement,
    []interface{}{
      $1,
      $3,
    }
    )) >>

  | emit "(" EmittableList ")" "," EmitKeys
    << dsl.WithErrorReturn(dsl.NewASTNode(
    $0,
    dsl.NodeTypeEmitStatement,
    []interface{}{
      $2,
      $5,
    }
    )) >>
;

//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
EmittableList
  : Emittable
    << dsl.WithErrorReturn(dsl.NewASTNode(
    nil,
    dsl.NodeTypeEmittableList,
    []interface{}{
      $0,
    }
    )) >>

  // Allow trailing final comma, especially for multiline statements
  | Emittable "," EmittableList
    << dsl.PrependChild(
      $2,
      $0,
    ) >>
;

Emittable
  : Literal
;

//  - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
EmitKeys

  : Rvalue
    << dsl.WithErrorReturn(dsl.NewASTNode(
    nil,
    dsl.NodeTypeEmitKeys,
    []interface{}{
      $0,
    }
    )) >>

  | Rvalue "," EmitKeys
    << dsl.PrependChild(
      $2,
      $0,
    ) >>
;


// ----------------------------------------------------------------
Rvalue
  : Literal
    << dsl.WithErrorReturn(dsl.NewASTNode(
    nil,
    dsl.NodeTypeStringLiteral,
    []interface{}{
      $0,
    }
    )) >>
  | "(" Literal ")"
    << dsl.WithErrorReturn(dsl.NewASTNode(
    nil,
    dsl.NodeTypeStringLiteral,
    []interface{}{
      $1,
    }
    )) >>
  | "[" Literal "]"
    << dsl.WithErrorReturn(dsl.NewASTNode(
    nil,
    dsl.NodeTypeStringLiteral,
    []interface{}{
      $1,
    }
    )) >>
  | "[" Literal "," Literal "]"
    << dsl.WithErrorReturn(dsl.NewASTNode(
    nil,
    dsl.NodeTypeStringLiteral,
    []interface{}{
      $1,
      $2,
    }
    )) >>
;

Literal
  : "x" << dsl.WithErrorReturn(dsl.NewASTNode(
  $0,
  dsl.NodeTypeStringLiteral,
  []interface{}{}
  )) >>
  | "y" << dsl.WithErrorReturn(dsl.NewASTNode(
  $0,
  dsl.NodeTypeStringLiteral,
  []interface{}{}
  )) >>
  | "z" << dsl.WithErrorReturn(dsl.NewASTNode(
  $0,
  dsl.NodeTypeStringLiteral,
  []interface{}{}
  )) >>
;
